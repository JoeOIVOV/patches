diff -durN asterisk-11.17.1.orig/channels/chan_sip.c asterisk-11.17.1/channels/chan_sip.c
--- asterisk-11.17.1.orig/channels/chan_sip.c	2015-05-01 14:15:02.420637071 +1200
+++ asterisk-11.17.1/channels/chan_sip.c	2015-05-01 14:15:13.944387216 +1200
@@ -254,6 +254,8 @@
 #include "asterisk/data.h"
 #include "asterisk/aoc.h"
 #include "asterisk/message.h"
+#include "asterisk/bridging.h"
+#include "asterisk/bridging_features.h"
 #include "sip/include/sip.h"
 #include "sip/include/globals.h"
 #include "sip/include/config_parser.h"
@@ -440,6 +442,18 @@
 					<enum name="codec[x]">
 						<para>Preferred codec index number <replaceable>x</replaceable> (beginning with zero).</para>
 					</enum>
+                                        <enum name="donotdisturb">
+                                                <para>Is DoNotDisturb set on this peer (yes/no).</para>
+                                        </enum>
+                                        <enum name="callforward">
+                                                <para>The call forwarding extension for this peer.</para>
+                                        </enum>
+                                        <enum name="huntgroup">
+                                                <para>Is HuntGroup login set on this peer (yes/no).</para>
+                                        </enum>
+                                        <enum name="regcallid">
+                                                <para>The Call-ID of the REGISTER dialog.</para>
+                                        </enum>
 				</enumlist>
 			</parameter>
 		</syntax>
@@ -644,13 +658,14 @@
 	const char * const mediatype;
 	const char * const text;
 } subscription_types[] = {
-	{ NONE,		   "-",        "unknown",	             "unknown" },
-	/* RFC 4235: SIP Dialog event package */
-	{ DIALOG_INFO_XML, "dialog",   "application/dialog-info+xml", "dialog-info+xml" },
-	{ CPIM_PIDF_XML,   "presence", "application/cpim-pidf+xml",   "cpim-pidf+xml" },  /* RFC 3863 */
-	{ PIDF_XML,        "presence", "application/pidf+xml",        "pidf+xml" },       /* RFC 3863 */
-	{ XPIDF_XML,       "presence", "application/xpidf+xml",       "xpidf+xml" },       /* Pre-RFC 3863 with MS additions */
-	{ MWI_NOTIFICATION,	"message-summary", "application/simple-message-summary", "mwi" } /* RFC 3842: Mailbox notification */
+	{ NONE,		    "-",                "unknown",                            "unknown" },
+	{ DIALOG_INFO_XML,  "dialog",           "application/dialog-info+xml",        "dialog-info+xml" }, /* RFC 4235: SIP Dialog event package */
+	{ CPIM_PIDF_XML,    "presence",         "application/cpim-pidf+xml",          "cpim-pidf+xml" },  /* RFC 3863 */
+	{ PIDF_XML,         "presence",         "application/pidf+xml",               "pidf+xml" },       /* RFC 3863 */
+	{ XPIDF_XML,        "presence",         "application/xpidf+xml",              "xpidf+xml" },       /* Pre-RFC 3863 with MS additions */
+	{ MWI_NOTIFICATION, "message-summary",  "application/simple-message-summary", "mwi" }, /* RFC 3842: Mailbox notification */
+	{ FEATURE_EVENTS,   "as-feature-event", "application/x-as-feature-event+xml", "as-feature-event" }, /* EMCA-323 application server feature events */
+	{ REMOTECC_XML,     "refer",            "application/x-cisco-remotecc-request+xml", "remotecc" } /* Cisco remotecc request/respones */
 };
 
 /*! \brief The core structure to setup dialogs. We parse incoming messages by using
@@ -844,6 +859,75 @@
 
 static enum sip_debug_e sipdebug;
 
+/*! \brief Remotecc applications */
+enum {
+	REMOTECC_CONFLIST = 1,
+	REMOTECC_CALLBACK = 2
+};
+
+/*! \brief Contains the parsed-out xml elements from a remotecc request */
+struct remotecc_dialog {
+	char *callid;
+	char *localtag;
+	char *remotetag;
+};
+
+struct remotecc_data {
+	char *softkeyevent;
+	struct remotecc_dialog dialogid;
+	struct remotecc_dialog consultdialogid;
+	struct remotecc_dialog joindialogid;
+	int applicationid;
+	int confid;
+	char *usercalldata;
+};
+
+/*! \brief Information required to start or join an ad-hoc conference */
+struct conference_data {
+	struct sip_pvt *pvt;
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(callid);
+		AST_STRING_FIELD(tag);
+		AST_STRING_FIELD(theirtag);
+		AST_STRING_FIELD(join_callid);
+		AST_STRING_FIELD(join_tag);
+		AST_STRING_FIELD(join_theirtag);
+	);
+};
+
+/*! \brief Informtion required to park a call */
+struct park_data {
+	struct sip_pvt *pvt;
+	struct sip_request req;
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(context);
+		AST_STRING_FIELD(callid);
+		AST_STRING_FIELD(tag);
+		AST_STRING_FIELD(theirtag);
+	);
+};
+
+/*! \brief Information required to record a call */
+struct record_data {
+	int outgoing:1;
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(callid);
+		AST_STRING_FIELD(tag);
+		AST_STRING_FIELD(theirtag);
+	);
+};
+
+/*! \brief Information required to start or join an ad-hoc conference */
+struct join_data {
+	struct sip_pvt *pvt;
+	struct sip_peer *peer;
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(callid);
+		AST_STRING_FIELD(tag);
+		AST_STRING_FIELD(theirtag);
+	);
+};
+
 /*! \brief extra debugging for 'text' related events.
  *  At the moment this is set together with sip_debug_console.
  *  \note It should either go away or be implemented properly.
@@ -991,6 +1075,13 @@
 	.initial_handler = cc_esc_publish_handler,
 	.modify_handler = cc_esc_publish_handler,
 };
+
+static int presence_esc_publish_handler(struct sip_pvt *pvt, struct sip_request *req, struct event_state_compositor *esc, struct sip_esc_entry *esc_entry);
+
+static const struct sip_esc_publish_callbacks presence_esc_publish_callbacks = {
+	.initial_handler = presence_esc_publish_handler,
+	.modify_handler = presence_esc_publish_handler,
+};
 #endif
 
 /*!
@@ -1013,6 +1104,7 @@
 } event_state_compositors [] = {
 #ifdef HAVE_LIBXML2
 	{CALL_COMPLETION, "call-completion", &cc_esc_publish_callbacks},
+	{PRESENCE,        "presence",        &presence_esc_publish_callbacks}
 #endif
 };
 
@@ -1191,6 +1283,10 @@
 static int temp_pvt_init(void *);
 static void temp_pvt_cleanup(void *);
 
+/*! \brief  The ad-hoc conference list */
+static AST_LIST_HEAD_STATIC(conferencel, sip_conference);
+static int next_confid = 0;
+
 /*! \brief A per-thread temporary pvt structure */
 AST_THREADSTORAGE_CUSTOM(ts_temp_pvt, temp_pvt_init, temp_pvt_cleanup);
 
@@ -1289,6 +1385,7 @@
 /*--- PBX interface functions */
 static struct ast_channel *sip_request_call(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *dest, int *cause);
 static int sip_devicestate(const char *data);
+static int sip_presencestate(const char *data, char **subtype, char **message);
 static int sip_sendtext(struct ast_channel *ast, const char *text);
 static int sip_call(struct ast_channel *ast, const char *dest, int timeout);
 static int sip_sendhtml(struct ast_channel *chan, int subclass, const char *data, int datalen);
@@ -1324,6 +1421,7 @@
 static int transmit_response_with_sdp(struct sip_pvt *p, const char *msg, const struct sip_request *req, enum xmittype reliable, int oldsdp, int rpid);
 static int transmit_response_with_unsupported(struct sip_pvt *p, const char *msg, const struct sip_request *req, const char *unsupported);
 static int transmit_response_with_auth(struct sip_pvt *p, const char *msg, const struct sip_request *req, const char *rand, enum xmittype reliable, const char *header, int stale);
+static int transmit_response_with_optionsind(struct sip_pvt *p, const struct sip_request *req, struct sip_peer *peer);
 static int transmit_provisional_response(struct sip_pvt *p, const char *msg, const struct sip_request *req, int with_sdp);
 static int transmit_response_with_allow(struct sip_pvt *p, const char *msg, const struct sip_request *req, enum xmittype reliable);
 static void transmit_fake_auth_response(struct sip_pvt *p, struct sip_request *req, enum xmittype reliable);
@@ -1337,6 +1435,7 @@
 static int transmit_info_with_vidupdate(struct sip_pvt *p);
 static int transmit_message(struct sip_pvt *p, int init, int auth);
 static int transmit_refer(struct sip_pvt *p, const char *dest);
+static int transmit_refer_with_content(struct sip_pvt *p, const char *type, const char *content);
 static int transmit_notify_with_mwi(struct sip_pvt *p, int newmsgs, int oldmsgs, const char *vmexten);
 static int transmit_notify_with_sipfrag(struct sip_pvt *p, int cseq, char *message, int terminate);
 static int transmit_cc_notify(struct ast_cc_agent *agent, struct sip_pvt *subscription, enum sip_cc_notify_state state);
@@ -1346,7 +1445,11 @@
 static void copy_request(struct sip_request *dst, const struct sip_request *src);
 static void receive_message(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, const char *e);
 static void parse_moved_contact(struct sip_pvt *p, struct sip_request *req, char **name, char **number, int set_call_forward);
-static int sip_send_mwi_to_peer(struct sip_peer *peer, int cache_only);
+static int sip_send_mwi(struct sip_peer *peer, int cache_only);
+static int sip_send_bulkupdate(struct sip_peer *peer);
+static void extensionstate_subscriptions(struct sip_peer *peer, int force);
+static void register_peer_aliases(struct sip_peer *peer, int force);
+static void expire_peer_aliases(struct sip_peer *peer);
 
 /* Misc dialog routines */
 static int __sip_autodestruct(const void *data);
@@ -1370,6 +1473,8 @@
 static int sip_sipredirect(struct sip_pvt *p, const char *dest);
 static int is_method_allowed(unsigned int *allowed_methods, enum sipmethod method);
 
+static void start_record_thread(const char *callid, const char *tag, const char *theirtag, int outgoing);
+
 /*--- Codec handling / SDP */
 static void try_suggested_sip_codec(struct sip_pvt *p);
 static const char *get_sdp_iterate(int* start, struct sip_request *req, const char *name);
@@ -1422,10 +1527,11 @@
 static int check_rtp_timeout(struct sip_pvt *dialog, time_t t);
 static int reload_config(enum channelreloadreason reason);
 static void add_diversion(struct sip_request *req, struct sip_pvt *pvt);
+static void add_join(struct sip_request *req, struct sip_pvt *pvt);
 static int expire_register(const void *data);
 static void *do_monitor(void *data);
 static int restart_monitor(void);
-static void peer_mailboxes_to_str(struct ast_str **mailbox_str, struct sip_peer *peer);
+static void get_peer_mailboxes(struct ast_str **mailbox_str, struct sip_peer *peer);
 static struct ast_variable *copy_vars(struct ast_variable *src);
 static int dialog_find_multiple(void *obj, void *arg, int flags);
 static struct ast_channel *sip_pvt_lock_full(struct sip_pvt *pvt);
@@ -1494,6 +1600,9 @@
 static char *sip_do_debug_peer(int fd, const char *arg);
 static char *sip_do_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 static char *sip_cli_notify(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+static char *sip_cli_donotdisturb(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+static char *sip_cli_callforward(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+static char *sip_cli_huntgroup(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 static char *sip_set_history(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 static int sip_dtmfmode(struct ast_channel *chan, const char *data);
 static int sip_addheader(struct ast_channel *chan, const char *data);
@@ -1515,6 +1624,7 @@
 static inline int sip_debug_test_pvt(struct sip_pvt *p);
 static void append_history_full(struct sip_pvt *p, const char *fmt, ...);
 static void sip_dump_history(struct sip_pvt *dialog);
+static void parse_rtp_stats(struct sip_pvt *pvt, struct sip_request *req);
 
 /*--- Device object handling */
 static struct sip_peer *build_peer(const char *name, struct ast_variable *v, struct ast_variable *alt, int realtime, int devstate_only);
@@ -1580,9 +1690,14 @@
 static int transmit_state_notify(struct sip_pvt *p, struct state_notify_data *data, int full, int timeout);
 static void update_connectedline(struct sip_pvt *p, const void *data, size_t datalen);
 static void update_redirecting(struct sip_pvt *p, const void *data, size_t datalen);
+static int sip_send_donotdisturb(struct sip_peer *peer);
+static int sip_send_callforward(struct sip_peer *peer);
+static int sip_send_huntgroup(struct sip_peer *peer);
 static int get_domain(const char *str, char *domain, int len);
 static void get_realm(struct sip_pvt *p, const struct sip_request *req);
-static char *get_content(struct sip_request *req);
+static char *get_content(struct sip_request *req, int start, int end);
+static int find_boundary(struct sip_request *req, const char *boundary, int start, int *done);
+const char *find_content_type(struct sip_request *req);
 
 /*-- TCP connection handling ---*/
 static void *_sip_tcp_helper_thread(struct ast_tcptls_session_instance *tcptls_session);
@@ -1629,7 +1744,7 @@
 static int handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock);
 static int handle_request_update(struct sip_pvt *p, struct sip_request *req);
 static int handle_request_invite(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, uint32_t seqno, int *recount, const char *e, int *nounlock);
-static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, uint32_t seqno, int *nounlock);
+static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, uint32_t seqno, const char *e, int *nounlock);
 static int handle_request_bye(struct sip_pvt *p, struct sip_request *req);
 static int handle_request_register(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *sin, const char *e);
 static int handle_request_cancel(struct sip_pvt *p, struct sip_request *req);
@@ -1691,6 +1806,7 @@
 	.properties = AST_CHAN_TP_WANTSJITTER | AST_CHAN_TP_CREATESJITTER,
 	.requester = sip_request_call,			/* called with chan unlocked */
 	.devicestate = sip_devicestate,			/* called with chan unlocked (not chan-specific) */
+	.presencestate = sip_presencestate,		/* called with chan unlocked (not chan-specific) */
 	.call = sip_call,			/* called with chan locked */
 	.send_html = sip_sendhtml,
 	.hangup = sip_hangup,			/* called with chan locked */
@@ -3269,9 +3385,27 @@
 	if (dialog->relatedpeer && dialog->relatedpeer->mwipvt == dialog) {
 		dialog->relatedpeer->mwipvt = dialog_unref(dialog->relatedpeer->mwipvt, "delete ->relatedpeer->mwipvt");
 	}
+	/* Remove link from peer to subscription for Feature Events */
+	if (dialog->relatedpeer && dialog->relatedpeer->fepvt == dialog) {
+		dialog->relatedpeer->fepvt = dialog_unref(dialog->relatedpeer->fepvt, "delete ->relatedpeer->fepvt");
+	}
 	if (dialog->relatedpeer && dialog->relatedpeer->call == dialog) {
 		dialog->relatedpeer->call = dialog_unref(dialog->relatedpeer->call, "unset the relatedpeer->call field in tandem with relatedpeer field itself");
 	}
+	if (dialog->conference) {
+		ao2_ref(dialog->conference, -1);
+		dialog->conference = NULL;
+	}
+	if (dialog->park_event_sub) {
+		ast_event_unsubscribe(dialog->park_event_sub);
+		dialog->park_event_sub = NULL;
+	}
+	if (dialog->recordoutpvt) {
+		dialog->recordoutpvt = dialog_unref(dialog->recordoutpvt, "delete ->recordoutpvt");
+	}
+	if (dialog->recordinpvt) {
+		dialog->recordinpvt = dialog_unref(dialog->recordinpvt, "delete ->recordinpvt");
+	}
 
 	/* remove all current packets in this dialog */
 	while((cp = dialog->packets)) {
@@ -5030,6 +5164,85 @@
 		destroy_mailbox(mailbox);
 }
 
+static void destroy_alias(struct sip_alias *alias)
+{
+	if (alias->peer) {
+		alias->peer->lastms = -1;
+
+		if (alias->peer->socket.tcptls_session) {
+			ao2_ref(alias->peer->socket.tcptls_session, -1);
+		} else if (alias->peer->socket.ws_session) {
+			ast_websocket_unref(alias->peer->socket.ws_session);
+		}
+
+		ast_string_field_set(alias->peer, fullcontact, "");
+		ast_string_field_set(alias->peer, username, "");
+		ast_string_field_set(alias->peer, useragent, "");
+
+		if (!ast_sockaddr_isnull(&alias->peer->addr)) {
+			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n",
+				alias->peer->name);
+			ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", alias->peer->name);
+			register_peer_exten(alias->peer, FALSE);
+
+			memset(&alias->peer->addr, 0, sizeof(alias->peer->addr));
+		}
+		sip_unref_peer(alias->peer, "destroy_alias removing peer ref");
+	}
+	ast_free(alias->name);
+	ast_free(alias);
+}
+
+static void clear_peer_aliases(struct sip_peer *peer)
+{
+	struct sip_alias *alias;
+
+	while ((alias = AST_LIST_REMOVE_HEAD(&peer->aliases, entry)))
+		destroy_alias(alias);
+}
+
+/*! Destroy extension state subscription */
+static void destroy_subscription(struct sip_subscription *subscription)
+{
+	if (subscription->pvt) {
+		dialog_unlink_all(subscription->pvt);
+		dialog_unref(subscription->pvt, "destroying subscription");
+	}
+	ast_string_field_free_memory(subscription);
+	ast_free(subscription);
+}
+
+/* Destroy all peer-related extension state subscriptions */
+static void clear_peer_subscriptions(struct sip_peer *peer)
+{
+	struct sip_subscription *subscription;
+
+	while ((subscription = AST_LIST_REMOVE_HEAD(&peer->subscriptions, entry)))
+		destroy_subscription(subscription);
+}
+
+static void destroy_callback(struct sip_peer *peer)
+{
+	ast_extension_state_del(peer->callback->stateid, NULL);
+	sip_unref_peer(peer, "destroy_callback: removing callback ref");
+	ast_free(peer->callback->exten);
+	ast_free(peer->callback);
+}
+
+static void destroy_selected(struct sip_selected *selected)
+{
+	ast_string_field_free_memory(selected);
+	ast_free(selected);
+}
+
+static void clear_peer_selected(struct sip_peer *peer)
+{
+	struct sip_selected *selected;
+
+	while ((selected = AST_LIST_REMOVE_HEAD(&peer->selected, entry)))
+		destroy_selected(selected);
+}
+
 static void sip_destroy_peer_fn(void *peer)
 {
 	sip_destroy_peer(peer);
@@ -5046,6 +5259,9 @@
 	 * happening right now.
 	 */
 	clear_peer_mailboxes(peer);
+	clear_peer_aliases(peer);
+	clear_peer_subscriptions(peer);
+	clear_peer_selected(peer);
 
 	if (peer->outboundproxy) {
 		ao2_ref(peer->outboundproxy, -1);
@@ -5062,7 +5278,15 @@
 		dialog_unlink_all(peer->mwipvt);
 		peer->mwipvt = dialog_unref(peer->mwipvt, "unreffing peer->mwipvt");
 	}
+	if (peer->fepvt) {	/* We have an active subscription, delete it */
+		dialog_unlink_all(peer->fepvt);
+		peer->fepvt = dialog_unref(peer->fepvt, "unreffing peer->fepvt");
+	}
 
+	if (peer->callback) {
+		destroy_callback(peer);
+		peer->callback = NULL;
+	}
 	if (peer->chanvars) {
 		ast_variables_destroy(peer->chanvars);
 		peer->chanvars = NULL;
@@ -5688,6 +5912,29 @@
 	*to_sock = *from_sock;
 }
 
+static void copy_pvt_data(struct sip_pvt *to_pvt, const struct sip_pvt *from_pvt)
+{
+	to_pvt->sa = from_pvt->sa;
+	to_pvt->recv = from_pvt->recv;
+	copy_socket_data(&to_pvt->socket, &from_pvt->socket);
+	ast_copy_flags(&to_pvt->flags[0], &from_pvt->flags[0], SIP_FLAGS_TO_COPY);
+	ast_copy_flags(&to_pvt->flags[1], &from_pvt->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
+	ast_copy_flags(&to_pvt->flags[2], &from_pvt->flags[2], SIP_PAGE3_FLAGS_TO_COPY);
+
+	/* Recalculate our side, and recalculate Call ID */
+	ast_sip_ouraddrfor(&to_pvt->sa, &to_pvt->ourip, to_pvt);
+	change_callid_pvt(to_pvt, NULL);
+
+	ast_string_field_set(to_pvt, tohost, from_pvt->tohost);
+	to_pvt->portinuri = from_pvt->portinuri;
+	to_pvt->fromdomainport = from_pvt->fromdomainport;
+
+	ast_string_field_set(to_pvt, fullcontact, from_pvt->fullcontact);
+	ast_string_field_set(to_pvt, username, from_pvt->username);
+	ast_string_field_set(to_pvt, fromuser, from_pvt->fromuser);
+	ast_string_field_set(to_pvt, fromname, from_pvt->fromname);
+}
+
 /*! \brief Initialize DTLS-SRTP support on an RTP instance */
 static int dialog_initialize_dtls_srtp(const struct sip_pvt *dialog, struct ast_rtp_instance *rtp, struct sip_srtp **srtp)
 {
@@ -5962,6 +6209,10 @@
 	if (peer->fromdomainport)
 		dialog->fromdomainport = peer->fromdomainport;
 	dialog->callingpres = peer->callingpres;
+	dialog->donotdisturb = peer->donotdisturb;
+	if (!ast_strlen_zero(peer->callforward)) {
+		ast_string_field_set(dialog, callforward, peer->callforward);
+	}
 
 	return 0;
 }
@@ -6132,8 +6383,17 @@
 		}
 	}
 
+	if (p->donotdisturb && ast_test_flag(&p->flags[2], SIP_PAGE3_DND_BUSY)) {
+		ast_queue_control(p->owner, AST_CONTROL_BUSY);
+		return 0;
+	} else if (!ast_strlen_zero(p->callforward)) {
+		ast_channel_call_forward_set(ast, p->callforward);
+		ast_queue_control(p->owner, AST_CONTROL_BUSY);
+		return 0;
+	}
+
 	/* Check whether there is vxml_url, distinctive ring variables */
-	headp=ast_channel_varshead(ast);
+	headp = ast_channel_varshead(ast);
 	AST_LIST_TRAVERSE(headp, current, entries) {
 		/* Check whether there is a VXML_URL variable */
 		if (!p->options->vxml_url && !strcasecmp(ast_var_name(current), "VXML_URL")) {
@@ -6360,6 +6620,9 @@
 	/* Remove link from peer to subscription of MWI */
 	if (p->relatedpeer && p->relatedpeer->mwipvt == p)
 		p->relatedpeer->mwipvt = dialog_unref(p->relatedpeer->mwipvt, "delete ->relatedpeer->mwipvt");
+	/* Remove link from peer to subscription for Feature Events */
+	if (p->relatedpeer && p->relatedpeer->fepvt)
+		p->relatedpeer->fepvt = dialog_unref(p->relatedpeer->fepvt, "delete ->relatedpeer->fepvt");
 	if (p->relatedpeer && p->relatedpeer->call == p)
 		p->relatedpeer->call = dialog_unref(p->relatedpeer->call, "unset the relatedpeer->call field in tandem with relatedpeer field itself");
 	
@@ -6920,6 +7183,11 @@
 		if (sipdebug)
 			ast_debug(1, "update_call_counter(%s) - decrement call limit counter on hangup\n", p->username);
 		update_call_counter(p, DEC_CALL_LIMIT);
+		if (!ast_test_flag(&p->flags[0], SIP_INC_COUNT) && p->relatedpeer) {
+			ao2_lock(p->relatedpeer);
+			clear_peer_selected(p->relatedpeer);
+			ao2_unlock(p->relatedpeer);
+		}
 	}
 
 	/* Determine how to disconnect */
@@ -7729,6 +7997,8 @@
 	case AST_CONTROL_FLASH: /* We don't currently handle AST_CONTROL_FLASH here, but it is expected, so we don't need to warn either. */
 		res = -1;
 		break;
+	case AST_CONTROL_MCID:
+		break;
 	case AST_CONTROL_PVT_CAUSE_CODE: /* these should be handled by the code in channel.c */
 	case -1:
 		res = -1;
@@ -8160,10 +8430,9 @@
 AST_THREADSTORAGE(sip_content_buf);
 
 /*! \brief Get message body content */
-static char *get_content(struct sip_request *req)
+static char *get_content(struct sip_request *req, int start, int end)
 {
 	struct ast_str *str;
-	int i;
 
 	if (!(str = ast_str_thread_get(&sip_content_buf, 128))) {
 		return NULL;
@@ -8171,8 +8440,8 @@
 
 	ast_str_reset(str);
 
-	for (i = 0; i < req->lines; i++) {
-		if (ast_str_append(&str, 0, "%s\n", REQ_OFFSET_TO_STR(req, line[i])) < 0) {
+	while (start < req->lines && start <= end) {
+		if (ast_str_append(&str, 0, "%s\n", REQ_OFFSET_TO_STR(req, line[start++])) < 0) {
 			return NULL;
 		}
 	}
@@ -8180,6 +8449,68 @@
 	return ast_str_buffer(str);
 }
 
+/*! \brief find the content boundary */
+static int find_boundary(struct sip_request *req, const char *boundary, int start, int *done)
+{
+	char *line;
+	int len = strlen(boundary);
+
+	for (*done = 0; start < req->lines; start++) {
+		line = REQ_OFFSET_TO_STR(req, line[start]);
+		if (strncmp(line, "--", 2)) {
+			continue;
+		}
+		if (!strncmp(boundary, line + 2, len)) {
+			if (!strcmp(line + 2 + len, "--")) {
+				*done = 1;
+			} else if (strcmp(line + 2 + len, "")) {
+				continue;
+			}
+			return start;
+		}
+	}
+
+	return -1;
+}
+
+/*! \brief get the content type from either the Content-Type header or the Content-Type of the first part */
+const char *find_content_type(struct sip_request *req)
+{
+	const char *type = sip_get_header(req, "Content-Type");
+	char *boundary;
+	const char *line;
+	int start, done;
+
+	if (ast_strlen_zero(type) || strncasecmp(type, "multipart/mixed", 15)) {
+		return type;
+	}
+
+	if ((boundary = strcasestr(type, ";boundary="))) {
+		boundary += 10;
+	} else if ((boundary = strcasestr(type, "; boundary="))) {
+		boundary += 11;
+	} else {
+		return "";
+	}
+	boundary = ast_strdupa(boundary);
+	boundary = strsep(&boundary, ";");
+
+	if ((start = find_boundary(req, boundary, 0, &done)) == -1) {
+		return "";
+	}
+
+	for (++start; start < req->lines; start++) {
+		line = REQ_OFFSET_TO_STR(req, line[start]);
+		if (!strncasecmp(line, "Content-Type:", 13)) {
+			return ast_skip_blanks(line + 13);
+		} else if (!strcasecmp(line, "")) {
+			break;
+		}
+	}
+
+	return "";
+}
+
 /*! \brief Read RTP from network */
 static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p, int *faxdetect)
 {
@@ -11268,13 +11599,16 @@
  *  is supported for this dialog. */
 static int add_supported(struct sip_pvt *pvt, struct sip_request *req)
 {
-	int res;
+	struct ast_str *str = ast_str_alloca(128);
+
+	ast_str_append(&str, -1, "replaces");
 	if (st_get_mode(pvt, 0) != SESSION_TIMER_MODE_REFUSE) {
-		res = add_header(req, "Supported", "replaces, timer");
-	} else {
-		res = add_header(req, "Supported", "replaces");
+		ast_str_append(&str, -1, ",timer");
 	}
-	return res;
+	if (ast_test_flag(&pvt->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER) && pvt->method == SIP_REGISTER) {
+		ast_str_append(&str, -1, ",X-cisco-sis-6.0.0");
+	}
+	return add_header(req, "Supported", ast_str_buffer(str));
 }
 
 /*! \brief Add header to SIP message */
@@ -12177,6 +12511,39 @@
 	return send_response(p, &resp, reliable, seqno);
 }
 
+/*! \brief Respond with an optionind response */
+static int transmit_response_with_optionsind(struct sip_pvt *p, const struct sip_request *req, struct sip_peer *peer)
+{
+	struct sip_request resp;
+
+	ast_copy_flags(&p->flags[0], &peer->flags[0], SIP_FLAGS_TO_COPY);
+	ast_copy_flags(&p->flags[1], &peer->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
+	ast_copy_flags(&p->flags[2], &peer->flags[2], SIP_PAGE3_FLAGS_TO_COPY);
+
+	respprep(&resp, p, "200 OK", req);
+
+	add_header(&resp, "Content-Type", "application/x-cisco-remotecc-response+xml");
+	add_date(&resp);
+
+	add_content(&resp, "<x-cisco-remotecc-response>\n");
+	add_content(&resp, "<response>\n");
+	add_content(&resp, "<code>200</code>\n");
+	add_content(&resp, "<optionsind>\n");
+	add_content(&resp, "<combine max=\"6\">\n");
+	add_content(&resp, "<remotecc><status /></remotecc>\n");
+	add_content(&resp, "<service-control />\n");
+	add_content(&resp, "</combine>\n");
+	add_content(&resp, "<dialog usage=\"hook status\"><unot /></dialog>\n");
+	add_content(&resp, "<dialog usage=\"shared line\"><unot /></dialog>\n");
+	add_content(&resp, "<presence usage=\"blf speed dial\"><unot /></presence>\n");
+	add_content(&resp, "<joinreq></joinreq>\n");
+	add_content(&resp, "</optionsind>\n");
+	add_content(&resp, "</response>\n");
+	add_content(&resp, "</x-cisco-remotecc-response>\n");
+
+	return send_response(p, &resp, XMIT_RELIABLE, 0);
+}
+
 /*!
  \brief Extract domain from SIP To/From header
  \return -1 on error, 1 if domain string is empty, 0 if domain was properly extracted
@@ -12401,7 +12768,6 @@
 {
 	struct ast_str *tmp = ast_str_alloca(256);
 	char tmp2[256];
-	char lid_name_buf[128];
 	char *lid_num;
 	char *lid_name;
 	int lid_pres;
@@ -12409,7 +12775,6 @@
 	const char *privacy = NULL;
 	const char *screen = NULL;
 	struct ast_party_id connected_id;
-	const char *anonymous_string = "\"Anonymous\" <sip:anonymous@anonymous.invalid>";
 
 	if (!ast_test_flag(&p->flags[0], SIP_SENDRPID)) {
 		return 0;
@@ -12420,14 +12785,10 @@
 	}
 	connected_id = ast_channel_connected_effective_id(p->owner);
 	lid_num = S_COR(connected_id.number.valid, connected_id.number.str, NULL);
-	if (!lid_num) {
-		return 0;
-	}
 	lid_name = S_COR(connected_id.name.valid, connected_id.name.str, NULL);
-	if (!lid_name) {
-		lid_name = lid_num;
+	if (!lid_num && !lid_name) {
+		return 0;
 	}
-	ast_escape_quoted(lid_name, lid_name_buf, sizeof(lid_name_buf));
 	lid_pres = ast_party_id_presentation(&connected_id);
 
 	if (((lid_pres & AST_PRES_RESTRICTION) != AST_PRES_ALLOWED) &&
@@ -12445,28 +12806,34 @@
 		fromdomain = ast_sockaddr_stringify_host_remote(&p->ourip);
 	}
 
-	lid_num = ast_uri_encode(lid_num, tmp2, sizeof(tmp2), ast_uri_sip_user);
+	if (!ast_strlen_zero(lid_name)) {
+		ast_escape_quoted(lid_name, tmp2, sizeof(tmp2));
+		ast_str_append(&tmp, -1, "\"%s\" ", tmp2);
+	}
+	ast_str_append(&tmp, -1, "<sip:");
+	if (!ast_strlen_zero(lid_num)) {
+		ast_uri_encode(lid_num, tmp2, sizeof(tmp2), ast_uri_sip_user);
+		ast_str_append(&tmp, -1, "%s@", tmp2);
+	}
+	ast_str_append(&tmp, -1, "%s>", fromdomain);
 
 	if (ast_test_flag(&p->flags[0], SIP_SENDRPID_PAI)) {
 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_TRUST_ID_OUTBOUND) != SIP_PAGE2_TRUST_ID_OUTBOUND_LEGACY) {
 			/* trust_id_outbound = yes - Always give full information even if it's private, but append a privacy header
 			 * When private data is included */
-			ast_str_set(&tmp, -1, "\"%s\" <sip:%s@%s>", lid_name_buf, lid_num, fromdomain);
 			if ((lid_pres & AST_PRES_RESTRICTION) != AST_PRES_ALLOWED) {
 				add_header(req, "Privacy", "id");
 			}
 		} else {
 			/* trust_id_outbound = legacy - behave in a non RFC-3325 compliant manner and send anonymized data when
 			 * when handling private data. */
-			if ((lid_pres & AST_PRES_RESTRICTION) == AST_PRES_ALLOWED) {
-				ast_str_set(&tmp, -1, "\"%s\" <sip:%s@%s>", lid_name_buf, lid_num, fromdomain);
-			} else {
-				ast_str_set(&tmp, -1, "%s", anonymous_string);
+			if ((lid_pres & AST_PRES_RESTRICTION) != AST_PRES_ALLOWED) {
+				ast_str_set(&tmp, -1, "\"Anonymous\" <sip:anonymous@anonymous.invalid>");
 			}
 		}
 		add_header(req, "P-Asserted-Identity", ast_str_buffer(tmp));
 	} else {
-		ast_str_set(&tmp, -1, "\"%s\" <sip:%s@%s>;party=%s", lid_name_buf, lid_num, fromdomain, p->outgoing_call ? "calling" : "called");
+		ast_str_append(&tmp, -1, ";party=%s", p->outgoing_call ? "calling" : "called");
 
 		switch (lid_pres) {
 		case AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED:
@@ -12492,11 +12859,7 @@
 		case AST_PRES_NUMBER_NOT_AVAILABLE:
 			break;
 		default:
-			if ((lid_pres & AST_PRES_RESTRICTION) != AST_PRES_ALLOWED) {
-				privacy = "full";
-			}
-			else
-				privacy = "off";
+			privacy = (lid_pres & AST_PRES_RESTRICTION) != AST_PRES_ALLOWED ? "full" : "off";
 			screen = "no";
 			break;
 		}
@@ -12506,6 +12869,13 @@
 		}
 
 		add_header(req, "Remote-Party-ID", ast_str_buffer(tmp));
+
+		if (ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+			ast_str_reset(tmp);
+			ast_str_append(&tmp, -1, "<urn:x-cisco-remotecc:callinfo>; orientation=%s", p->outgoing_call ? "from" : "to");
+
+			add_header(req, "Call-Info", ast_str_buffer(tmp));
+		}
 	}
 	return 0;
 }
@@ -12731,9 +13101,17 @@
 	}
 
 	ast_str_append(m_buf, 0, " %d", rtp_code);
-	ast_str_append(a_buf, 0, "a=rtpmap:%d %s/%u\r\n", rtp_code, subtype, rate);
 
+	if (format->id == AST_FORMAT_H264 && ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		ast_str_append(a_buf, 0, "b=TIAS:%d\r\n", p->maxcallbitrate);
+	}
+
+	ast_str_append(a_buf, 0, "a=rtpmap:%d %s/%d\r\n", rtp_code, subtype, rate);
 	ast_format_sdp_generate(format, rtp_code, a_buf);
+
+	if (format->id == AST_FORMAT_H264 && ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		ast_str_append(a_buf, 0, "a=imageattr:%d recv [x=640,y=480,q=0.50]\r\n", rtp_code);
+	}
 }
 
 /*! \brief Add text codec offer to SDP offer/answer body in INVITE or 200 OK */
@@ -13122,8 +13500,9 @@
 				       get_sdp_rtp_profile(p, v_a_crypto ? 1 : 0, p->vrtp));
 
 			/* Build max bitrate string */
-			if (p->maxcallbitrate)
+			if (p->maxcallbitrate && !ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
 				snprintf(bandwidth, sizeof(bandwidth), "b=CT:%d\r\n", p->maxcallbitrate);
+			}
 			if (debug) {
 				ast_verbose("Video is at %s\n", ast_sockaddr_stringify(&vdest));
 			}
@@ -13159,6 +13538,11 @@
 		}
 
 		/* Start building generic SDP headers */
+		if (ast_test_flag(&p->flags[2], SIP_PAGE3_RELAY_NEAREND)) {
+			ast_str_append(&a_audio, 0, "a=label:X-relay-nearend\r\n");
+		} else if (ast_test_flag(&p->flags[2], SIP_PAGE3_RELAY_FAREND)) {
+			ast_str_append(&a_audio, 0, "a=label:X-relay-farend\r\n");
+		}
 
 		/* We break with the "recommendation" and send our IP, in order that our
 		   peer doesn't have to ast_gethostbyname() us */
@@ -13804,8 +14188,6 @@
 	const char *d = NULL;	/* domain in from header */
 	const char *urioptions = "";
 	int ourport;
-	int cid_has_name = 1;
-	int cid_has_num = 1;
 	struct ast_party_id connected_id;
 
 	if (ast_test_flag(&p->flags[0], SIP_USEREQPHONE)) {
@@ -13854,7 +14236,7 @@
 
 	/* Hey, it's a NOTIFY! See if they've configured a mwi_from.
 	 * XXX Right now, this logic works because the only place that mwi_from
-	 * is set on the sip_pvt is in sip_send_mwi_to_peer. If things changed, then
+	 * is set on the sip_pvt is in sip_send_mwi. If things changed, then
 	 * we might end up putting the mwi_from setting into other types of NOTIFY
 	 * messages as well.
 	 */
@@ -13863,13 +14245,8 @@
 	}
 
 	if (ast_strlen_zero(l)) {
-		cid_has_num = 0;
 		l = default_callerid;
 	}
-	if (ast_strlen_zero(n)) {
-		cid_has_name = 0;
-		n = l;
-	}
 
 	/* Allow user to be overridden */
 	if (!ast_strlen_zero(p->fromuser))
@@ -13891,15 +14268,17 @@
 
 	ast_copy_string(tmp_l, l, sizeof(tmp_l));
 	if (sip_cfg.pedanticsipchecking) {
-		ast_escape_quoted(n, tmp_n, sizeof(tmp_n));
-		n = tmp_n;
+		if (!ast_strlen_zero(n)) {
+			ast_escape_quoted(n, tmp_n, sizeof(tmp_n));
+			n = tmp_n;
+		}
 		ast_uri_encode(l, tmp_l, sizeof(tmp_l), ast_uri_sip_user);
 	}
 
 	ourport = (p->fromdomainport && (p->fromdomainport != STANDARD_SIP_PORT)) ? p->fromdomainport : ast_sockaddr_port(&p->ourip);
 
 	/* If a caller id name was specified, add a display name. */
-	if (cid_has_name || !cid_has_num) {
+	if (!ast_strlen_zero(n)) {
 		snprintf(from, sizeof(from), "\"%s\" ", n);
 	} else {
 		from[0] = '\0';
@@ -14040,6 +14419,20 @@
 	add_header(req, "Diversion", header_text);
 }
 
+static void add_join(struct sip_request *req, struct sip_pvt *pvt)
+{
+	char tmp[256];
+
+	if (!ast_test_flag(&pvt->flags[2], SIP_PAGE3_RELAY_NEAREND) && !ast_test_flag(&pvt->flags[2], SIP_PAGE3_RELAY_FAREND))
+		return;
+
+	if (ast_strlen_zero(pvt->join_callid) || ast_strlen_zero(pvt->join_tag) || ast_strlen_zero(pvt->join_theirtag))
+		return;
+
+	snprintf(tmp, sizeof(tmp), "%s;from-tag=%s;to-tag=%s", pvt->join_callid, pvt->join_tag, pvt->join_theirtag);
+	add_header(req, "Join", tmp);
+}
+
 static int transmit_publish(struct sip_epa_entry *epa_entry, enum sip_publish_type publish_type, const char * const explicit_uri)
 {
 	struct sip_pvt *pvt;
@@ -14106,12 +14499,25 @@
 	}
 	add_date(&req);
 	if (sipmethod == SIP_REFER && p->refer) {	/* Call transfer */
+		if (!ast_strlen_zero(p->refer->require)) {
+			add_header(&req, "Require", p->refer->require);
+		}
 		if (!ast_strlen_zero(p->refer->refer_to)) {
 			add_header(&req, "Refer-To", p->refer->refer_to);
 		}
 		if (!ast_strlen_zero(p->refer->referred_by)) {
 			add_header(&req, "Referred-By", p->refer->referred_by);
 		}
+		if (!ast_strlen_zero(p->refer->content_id)) {
+			add_header(&req, "Content-Id", p->refer->content_id);
+		}
+		if (!ast_strlen_zero(p->refer->content_type)) {
+			add_header(&req, "Content-Type", p->refer->content_type);
+		}
+		if (ast_str_strlen(p->refer->content)) {
+			add_content(&req, ast_str_buffer(p->refer->content));
+		}
+		add_expires(&req, p->expiry);
 	} else if (sipmethod == SIP_SUBSCRIBE) {
 		if (p->subscribed == MWI_NOTIFICATION) {
 			add_header(&req, "Event", "message-summary");
@@ -14201,6 +14607,7 @@
 		add_rpid(&req, p);
 	if (sipmethod == SIP_INVITE) {
 		add_diversion(&req, p);
+		add_join(&req, p);
 	}
 	if (sdp) {
 		offered_media_list_destroy(p);
@@ -14420,6 +14827,9 @@
 	struct ast_channel *c = NULL;
 	struct timeval tv = {0,};
 
+	if (!device_state_info)
+		return NULL;
+
 	/* iterate ringing devices and get the oldest of all causing channels */
 	citer = ao2_iterator_init(device_state_info, 0);
 	for (; (device_state = ao2_iterator_next(&citer)); ao2_ref(device_state, -1)) {
@@ -14438,93 +14848,9 @@
 	return c ? ast_channel_ref(c) : NULL;
 }
 
-/* XXX Candidate for moving into its own file */
-static int allow_notify_user_presence(struct sip_pvt *p)
-{
-	return (strstr(p->useragent, "Digium")) ? 1 : 0;
-}
-
 /*! \brief Builds XML portion of NOTIFY messages for presence or dialog updates */
 static void state_notify_build_xml(struct state_notify_data *data, int full, const char *exten, const char *context, struct ast_str **tmp, struct sip_pvt *p, int subscribed, const char *mfrom, const char *mto)
 {
-	enum state { NOTIFY_OPEN, NOTIFY_INUSE, NOTIFY_CLOSED } local_state = NOTIFY_OPEN;
-	const char *statestring = "terminated";
-	const char *pidfstate = "--";
-	const char *pidfnote ="Ready";
-	char hint[AST_MAX_EXTENSION];
-
-	switch (data->state) {
-	case (AST_EXTENSION_RINGING | AST_EXTENSION_INUSE):
-		statestring = (sip_cfg.notifyringing) ? "early" : "confirmed";
-		local_state = NOTIFY_INUSE;
-		pidfstate = "busy";
-		pidfnote = "Ringing";
-		break;
-	case AST_EXTENSION_RINGING:
-		statestring = "early";
-		local_state = NOTIFY_INUSE;
-		pidfstate = "busy";
-		pidfnote = "Ringing";
-		break;
-	case AST_EXTENSION_INUSE:
-		statestring = "confirmed";
-		local_state = NOTIFY_INUSE;
-		pidfstate = "busy";
-		pidfnote = "On the phone";
-		break;
-	case AST_EXTENSION_BUSY:
-		statestring = "confirmed";
-		local_state = NOTIFY_CLOSED;
-		pidfstate = "busy";
-		pidfnote = "On the phone";
-		break;
-	case AST_EXTENSION_UNAVAILABLE:
-		statestring = "terminated";
-		local_state = NOTIFY_CLOSED;
-		pidfstate = "away";
-		pidfnote = "Unavailable";
-		break;
-	case AST_EXTENSION_ONHOLD:
-		statestring = "confirmed";
-		local_state = NOTIFY_CLOSED;
-		pidfstate = "busy";
-		pidfnote = "On hold";
-		break;
-	case AST_EXTENSION_NOT_INUSE:
-	default:
-		/* Default setting */
-		break;
-	}
-
-	/* Check which device/devices we are watching  and if they are registered */
-	if (ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten)) {
-		char *hint2;
-		char *individual_hint = NULL;
-		int hint_count = 0, unavailable_count = 0;
-
-		/* strip off any possible PRESENCE providers from hint */
-		if ((hint2 = strrchr(hint, ','))) {
-			*hint2 = '\0';
-		}
-		hint2 = hint;
-
-		while ((individual_hint = strsep(&hint2, "&"))) {
-			hint_count++;
-
-			if (ast_device_state(individual_hint) == AST_DEVICE_UNAVAILABLE)
-				unavailable_count++;
-		}
-
-		/* If none of the hinted devices are registered, we will
-		 * override notification and show no availability.
-		 */
-		if (hint_count > 0 && hint_count == unavailable_count) {
-			local_state = NOTIFY_CLOSED;
-			pidfstate = "away";
-			pidfnote = "Not online";
-		}
-	}
-
 	switch (subscribed) {
 	case XPIDF_XML:
 	case CPIM_PIDF_XML:
@@ -14535,46 +14861,91 @@
 		ast_str_append(tmp, 0, "<presentity uri=\"%s;method=SUBSCRIBE\" />\n", mfrom);
 		ast_str_append(tmp, 0, "<atom id=\"%s\">\n", exten);
 		ast_str_append(tmp, 0, "<address uri=\"%s;user=ip\" priority=\"0.800000\">\n", mto);
-		ast_str_append(tmp, 0, "<status status=\"%s\" />\n", (local_state ==  NOTIFY_OPEN) ? "open" : (local_state == NOTIFY_INUSE) ? "inuse" : "closed");
-		ast_str_append(tmp, 0, "<msnsubstatus substatus=\"%s\" />\n", (local_state == NOTIFY_OPEN) ? "online" : (local_state == NOTIFY_INUSE) ? "onthephone" : "offline");
+		if (data->state & (AST_EXTENSION_RINGING | AST_EXTENSION_INUSE) || data->presence_state == AST_PRESENCE_DND) {
+			ast_str_append(tmp, 0, "<status status=\"inuse\" />\n");
+			ast_str_append(tmp, 0, "<msnsubstatus substatus=\"onthephone\" />\n");
+		} else if (data->state & (AST_EXTENSION_BUSY | AST_EXTENSION_UNAVAILABLE | AST_EXTENSION_ONHOLD)) {
+			ast_str_append(tmp, 0, "<status status=\"closed\" />\n");
+			ast_str_append(tmp, 0, "<msnsubstatus substatus=\"offline\" />\n");
+		} else {
+			ast_str_append(tmp, 0, "<status status=\"open\" />\n");
+			ast_str_append(tmp, 0, "<msnsubstatus substatus=\"online\" />\n");
+		}
 		ast_str_append(tmp, 0, "</address>\n</atom>\n</presence>\n");
 		break;
 	case PIDF_XML: /* Eyebeam supports this format */
-		ast_str_append(tmp, 0,
-			"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"
-			"<presence xmlns=\"urn:ietf:params:xml:ns:pidf\" \nxmlns:pp=\"urn:ietf:params:xml:ns:pidf:person\"\nxmlns:es=\"urn:ietf:params:xml:ns:pidf:rpid:status:rpid-status\"\nxmlns:ep=\"urn:ietf:params:xml:ns:pidf:rpid:rpid-person\"\nentity=\"%s\">\n", mfrom);
-		ast_str_append(tmp, 0, "<pp:person><status>\n");
-		if (pidfstate[0] != '-') {
-			ast_str_append(tmp, 0, "<ep:activities><ep:%s/></ep:activities>\n", pidfstate);
-		}
-		ast_str_append(tmp, 0, "</status></pp:person>\n");
-		ast_str_append(tmp, 0, "<note>%s</note>\n", pidfnote); /* Note */
-		ast_str_append(tmp, 0, "<tuple id=\"%s\">\n", exten); /* Tuple start */
-		ast_str_append(tmp, 0, "<contact priority=\"1\">%s</contact>\n", mto);
-		if (pidfstate[0] == 'b') /* Busy? Still open ... */
-			ast_str_append(tmp, 0, "<status><basic>open</basic></status>\n");
-		else
-			ast_str_append(tmp, 0, "<status><basic>%s</basic></status>\n", (local_state != NOTIFY_CLOSED) ? "open" : "closed");
-
-		if (allow_notify_user_presence(p) && (data->presence_state != AST_PRESENCE_INVALID)
-				&& (data->presence_state != AST_PRESENCE_NOT_SET)) {
+		if (ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+			ast_str_append(tmp, 0,
+				"<presence xmlns=\"urn:ietf:params:xml:ns:pidf\" xmlns:dm=\"urn:ietf:params:xml:ns:pidf:data-model\" xmlns:e=\"urn:ietf:params:xml:ns:pidf:status:rpid\" xmlns:ce=\"urn:cisco:params:xml:ns:pidf:rpid\" entity=\"%s\">\n", mfrom);
+			ast_str_append(tmp, 0, "<dm:person>\n");
+			ast_str_append(tmp, 0, "<e:activities>\n");
+			if (data->state & AST_EXTENSION_RINGING && sip_cfg.notifyringing) {
+				ast_str_append(tmp, 0, "<ce:alerting />\n");
+			} else if (data->state & (AST_EXTENSION_INUSE | AST_EXTENSION_BUSY | AST_EXTENSION_ONHOLD)) {
+				ast_str_append(tmp, 0, "<e:on-the-phone />\n");
+			} else if (data->presence_state == AST_PRESENCE_DND) {
+				ast_str_append(tmp, 0, "<ce:dnd />\n");
+			}
+			ast_str_append(tmp, 0, "</e:activities>\n");
+			ast_str_append(tmp, 0, "</dm:person>\n");
+			ast_str_append(tmp, 0, "<tuple id=\"%d\">\n", p->dialogver);
+			if (data->state == AST_EXTENSION_UNAVAILABLE) {
+				ast_str_append(tmp, 0, "<status><basic>closed</basic></status>\n");
+			} else {
+				ast_str_append(tmp, 0, "<status><basic>open</basic></status>\n");
+			}
 			ast_str_append(tmp, 0, "</tuple>\n");
-			ast_str_append(tmp, 0, "<tuple id=\"digium-presence\">\n");
-			ast_str_append(tmp, 0, "<status>\n");
-			ast_str_append(tmp, 0, "<digium_presence type=\"%s\" subtype=\"%s\">%s</digium_presence>\n",
-				ast_presence_state2str(data->presence_state),
-				S_OR(data->presence_subtype, ""),
-				S_OR(data->presence_message, ""));
-			ast_str_append(tmp, 0, "</status>\n");
-			ast_test_suite_event_notify("DIGIUM_PRESENCE_SENT",
+			ast_str_append(tmp, 0, "</presence>\n");
+		} else {
+			ast_str_append(tmp, 0,
+				"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"
+				"<presence xmlns=\"urn:ietf:params:xml:ns:pidf\" \nxmlns:pp=\"urn:ietf:params:xml:ns:pidf:person\"\nxmlns:es=\"urn:ietf:params:xml:ns:pidf:rpid:status:rpid-status\"\nxmlns:ep=\"urn:ietf:params:xml:ns:pidf:rpid:rpid-person\"\nentity=\"%s\">\n", mfrom);
+			ast_str_append(tmp, 0, "<pp:person><status>\n");
+			if (data->state == AST_EXTENSION_UNAVAILABLE) {
+				ast_str_append(tmp, 0, "<ep:activities><ep:away /></ep:activities>\n");
+			} else if (data->state & (AST_EXTENSION_RINGING | AST_EXTENSION_INUSE | AST_EXTENSION_BUSY | AST_EXTENSION_ONHOLD) || data->presence_state == AST_PRESENCE_DND) {
+				ast_str_append(tmp, 0, "<ep:activities><ep:busy /></ep:activities>\n");
+			}
+			ast_str_append(tmp, 0, "</status></pp:person>\n");
+			if (data->state & AST_EXTENSION_RINGING) {
+				ast_str_append(tmp, 0, "<note>Ringing</note>\n");
+			} else if (data->state & (AST_EXTENSION_INUSE | AST_EXTENSION_BUSY)) {
+				ast_str_append(tmp, 0, "<note>On the phone</note>\n");
+			} else if (data->state == AST_EXTENSION_ONHOLD) {
+				ast_str_append(tmp, 0, "<note>On hold</note>\n");
+			} else if (data->state == AST_EXTENSION_UNAVAILABLE) {
+				ast_str_append(tmp, 0, "<note>Unavailable</note>\n");
+			} else if (data->presence_state == AST_PRESENCE_DND) {
+				ast_str_append(tmp, 0, "<note>Do not disturb</note>\n");
+			} else {
+				ast_str_append(tmp, 0, "<note>Ready</note>\n");
+			}
+			ast_str_append(tmp, 0, "<tuple id=\"%s\">\n", exten); /* Tuple start */
+			ast_str_append(tmp, 0, "<contact priority=\"1\">%s</contact>\n", mto);
+			if (data->state & (AST_EXTENSION_UNAVAILABLE | AST_EXTENSION_BUSY | AST_EXTENSION_ONHOLD)) {
+				ast_str_append(tmp, 0, "<status><basic>closed</basic></status>\n");
+			} else {
+				ast_str_append(tmp, 0, "<status><basic>open</basic></status>\n");
+			}
+			if (ast_test_flag(&p->flags[2], SIP_PAGE3_WHY_DIDNT_DIGIUM_THINK_OF_THIS) && (data->presence_state > 0)) {
+				ast_str_append(tmp, 0, "</tuple>\n");
+				ast_str_append(tmp, 0, "<tuple id=\"digium-presence\">\n");
+				ast_str_append(tmp, 0, "<status>\n");
+				ast_str_append(tmp, 0, "<digium_presence type=\"%s\" subtype=\"%s\">%s</digium_presence>\n",
+					ast_presence_state2str(data->presence_state),
+					S_OR(data->presence_subtype, ""),
+					S_OR(data->presence_message, ""));
+				ast_str_append(tmp, 0, "</status>\n");
+				ast_test_suite_event_notify("DIGIUM_PRESENCE_SENT",
 					"PresenceState: %s\r\n"
 					"Subtype: %s\r\n"
 					"Message: %s",
 					ast_presence_state2str(data->presence_state),
 					S_OR(data->presence_subtype, ""),
 					S_OR(data->presence_message, ""));
+			}
+			ast_str_append(tmp, 0, "</tuple>\n</presence>\n");
 		}
-		ast_str_append(tmp, 0, "</tuple>\n</presence>\n");
 		break;
 	case DIALOG_INFO_XML: /* SNOM subscribes in this format */
 		ast_str_append(tmp, 0, "<?xml version=\"1.0\"?>\n");
@@ -14684,7 +15055,13 @@
 		} else {
 			ast_str_append(tmp, 0, "<dialog id=\"%s\">\n", exten);
 		}
-		ast_str_append(tmp, 0, "<state>%s</state>\n", statestring);
+		if (data->state & AST_EXTENSION_RINGING && sip_cfg.notifyringing) {
+			ast_str_append(tmp, 0, "<state>early</state>\n");
+		} else if (data->state & (AST_EXTENSION_RINGING | AST_EXTENSION_INUSE | AST_EXTENSION_BUSY | AST_EXTENSION_ONHOLD) || data->presence_state == AST_PRESENCE_DND) {
+			ast_str_append(tmp, 0, "<state>confirmed</state>\n");
+		} else {
+			ast_str_append(tmp, 0, "<state>terminated</state>\n");
+		}
 		if (data->state == AST_EXTENSION_ONHOLD) {
 				ast_str_append(tmp, 0, "<local>\n<target uri=\"%s\">\n"
 			                                    "<param pname=\"+sip.rendering\" pvalue=\"no\"/>\n"
@@ -14766,7 +15143,7 @@
 
 	reqprep(&req, p, SIP_NOTIFY, 0, 1);
 
-	switch(data->state) {
+	switch (data->state) {
 	case AST_EXTENSION_DEACTIVATED:
 		if (timeout)
 			add_header(&req, "Subscription-State", "terminated;reason=timeout");
@@ -14779,36 +15156,22 @@
 		add_header(&req, "Subscription-State", "terminated;reason=noresource");
 		break;
 	default:
-		if (p->expiry)
+		if (p->expiry > 0) {
+			char tmp[64];
+
+			snprintf(tmp, sizeof(tmp), "active;expires=%d", p->expiry);
+			add_header(&req, "Subscription-State", tmp);
+		} else if (ast_test_flag(&p->flags[2], SIP_PAGE3_SUBSCRIPTIONSTATE_ACTIVE)) {
 			add_header(&req, "Subscription-State", "active");
-		else	/* Expired */
+		} else {
 			add_header(&req, "Subscription-State", "terminated;reason=timeout");
+		}
 	}
 
-	switch (p->subscribed) {
-	case XPIDF_XML:
-	case CPIM_PIDF_XML:
-		add_header(&req, "Event", subscriptiontype->event);
-		state_notify_build_xml(data, full, p->exten, p->context, &tmp, p, p->subscribed, mfrom, mto);
-		add_header(&req, "Content-Type", subscriptiontype->mediatype);
-		p->dialogver++;
-		break;
-	case PIDF_XML: /* Eyebeam supports this format */
-		add_header(&req, "Event", subscriptiontype->event);
-		state_notify_build_xml(data, full, p->exten, p->context, &tmp, p, p->subscribed, mfrom, mto);
-		add_header(&req, "Content-Type", subscriptiontype->mediatype);
-		p->dialogver++;
-		break;
-	case DIALOG_INFO_XML: /* SNOM subscribes in this format */
-		add_header(&req, "Event", subscriptiontype->event);
-		state_notify_build_xml(data, full, p->exten, p->context, &tmp, p, p->subscribed, mfrom, mto);
-		add_header(&req, "Content-Type", subscriptiontype->mediatype);
-		p->dialogver++;
-		break;
-	case NONE:
-	default:
-		break;
-	}
+	add_header(&req, "Event", subscriptiontype->event);
+	state_notify_build_xml(data, full, p->exten, p->context, &tmp, p, p->subscribed, mfrom, mto);
+	add_header(&req, "Content-Type", subscriptiontype->mediatype);
+	p->dialogver++;
 
 	add_content(&req, ast_str_buffer(tmp));
 
@@ -14867,9 +15230,9 @@
 	}
 	/* Cisco has a bug in the SIP stack where it can't accept the
 		(0/0) notification. This can temporarily be disabled in
-		sip.conf with the "buggymwi" option */
+		sip.conf with the "cisco_usecallmanager" option */
 	ast_str_append(&out, 0, "Voice-Message: %d/%d%s\r\n",
-		newmsgs, oldmsgs, (ast_test_flag(&p->flags[1], SIP_PAGE2_BUGGY_MWI) ? "" : " (0/0)"));
+		newmsgs, oldmsgs, (ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER) ? "" : " (0/0)"));
 
 	if (p->subscribed) {
 		if (p->expiry) {
@@ -14916,7 +15279,7 @@
 	const char *channame = astman_get_header(m, "Channel");
 	struct ast_variable *vars = astman_get_variables_order(m, ORDER_NATURAL);
 	struct sip_pvt *p;
-	struct ast_variable *header, *var;
+	struct ast_variable *var, *header, *headers = NULL;
 
 	if (ast_strlen_zero(channame)) {
 		astman_send_error(s, m, "SIPNotify requires a channel name");
@@ -14945,18 +15308,23 @@
 	ast_set_flag(&p->flags[0], SIP_OUTGOING);
 	sip_notify_alloc(p);
 
-	p->notify->headers = header = ast_variable_new("Subscription-State", "terminated", "");
+	/* Recalculate our side, and recalculate Call ID */
+	ast_sip_ouraddrfor(&p->sa, &p->ourip, p);
+	change_callid_pvt(p, NULL);
 
 	for (var = vars; var; var = var->next) {
 		if (!strcasecmp(var->name, "Content")) {
-			if (ast_str_strlen(p->notify->content))
-				ast_str_append(&p->notify->content, 0, "\r\n");
-			ast_str_append(&p->notify->content, 0, "%s", var->value);
+			ast_str_append(&p->notify->content, 0, "%s\r\n", var->value);
 		} else if (!strcasecmp(var->name, "Content-Length")) {
 			ast_log(LOG_WARNING, "it is not necessary to specify Content-Length, ignoring\n");
 		} else {
-			header->next = ast_variable_new(var->name, var->value, "");
-			header = header->next;
+			header = ast_variable_new(var->name, var->value, "");
+			if (headers) {
+				headers->next = header;
+			} else {
+				p->notify->headers = header;
+			}
+			headers = header;
 		}
 	}
 
@@ -14992,10 +15360,6 @@
 	if (!ast_test_flag(&p->flags[0], SIP_SENDRPID)) {
 		return;
 	}
-	if (!connected_id.number.valid
-		|| ast_strlen_zero(connected_id.number.str)) {
-		return;
-	}
 
 	append_history(p, "ConnectedLine", "%s party is now %s <%s>",
 		ast_test_flag(&p->flags[0], SIP_OUTGOING) ? "Calling" : "Called",
@@ -15005,7 +15369,12 @@
 	if (ast_channel_state(p->owner) == AST_STATE_UP || ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
 		struct sip_request req;
 
-		if (!p->pendinginvite && (p->invitestate == INV_CONFIRMED || p->invitestate == INV_TERMINATED)) {
+		if (is_method_allowed(&p->allowed_methods, SIP_UPDATE) && !ast_strlen_zero(p->okcontacturi)) {
+			reqprep(&req, p, SIP_UPDATE, 0, 1);
+			add_rpid(&req, p);
+			add_header(&req, "X-Asterisk-rpid-update", "Yes");
+			send_request(p, &req, XMIT_CRITICAL, p->ocseq);
+		} else if (!p->pendinginvite && (p->invitestate == INV_CONFIRMED || p->invitestate == INV_TERMINATED)) {
 			reqprep(&req, p, ast_test_flag(&p->flags[0], SIP_REINVITE_UPDATE) ? SIP_UPDATE : SIP_INVITE, 0, 1);
 
 			add_header(&req, "Allow", ALLOWED_METHODS);
@@ -15018,11 +15387,6 @@
 			ast_set_flag(&p->flags[0], SIP_OUTGOING);
 			p->invitestate = INV_CALLING;
 			send_request(p, &req, XMIT_CRITICAL, p->ocseq);
-		} else if ((is_method_allowed(&p->allowed_methods, SIP_UPDATE)) && (!ast_strlen_zero(p->okcontacturi))) { 
-			reqprep(&req, p, SIP_UPDATE, 0, 1);
-			add_rpid(&req, p);
-			add_header(&req, "X-Asterisk-rpid-update", "Yes");
-			send_request(p, &req, XMIT_CRITICAL, p->ocseq);
 		} else {
 			/* We cannot send the update yet, so we have to wait until we can */
 			ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
@@ -15030,20 +15394,19 @@
 	} else {
 		ast_set_flag(&p->flags[1], SIP_PAGE2_CONNECTLINEUPDATE_PEND);
 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_RPID_IMMEDIATE)) {
-			struct sip_request resp;
+			if (ast_channel_state(p->owner) == AST_STATE_RING || ast_channel_state(p->owner) == AST_STATE_RINGING) {
+				struct sip_request resp;
 
-			if ((ast_channel_state(p->owner) == AST_STATE_RING) && !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT)) {
-				ast_clear_flag(&p->flags[1], SIP_PAGE2_CONNECTLINEUPDATE_PEND);
-				respprep(&resp, p, "180 Ringing", &p->initreq);
-				add_rpid(&resp, p);
-				send_response(p, &resp, XMIT_UNRELIABLE, 0);
-				ast_set_flag(&p->flags[0], SIP_RINGING);
-			} else if (ast_channel_state(p->owner) == AST_STATE_RINGING) {
 				ast_clear_flag(&p->flags[1], SIP_PAGE2_CONNECTLINEUPDATE_PEND);
-				respprep(&resp, p, "183 Session Progress", &p->initreq);
+				if (ast_channel_state(p->owner) == AST_STATE_RING && !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT)) {
+					respprep(&resp, p, "180 Ringing", &p->initreq);
+					ast_set_flag(&p->flags[0], SIP_RINGING);
+				} else {
+					respprep(&resp, p, "183 Session Progress", &p->initreq);
+					ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);
+				}
 				add_rpid(&resp, p);
 				send_response(p, &resp, XMIT_UNRELIABLE, 0);
-				ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);
 			} else {
 				ast_debug(1, "Unable able to send update to '%s' in state '%s'\n", ast_channel_name(p->owner), ast_state2str(ast_channel_state(p->owner)));
 			}
@@ -15051,6 +15414,161 @@
 	}
 }
 
+/*! \brief Notify peer that the do not disturb status has changed */
+static int sip_send_donotdisturb(struct sip_peer *peer)
+{
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+		return 0;
+	}
+
+	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		struct sip_pvt *pvt;
+		struct ast_str *content = ast_str_alloca(8192);
+
+		if (!(pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+			return -1;
+		}
+
+		set_socket_transport(&pvt->socket, 0);
+		if (create_addr_from_peer(pvt, peer)) {
+			dialog_unlink_all(pvt);
+			dialog_unref(pvt, "create_addr_from_peer failed in sip_send_donotdisturb. Unref dialog");
+			return -1;
+		}
+
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<dndupdate>\n");
+		ast_str_append(&content, 0, "<state>%s</state>\n", peer->donotdisturb ? "enable" : "disable");
+		ast_str_append(&content, 0, "<option>%s</option>\n", ast_test_flag(&pvt->flags[2], SIP_PAGE3_DND_BUSY) ? "callreject" : "ringeroff");
+		ast_str_append(&content, 0, "</dndupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	} else if (peer->fepvt) {
+		struct sip_request req;
+		struct sip_pvt *pvt = peer->fepvt;
+		char tmp[512];
+
+		ast_set_flag(&pvt->flags[0], SIP_OUTGOING);
+		reqprep(&req, pvt, SIP_NOTIFY, 0, 1);
+
+		add_header(&req, "Event", "as-feature-event");
+		if (pvt->expiry) {
+			add_header(&req, "Subscription-State", "active");
+		} else {
+			add_header(&req, "Subscription-State", "terminated;reason=timeout");
+		}
+		add_header(&req, "Content-Type", "application/x-as-feature-event+xml");
+
+		add_content(&req, "<?xml version=\"1.0\"?>\n");
+		add_content(&req, "<DoNotDisturbEvent xmlns=\"http://www.ecma-international.org/standards/ecma-323/csta/ed3\">\n");
+		snprintf(tmp, sizeof(tmp), "<device><notKnown /></device>\n<doNotDisturbOn>%s</doNotDisturbOn>\n", peer->donotdisturb ? "true" : "false");
+		add_content(&req, tmp);
+		add_content(&req, "</DoNotDisturbEvent>\n");
+
+		send_request(pvt, &req, XMIT_RELIABLE, pvt->ocseq);
+	}
+
+	return 0;
+}
+
+/*! \brief Notify peer that the call forwarding extension has changed */
+static int sip_send_callforward(struct sip_peer *peer)
+{
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+		return 0;
+	}
+
+	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		struct sip_pvt *pvt;
+		struct ast_str *content = ast_str_alloca(8192);
+
+		if (!(pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+			return -1;
+		}
+
+		set_socket_transport(&pvt->socket, 0);
+		if (create_addr_from_peer(pvt, peer)) {
+			dialog_unlink_all(pvt);
+			dialog_unref(pvt, "create_addr_from_peer failed in sip_send_callforward. Unref dialog");
+			return -1;
+		}
+
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<cfwdallupdate>\n");
+		ast_str_append(&content, 0, "<linenumber>%d</linenumber>\n", peer->cisco_lineindex);
+		ast_str_append(&content, 0, "<fwdaddress>%s</fwdaddress>\n", peer->callforward);
+		ast_str_append(&content, 0, "<tovoicemail>%s</tovoicemail>\n", !strcmp(peer->callforward, peer->vmexten) ? "on" : "off");
+		ast_str_append(&content, 0, "</cfwdallupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	} else if (peer->fepvt) {
+		struct sip_request req;
+		struct sip_pvt *pvt = peer->fepvt;
+		char tmp[512];
+
+		ast_set_flag(&pvt->flags[0], SIP_OUTGOING);
+		reqprep(&req, pvt, SIP_NOTIFY, 0, 1);
+
+		add_header(&req, "Event", "as-feature-event");
+		if (pvt->expiry) {
+			add_header(&req, "Subscription-State", "active");
+		} else {
+			add_header(&req, "Subscription-State", "terminated;reason=timeout");
+		}
+		add_header(&req, "Content-Type", "application/x-as-feature-event+xml");
+
+		add_content(&req, "<?xml version=\"1.0\"?>\n");
+		add_content(&req, "<ForwardingEvent xmlns=\"http://www.ecma-international.org/standards/ecma-323/csta/ed3\">\n");
+		add_content(&req, "<device><notKnown /></device>\n<forwardingType>forwardImmediate</forwardingType>\n");
+		snprintf(tmp, sizeof(tmp), "<forwardStatus>%s</forwardStatus>\n<forwardTo>%s</forwardTo>\n", !ast_strlen_zero(peer->callforward) ? "true" : "false", peer->callforward);
+		add_content(&req, tmp);
+		add_content(&req, "</ForwardingEvent>\n");
+
+		send_request(pvt, &req, XMIT_RELIABLE, pvt->ocseq);
+	}
+
+	return 0;
+}
+
+/*! \brief Notify peer that the huntgroup login state has changed */
+static int sip_send_huntgroup(struct sip_peer *peer)
+{
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+		return 0;
+	}
+
+	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		struct sip_pvt *pvt;
+		struct ast_str *content = ast_str_alloca(8192);
+
+		if (!(pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+			return -1;
+		}
+
+		set_socket_transport(&pvt->socket, 0);
+		if (create_addr_from_peer(pvt, peer)) {
+			dialog_unlink_all(pvt);
+			dialog_unref(pvt, "create_addr_from_peer failed in sip_send_huntgroup. Unref dialog");
+			return -1;
+		}
+
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<hlogupdate>\n");
+		ast_str_append(&content, 0, "<status>%s</status>\n", peer->huntgroup ? "on" : "off");
+		ast_str_append(&content, 0, "</hlogupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	}
+
+	return 0;
+}
+
 static const struct _map_x_s regstatestrings[] = {
 	{ REG_STATE_FAILED,     "Failed" },
 	{ REG_STATE_UNREGISTERED, "Unregistered"},
@@ -15338,8 +15856,8 @@
 			ast_string_field_set(p, username, r->username);
 		}
 		/* Save extension in packet */
-		if (!ast_strlen_zero(r->callback)) {
-			ast_string_field_set(p, exten, r->callback);
+		if (!ast_strlen_zero(r->exten)) {
+			ast_string_field_set(p, exten, r->exten);
 		}
 
 		/* Set transport and port so the correct contact is built */
@@ -15475,6 +15993,9 @@
 {
 	sip_refer_destroy(p);
 	p->refer = ast_calloc_with_stringfields(1, struct sip_refer, 512);
+	if (p->refer) {
+		p->refer->content = ast_str_create(128);
+	}
 	return p->refer ? 1 : 0;
 }
 
@@ -15486,6 +16007,7 @@
 			p->refer->refer_call = dialog_unref(p->refer->refer_call, "unref dialog p->refer->refer_call");
 		}
 		ast_string_field_free_memory(p->refer);
+		ast_free(p->refer->content);
 		ast_free(p->refer);
 		p->refer = NULL;
 	}
@@ -15565,6 +16087,28 @@
 	*/
 }
 
+/*! \brief Send an out-of-dialog SIP REFER message with content */
+static int transmit_refer_with_content(struct sip_pvt *pvt, const char *content_type, const char *content)
+{
+	/* Refer is outgoing call */
+	ast_set_flag(&pvt->flags[0], SIP_OUTGOING);
+	sip_refer_alloc(pvt);
+	pvt->refer->status = REFER_SENT;
+
+	ast_string_field_set(pvt->refer, require, "norefersub");
+	ast_string_field_set(pvt->refer, referred_by, pvt->our_contact);
+	ast_string_field_build(pvt->refer, content_id, "%08lx", ast_random());
+	ast_string_field_build(pvt->refer, refer_to, "cid:%s", pvt->refer->content_id);
+	ast_string_field_set(pvt->refer, content_type, content_type);
+
+	ast_str_set(&pvt->refer->content, 0, "%s", content);
+
+	sip_scheddestroy(pvt, SIP_TRANS_TIMEOUT);
+	sip_alreadygone(pvt);
+
+	return transmit_invite(pvt, SIP_REFER, 0, 2, NULL);
+}
+
 /*! \brief Send SIP INFO advice of charge message */
 static int transmit_info_with_aoc(struct sip_pvt *p, struct ast_aoc_decoded *decoded)
 {
@@ -15647,6 +16191,10 @@
 
 	if (sipmethod == SIP_ACK) {
 		p->invitestate = INV_CONFIRMED;
+
+		if (ast_test_flag(&p->flags[2], SIP_PAGE3_SDP_ACK)) {
+			add_sdp(&resp, p, FALSE, TRUE, FALSE);
+		}
 	}
 
 	return send_request(p, &resp, reliable, seqno ? seqno : p->ocseq);
@@ -15752,6 +16300,7 @@
 static int expire_register(const void *data)
 {
 	struct sip_peer *peer = (struct sip_peer *)data;
+	struct sip_subscription *subscription;
 
 	if (!peer) {		/* Hmmm. We have no peer. Weird. */
 		return 0;
@@ -15759,6 +16308,7 @@
 
 	peer->expire = -1;
 	peer->portinuri = 0;
+	ast_string_field_set(peer, regcallid, "");
 
 	destroy_association(peer);	/* remove registration data from storage */
 	set_socket_transport(&peer->socket, peer->default_outbound_transport);
@@ -15771,6 +16321,14 @@
 		peer->socket.ws_session = NULL;
 	}
 
+	AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+		if (subscription->pvt) {
+			dialog_unlink_all(subscription->pvt);
+			dialog_unref(subscription->pvt, "destroying subscription");
+			subscription->pvt = NULL;
+		}
+	}
+
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", peer->name);
 	register_peer_exten(peer, FALSE);	/* Remove regexten */
 	ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", peer->name);
@@ -15796,6 +16354,7 @@
 	/* Only clear the addr after we check for destruction.  The addr must remain
 	 * in order to unlink from the peers_by_ip container correctly */
 	memset(&peer->addr, 0, sizeof(peer->addr));
+	expire_peer_aliases(peer);
 
 	sip_unref_peer(peer, "removing peer ref for expire_register");
 
@@ -16088,6 +16647,7 @@
 		return PARSE_REGISTER_QUERY;
 	} else if (!strcasecmp(curi, "*") || !expire) {	/* Unregister this peer */
 		/* This means remove all registrations and return OK */
+		pvt->expiry = 0;
 		AST_SCHED_DEL_UNREF(sched, peer->expire,
 				sip_unref_peer(peer, "remove register expire ref"));
 		ast_verb(3, "Unregistered SIP '%s'\n", peer->name);
@@ -16207,12 +16767,18 @@
 	if (ast_sockaddr_cmp(&peer->addr, &oldsin)) {
 		ast_verb(3, "Registered SIP '%s' at %s\n", peer->name,
 			ast_sockaddr_stringify(&peer->addr));
+
+		/* Clear off-hook counter in case of the on-hook notification not being received */
+		peer->offhook = 0;
 	}
 	sip_pvt_unlock(pvt);
 	sip_poke_peer(peer, 0);
 	sip_pvt_lock(pvt);
 	register_peer_exten(peer, 1);
 
+	/* Save REGISTER dialog Call-ID */
+	ast_string_field_set(peer, regcallid, pvt->callid);
+
 	/* Save User agent */
 	useragent = sip_get_header(req, "User-Agent");
 	if (strcasecmp(useragent, peer->useragent)) {
@@ -16441,6 +17007,8 @@
 	/* Always OK if no secret */
 	if (ast_strlen_zero(secret) && ast_strlen_zero(md5secret)) {
 		return AUTH_SUCCESSFUL;
+	} else if (ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER) && (sipmethod == SIP_REFER || sipmethod == SIP_PUBLISH)) {
+		return AUTH_SUCCESSFUL; /* Buggy Cisco USECALLMANAGER phones can't auth REFER or PUBLISH correctly */
 	}
 
 	/* Always auth with WWW-auth since we're NOT a proxy */
@@ -16603,7 +17171,7 @@
 {
 	struct sip_peer *peer = userdata;
 
-	sip_send_mwi_to_peer(peer, 0);
+	sip_send_mwi(peer, 0);
 }
 
 static void network_change_event_subscribe(void)
@@ -16680,8 +17248,8 @@
 			/* we must skip the next two checks for a queued state change or resubscribe */
 		} else if ((p->laststate == data->state && (~data->state & AST_EXTENSION_RINGING)) &&
 				(p->last_presence_state == data->presence_state &&
-					!strcmp(p->last_presence_subtype, data->presence_subtype) &&
-					!strcmp(p->last_presence_message, data->presence_message))) {
+					!strcmp(p->last_presence_subtype, S_OR(data->presence_subtype, "")) &&
+					!strcmp(p->last_presence_message, S_OR(data->presence_message, "")))) {
 			/* don't notify unchanged state or unchanged early-state causing parties again */
 			sip_pvt_unlock(p);
 			return 0;
@@ -16733,7 +17301,7 @@
 	}
 
 	if (!force) {
-		ast_verb(2, "Extension Changed %s[%s] new state %s for Notify User %s %s\n", exten, context, ast_extension_state2str(data->state), p->username,
+		ast_debug(1, "Extension Changed %s[%s] new state %s for Notify User %s %s\n", exten, context, ast_extension_state2str(data->state), p->username,
 				ast_test_flag(&p->flags[1], SIP_PAGE2_STATECHANGEQUEUE) ? "(queued)" : "");
 	}
 
@@ -16756,11 +17324,6 @@
 		.presence_message = info->presence_message,
 	};
 
-	if ((info->reason == AST_HINT_UPDATE_PRESENCE) && !(allow_notify_user_presence(p))) {
-		/* ignore a presence triggered update if we know the useragent doesn't care */
-		return 0;
-	}
-
 	return extensionstate_update(context, exten, &notify_data, p, FALSE);
 }
 
@@ -16917,7 +17480,7 @@
 	char tmp[256];
 	char *c, *name, *unused_password, *domain;
 	char *uri2 = ast_strdupa(uri);
-	int send_mwi = 0;
+	int registered = 0;
 
 	terminate_uri(uri2);
 
@@ -17025,7 +17588,6 @@
 					transmit_response_with_date(p, "403 Forbidden", req);
 					res = AUTH_BAD_TRANSPORT;
 				} else {
-
 					/* We have a successful registration attempt with proper authentication,
 					now, update the peer */
 					switch (parse_register_contact(p, peer, req)) {
@@ -17043,7 +17605,6 @@
 						ast_string_field_set(p, fullcontact, peer->fullcontact);
 						transmit_response_with_date(p, "200 OK", req);
 						res = 0;
-						send_mwi = 1;
 						break;
 					case PARSE_REGISTER_UPDATE:
 						ast_string_field_set(p, fullcontact, peer->fullcontact);
@@ -17052,8 +17613,12 @@
 							update_peer(peer, p->expiry);
 						}
 						/* Say OK and ask subsystem to retransmit msg counter */
-						transmit_response_with_date(p, "200 OK", req);
-						send_mwi = 1;
+						if (p->expiry != 0 && ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+							transmit_response_with_optionsind(p, req, peer);
+						} else {
+							transmit_response_with_date(p, "200 OK", req);
+						}
+						registered = 1;
 						res = 0;
 						break;
 					}
@@ -17088,15 +17653,18 @@
 			case PARSE_REGISTER_QUERY:
 				ast_string_field_set(p, fullcontact, peer->fullcontact);
 				transmit_response_with_date(p, "200 OK", req);
-				send_mwi = 1;
 				res = 0;
 				break;
 			case PARSE_REGISTER_UPDATE:
 				ast_string_field_set(p, fullcontact, peer->fullcontact);
 				/* Say OK and ask subsystem to retransmit msg counter */
-				transmit_response_with_date(p, "200 OK", req);
+				if (p->expiry != 0 && ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+					transmit_response_with_optionsind(p, req, peer);
+				} else {
+					transmit_response_with_date(p, "200 OK", req);
+				}
 				manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Registered\r\nAddress: %s\r\n", peer->name, ast_sockaddr_stringify(addr));
-				send_mwi = 1;
+				registered = 1;
 				res = 0;
 				break;
 			}
@@ -17104,10 +17672,16 @@
 		}
 	}
 	if (!res) {
-		if (send_mwi) {
-			sip_pvt_unlock(p);
-			sip_send_mwi_to_peer(peer, 0);
-			sip_pvt_lock(p);
+		if (p->expiry != 0 && registered) {
+			if (ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+				register_peer_aliases(peer, 1);
+				sip_send_bulkupdate(peer);
+			} else {
+				sip_pvt_unlock(p);
+				sip_send_mwi(peer, 0);
+				sip_pvt_lock(p);
+			}
+			extensionstate_subscriptions(peer, 1);
 		} else {
 			update_peer_lastmsgssent(peer, -1, 0);
 		}
@@ -17232,82 +17806,6 @@
 	}
 }
 
-/*! \brief Parse the parts of the P-Asserted-Identity header
- * on an incoming packet. Returns 1 if a valid header is found
- * and it is different from the current caller id.
- */
-static int get_pai(struct sip_pvt *p, struct sip_request *req)
-{
-	char pai[256];
-	char privacy[64];
-	char *cid_num = NULL;
-	char *cid_name = NULL;
-	char emptyname[1] = "";
-	int callingpres = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;
-	char *uri = NULL;
-	int is_anonymous = 0, do_update = 1, no_name = 0;
-
-	ast_copy_string(pai, sip_get_header(req, "P-Asserted-Identity"), sizeof(pai));
-
-	if (ast_strlen_zero(pai)) {
-		return 0;
-	}
-
-	/* use the reqresp_parser function get_name_and_number*/
-	if (get_name_and_number(pai, &cid_name, &cid_num)) {
-		return 0;
-	}
-
-	if (global_shrinkcallerid && ast_is_shrinkable_phonenumber(cid_num)) {
-		ast_shrink_phone_number(cid_num);
-	}
-
-	uri = get_in_brackets(pai);
-	if (!strncasecmp(uri, "sip:anonymous@anonymous.invalid", 31)) {
-		callingpres = AST_PRES_PROHIB_USER_NUMBER_NOT_SCREENED;
-		/*XXX Assume no change in cid_num. Perhaps it should be
-		 * blanked?
-		 */
-		ast_free(cid_num);
-		is_anonymous = 1;
-		cid_num = (char *)p->cid_num;
-	}
-
-	ast_copy_string(privacy, sip_get_header(req, "Privacy"), sizeof(privacy));
-	if (!ast_strlen_zero(privacy) && !strncmp(privacy, "id", 2)) {
-		callingpres = AST_PRES_PROHIB_USER_NUMBER_NOT_SCREENED;
-	}
-	if (!cid_name) {
-		no_name = 1;
-		cid_name = (char *)emptyname;
-	}	
-	/* Only return true if the supplied caller id is different */
-	if (!strcasecmp(p->cid_num, cid_num) && !strcasecmp(p->cid_name, cid_name) && p->callingpres == callingpres) {
-		do_update = 0;
-	} else {
-
-		ast_string_field_set(p, cid_num, cid_num);
-		ast_string_field_set(p, cid_name, cid_name);
-		p->callingpres = callingpres;
-
-		if (p->owner) {
-			ast_set_callerid(p->owner, cid_num, cid_name, NULL);
-			ast_channel_caller(p->owner)->id.name.presentation = callingpres;
-			ast_channel_caller(p->owner)->id.number.presentation = callingpres;
-		}
-	}
-
-	/* get_name_and_number allocates memory for cid_num and cid_name so we have to free it */
-	if (!is_anonymous) {
-		ast_free(cid_num);
-	}
-	if (!no_name) {
-		ast_free(cid_name);
-	}
-
-	return do_update;
-}
-
 /*! \brief Get name, number and presentation from remote party id header,
  *  returns true if a valid header was found and it was different from the
  *  current caller id.
@@ -17322,6 +17820,7 @@
 	char *privacy = "";
 	char *screen = "";
 	char *start, *end;
+	int pai;
 
 	if (!ast_test_flag(&p->flags[0], SIP_TRUSTRPID))
 		return 0;
@@ -17330,7 +17829,13 @@
 		req = &p->initreq;
 	ast_copy_string(tmp, sip_get_header(req, "Remote-Party-ID"), sizeof(tmp));
 	if (ast_strlen_zero(tmp)) {
-		return get_pai(p, req);
+		ast_copy_string(tmp, sip_get_header(req, "P-Asserted-Identity"), sizeof(tmp));
+		if (ast_strlen_zero(tmp)) {
+			return 0;
+		}
+		pai = 1;
+	} else {
+		pai = 0;
 	}
 
 	/*
@@ -17382,7 +17887,13 @@
 	if (!end)
 		return 0;
 	*end++ = '\0';
-	if (*end) {
+	if (pai) {
+		if (!strcasecmp(sip_get_header(req, "Privacy"), "id")) {
+			callingpres = AST_PRES_PROHIB_USER_NUMBER_PASSED_SCREEN;
+		} else if (!strcasecmp(cid_num, "sip:anonymous@anonymous.invalid")) {
+			callingpres = AST_PRES_PROHIB_USER_NUMBER_NOT_SCREENED;
+		}
+	} else if (*end) {
 		start = end;
 		if (*start != ';')
 			return 0;
@@ -18193,10 +18704,10 @@
 
 		/* Then find devices based on IP */
 		if (!peer) {
-			char *uri_tmp, *callback = NULL, *dummy;
+			char *uri_tmp, *callbackexten = NULL, *dummy;
 			uri_tmp = ast_strdupa(uri2);
-			parse_uri(uri_tmp, "sip:,sips:", &callback, &dummy, &dummy, &dummy);
-			if (!ast_strlen_zero(callback) && (peer = sip_find_peer_by_ip_and_exten(&p->recv, callback, p->socket.type))) {
+			parse_uri(uri_tmp, "sip:,sips:", &callbackexten, &dummy, &dummy, &dummy);
+			if (!ast_strlen_zero(callbackexten) && (peer = sip_find_peer_by_ip_and_exten(&p->recv, callbackexten, p->socket.type))) {
 				; /* found, fall through */
 			} else {
 				peer = sip_find_peer(NULL, &p->recv, TRUE, FINDPEERS, FALSE, p->socket.type);
@@ -18601,7 +19112,7 @@
 		return;
 	}
 
-	if (!(buf = get_content(req))) {
+	if (!(buf = get_content(req, 0, req->lines - 1))) {
 		ast_log(LOG_WARNING, "Unable to retrieve text from %s\n", p->callid);
 		transmit_response(p, "500 Internal Server Error", req);
 		if (!p->owner) {
@@ -19981,7 +20492,7 @@
 }
 
 /*! \brief list peer mailboxes to CLI */
-static void peer_mailboxes_to_str(struct ast_str **mailbox_str, struct sip_peer *peer)
+static void get_peer_mailboxes(struct ast_str **mailbox_str, struct sip_peer *peer)
 {
 	struct sip_mailbox *mailbox;
 
@@ -20018,6 +20529,8 @@
 	int x = 0, load_realtime;
 	struct ast_format codec;
 	int realtimepeers;
+	struct sip_alias *alias;
+	struct sip_subscription *subscription;
 
 	realtimepeers = ast_check_realtime("sippeers");
 
@@ -20075,8 +20588,6 @@
 			ao2_t_ref(credentials, -1, "Unref peer auth for show");
 		}
 		ast_cli(fd, "  Context      : %s\n", peer->context);
-		ast_cli(fd, "  Record On feature : %s\n", peer->record_on_feature);
-		ast_cli(fd, "  Record Off feature : %s\n", peer->record_off_feature);
 		ast_cli(fd, "  Subscr.Cont. : %s\n", S_OR(peer->subscribecontext, "<Not set>") );
 		ast_cli(fd, "  Language     : %s\n", peer->language);
 		ast_cli(fd, "  Tonezone     : %s\n", peer->zone[0] != '\0' ? peer->zone : "<Not set>");
@@ -20097,7 +20608,7 @@
 		print_named_groups(fd, peer->named_callgroups, 0);
 		ast_cli(fd, "  Nam. Pickupgr: ");
 		print_named_groups(fd, peer->named_pickupgroups, 0);
-		peer_mailboxes_to_str(&mailbox_str, peer);
+		get_peer_mailboxes(&mailbox_str, peer);
 		ast_cli(fd, "  MOH Suggest  : %s\n", peer->mohsuggest);
 		ast_cli(fd, "  Mailbox      : %s\n", ast_str_buffer(mailbox_str));
 		ast_cli(fd, "  VM Extension : %s\n", peer->vmexten);
@@ -20175,9 +20686,9 @@
 		ast_cli(fd, "  Qualify Freq : %d ms\n", peer->qualifyfreq);
 		ast_cli(fd, "  Keepalive    : %d ms\n", peer->keepalive * 1000);
 		if (peer->chanvars) {
-			ast_cli(fd, "  Variables    :\n");
+			ast_cli(fd, "  Variables    : ");
 			for (v = peer->chanvars ; v ; v = v->next)
-				ast_cli(fd, "                 %s = %s\n", v->name, v->value);
+				ast_cli(fd, "%s%s=%s\n", v != peer->chanvars ? "                 " : "", v->name, v->value);
 		}
 
 		ast_cli(fd, "  Sess-Timers  : %s\n", stmode2str(peer->stimer.st_mode_oper));
@@ -20186,8 +20697,27 @@
 		ast_cli(fd, "  Min-Sess     : %d secs\n", peer->stimer.st_min_se);
 		ast_cli(fd, "  RTP Engine   : %s\n", peer->engine);
 		ast_cli(fd, "  Parkinglot   : %s\n", peer->parkinglot);
+		ast_cli(fd, "  Record On    : %s\n", peer->record_on_feature);
+		ast_cli(fd, "  Record Off   : %s\n", peer->record_off_feature);
 		ast_cli(fd, "  Use Reason   : %s\n", AST_CLI_YESNO(ast_test_flag(&peer->flags[1], SIP_PAGE2_Q850_REASON)));
 		ast_cli(fd, "  Encryption   : %s\n", AST_CLI_YESNO(ast_test_flag(&peer->flags[1], SIP_PAGE2_USE_SRTP)));
+		ast_cli(fd, "  DND          : %s\n", AST_CLI_YESNO(peer->donotdisturb));
+		ast_cli(fd, "  CallFwd Ext. : %s\n", peer->callforward);
+		ast_cli(fd, "  Hunt Group   : %s\n", AST_CLI_YESNO(peer->huntgroup));
+		if (!AST_LIST_EMPTY(&peer->aliases)) {
+			ast_cli(fd, "  BulkReg.Peers: ");
+			AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+				ast_cli(fd, "%s%s (Line %d)\n", alias != AST_LIST_FIRST(&peer->aliases) ? "                 " : "", alias->name, alias->lineindex);
+			}
+		}
+
+		if (!AST_LIST_EMPTY(&peer->subscriptions)) {
+			ast_cli(fd, "  Subscriptions: ");
+			AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+				ast_cli(fd, "%s%s@%s\n", subscription != AST_LIST_FIRST(&peer->subscriptions) ? "                 " : "", subscription->exten, subscription->context);
+			}
+		}
+
 		ast_cli(fd, "\n");
 		peer = sip_unref_peer(peer, "sip_show_peer: sip_unref_peer: done with peer ptr");
 	} else  if (peer && type == 1) { /* manager listing */
@@ -20221,7 +20751,7 @@
 		astman_append(s, "%s\r\n", ast_print_namedgroups(&tmp_str, peer->named_pickupgroups));
 		ast_str_reset(tmp_str);
 		astman_append(s, "MOHSuggest: %s\r\n", peer->mohsuggest);
-		peer_mailboxes_to_str(&tmp_str, peer);
+		get_peer_mailboxes(&tmp_str, peer);
 		astman_append(s, "VoiceMailbox: %s\r\n", ast_str_buffer(tmp_str));
 		astman_append(s, "TransferMode: %s\r\n", transfermode2str(peer->allowtransfer));
 		astman_append(s, "LastMsgsSent: %d\r\n", peer->lastmsgssent);
@@ -20293,6 +20823,15 @@
 		}
 		astman_append(s, "SIP-Use-Reason-Header: %s\r\n", (ast_test_flag(&peer->flags[1], SIP_PAGE2_Q850_REASON)) ? "Y" : "N");
 		astman_append(s, "Description: %s\r\n", peer->description);
+		astman_append(s, "DoNotDisturb: %s\r\n", peer->donotdisturb ? "Y" : "N");
+		astman_append(s, "CallForward: %s\r\n", peer->callforward);
+		astman_append(s, "HuntGroup: %s\r\n", peer->huntgroup ? "Y" : "N");
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			astman_append(s, "Register: %d=%s\r\n", alias->lineindex, alias->name);
+		}
+		AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+			astman_append(s, "Subscribe: %s@%s\r\n", subscription->exten, subscription->context);
+		}
 
 		peer = sip_unref_peer(peer, "sip_show_peer: sip_unref_peer: done with peer");
 
@@ -20407,9 +20946,9 @@
 
 		ast_cli(a->fd, "  Auto-Framing:  %s \n", AST_CLI_YESNO(user->autoframing));
 		if (user->chanvars) {
- 			ast_cli(a->fd, "  Variables    :\n");
+ 			ast_cli(a->fd, "  Variables    : ");
 			for (v = user->chanvars ; v ; v = v->next)
- 				ast_cli(a->fd, "                 %s = %s\n", v->name, v->value);
+ 				ast_cli(a->fd, "%s%s=%s\n", v != user->chanvars ? "                 " : "", v->name, v->value);
 		}
 
 		ast_cli(a->fd, "\n");
@@ -21005,7 +21544,7 @@
 	if (cur->subscribed != NONE && arg->subscriptions) {
 		struct ast_str *mailbox_str = ast_str_alloca(512);
 		if (cur->subscribed == MWI_NOTIFICATION && cur->relatedpeer)
-			peer_mailboxes_to_str(&mailbox_str, cur->relatedpeer);
+			get_peer_mailboxes(&mailbox_str, cur->relatedpeer);
 		ast_cli(arg->fd, FORMAT4, ast_sockaddr_stringify_addr(dst),
 				S_OR(cur->username, S_OR(cur->cid_num, "(None)")),
 			   	cur->callid,
@@ -21499,7 +22038,7 @@
 			}
 		} else {
 			/* Type is application/dtmf, simply use what's in the message body */
-			buf = get_content(req);
+			buf = get_content(req, 0, req->lines - 1);
 		}
 
 		/* An empty message body requires us to send a 200 OK */
@@ -21727,6 +22266,8 @@
 static char *sip_cli_notify(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct ast_variable *varlist;
+	struct ast_channel *chan;
+	struct ast_str *str;
 	int i;
 
 	switch (cmd) {
@@ -21741,8 +22282,9 @@
 		return complete_sip_notify(a->line, a->word, a->pos, a->n);
 	}
 
-	if (a->argc < 4)
+	if (a->argc < 4) {
 		return CLI_SHOWUSAGE;
+	}
 
 	if (!notify_types) {
 		ast_cli(a->fd, "No %s file found, or no types listed there\n", notify_config);
@@ -21756,10 +22298,21 @@
 		return CLI_FAILURE;
 	}
 
+	if (!(chan = ast_dummy_channel_alloc())) {
+		ast_cli(a->fd, "Cannot allocate the channel for variables substitution\n");
+		return CLI_FAILURE;
+	}
+
+	if (!(str = ast_str_create(32))) {
+		ast_channel_release(chan);
+		ast_cli(a->fd, "Cannot allocate the string for variables substitution\n");
+		return CLI_FAILURE;
+	}
+
 	for (i = 3; i < a->argc; i++) {
 		struct sip_pvt *p;
-		char buf[512];
-		struct ast_variable *header, *var;
+		char tmp[1024];
+		struct ast_variable *var, *header, *headers = NULL;
 
 		if (!(p = sip_alloc(NULL, NULL, 0, SIP_NOTIFY, NULL, NULL))) {
 			ast_log(LOG_WARNING, "Unable to build sip pvt data for notify (memory/socket error)\n");
@@ -21778,36 +22331,216 @@
 		/* Notify is outgoing call */
 		ast_set_flag(&p->flags[0], SIP_OUTGOING);
 		sip_notify_alloc(p);
-		p->notify->headers = header = ast_variable_new("Subscription-State", "terminated", "");
+
+		/* Recalculate our side, and recalculate Call ID */
+		ast_sip_ouraddrfor(&p->sa, &p->ourip, p);
+		change_callid_pvt(p, NULL);
+
+		/* Set the name of the peer being sent the notification so it can be used in ${} functions */
+		pbx_builtin_setvar_helper(chan, "PEERNAME", p->peername);
+
+		for (var = p->chanvars; var; var = var->next) {
+			pbx_builtin_setvar_helper(chan, var->name, ast_get_encoded_str(var->value, tmp, sizeof(tmp)));
+		}
 
 		for (var = varlist; var; var = var->next) {
-			ast_copy_string(buf, var->value, sizeof(buf));
-			ast_unescape_semicolon(buf);
+			ast_copy_string(tmp, var->value, sizeof(tmp));
+			ast_unescape_semicolon(tmp);
+			ast_str_substitute_variables(&str, 0, chan, tmp);
 
 			if (!strcasecmp(var->name, "Content")) {
-				if (ast_str_strlen(p->notify->content))
-					ast_str_append(&p->notify->content, 0, "\r\n");
-				ast_str_append(&p->notify->content, 0, "%s", buf);
+				ast_str_append(&p->notify->content, 0, "%s\r\n", ast_str_buffer(str));
 			} else if (!strcasecmp(var->name, "Content-Length")) {
 				ast_log(LOG_WARNING, "it is not necessary to specify Content-Length in sip_notify.conf, ignoring\n");
 			} else {
-				header->next = ast_variable_new(var->name, buf, "");
-				header = header->next;
+				header = ast_variable_new(var->name, ast_str_buffer(str), "");
+				if (headers) {
+					headers->next = header;
+				} else {
+					p->notify->headers = header;
+				}
+				headers = header;
 			}
 		}
 
-		/* Now that we have the peer's address, set our ip and change callid */
-		ast_sip_ouraddrfor(&p->sa, &p->ourip, p);
-		build_via(p);
-
-		change_callid_pvt(p, NULL);
-
 		ast_cli(a->fd, "Sending NOTIFY of type '%s' to '%s'\n", a->argv[2], a->argv[i]);
 		sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
 		transmit_invite(p, SIP_NOTIFY, 0, 2, NULL);
 		dialog_unref(p, "bump down the count of p since we're done with it.");
 	}
 
+	ast_channel_release(chan);
+	ast_free(str);
+
+	return CLI_SUCCESS;
+}
+
+/*! \brief Enable/Disable DoNotDisturb on a peer */
+static char *sip_cli_donotdisturb(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct sip_peer *peer;
+	struct sip_alias *alias;
+	int donotdisturb;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "sip donotdisturb {on|off}";
+		e->usage =
+			"Usage: sip donotdisturb {on|off} <peer>\n"
+			"       Enables/Disables do not disturb on a SIP peer\n";
+		return NULL;
+	case CLI_GENERATE:
+		if (a->pos == 3) {
+			return complete_sip_peer(a->word, a->n, 0);
+		}
+		return NULL;
+	}
+
+	if (a->argc < 4) {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!strcasecmp(a->argv[2], "on")) {
+		donotdisturb = 1;
+	} else if (!strcasecmp(a->argv[2], "off")) {
+		donotdisturb = 0;
+	} else {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!(peer = sip_find_peer(a->argv[3], NULL, TRUE, FINDPEERS, FALSE, 0))) {
+		ast_cli(a->fd, "No such peer '%s'\n", a->argv[3]);
+		return CLI_FAILURE;
+	}
+
+	ast_cli(a->fd, "Do Not Disturb on '%s' %s\n", peer->name, donotdisturb ? "enabled" : "disabled");
+	peer->donotdisturb = donotdisturb;
+	ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", peer->name);
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		if (alias->peer) {
+			alias->peer->donotdisturb = peer->donotdisturb;
+			ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", alias->peer->name);
+		}
+	}
+	if (!peer->is_realtime) {
+		ast_db_put("SIP/DoNotDisturb", peer->name, donotdisturb ? "yes" : "no");
+	}
+	sip_send_donotdisturb(peer);
+	peer = sip_unref_peer(peer, "unref after sip_find_peer");
+
+	return CLI_SUCCESS;
+}
+
+/*! \brief Sets/Removes the call fowarding extension for a peer */
+static char *sip_cli_callforward(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct sip_peer *peer;
+	const char *callforward;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "sip callforward {on|off}";
+		e->usage =
+			"Usage: sip callforward {on <peer> <extension>|off <peer>}\n"
+			"       Sets/Removes the call forwarding extension for a SIP peer\n";
+		return NULL;
+	case CLI_GENERATE:
+		if (a->pos == 3) {
+			return complete_sip_peer(a->word, a->n, 0);
+		}
+		return NULL;
+	}
+
+	if (a->argc < 4) {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!strcasecmp(a->argv[2], "on")) {
+		if (a->argc < 5) {
+			return CLI_SHOWUSAGE;
+		}
+		callforward = a->argv[4];
+	} else if (!strcasecmp(a->argv[2], "off")) {
+		callforward = "";
+	} else {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!(peer = sip_find_peer(a->argv[3], NULL, TRUE, FINDPEERS, FALSE, 0))) {
+		ast_cli(a->fd, "No such peer '%s'\n", a->argv[3]);
+		return CLI_FAILURE;
+	}
+
+	if (ast_strlen_zero(callforward)) {
+		ast_cli(a->fd, "Call forwarding on '%s' removed\n", peer->name);
+	} else {
+		ast_cli(a->fd, "Call forwarding on '%s' set to %s\n", peer->name, callforward);
+	}
+	ast_string_field_set(peer, callforward, callforward);
+	if (!peer->is_realtime) {
+		if (ast_strlen_zero(peer->callforward)) {
+			ast_db_del("SIP/CallForward", peer->name);
+		} else {
+			ast_db_put("SIP/CallForward", peer->name, callforward);
+		}
+	}
+	sip_send_callforward(peer);
+	peer = sip_unref_peer(peer, "unref after sip_find_peer");
+
+	return CLI_SUCCESS;
+}
+
+/*! \brief Login to/Logout from huntgroup for a peer */
+static char *sip_cli_huntgroup(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct sip_peer *peer;
+	struct sip_alias *alias;
+	int huntgroup;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "sip huntgroup {on|off}";
+		e->usage =
+			"Usage: sip huntgroup {on|off} <peer>\n"
+			"       Login to/Logout from huntgroup for a SIP peer\n";
+		return NULL;
+	case CLI_GENERATE:
+		if (a->pos == 3) {
+			return complete_sip_peer(a->word, a->n, 0);
+		}
+		return NULL;
+	}
+
+	if (a->argc < 4) {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!strcasecmp(a->argv[2], "on")) {
+		huntgroup = 1;
+	} else if (!strcasecmp(a->argv[2], "off")) {
+		huntgroup = 0;
+	} else {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!(peer = sip_find_peer(a->argv[3], NULL, TRUE, FINDPEERS, FALSE, 0))) {
+		ast_cli(a->fd, "No such peer '%s'\n", a->argv[3]);
+		return CLI_FAILURE;
+	}
+
+	ast_cli(a->fd, "Hunt Group %s for '%s'\n", huntgroup ? "login" : "logout", peer->name);
+	peer->huntgroup = huntgroup;
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		if (alias->peer) {
+			alias->peer->huntgroup = peer->huntgroup;
+		}
+	}
+	if (!peer->is_realtime) {
+		ast_db_put("SIP/HuntGroup", peer->name, huntgroup ? "yes" : "no");
+	}
+	sip_send_huntgroup(peer);
+	peer = sip_unref_peer(peer, "unref after sip_find_peer");
+
 	return CLI_SUCCESS;
 }
 
@@ -22156,7 +22889,7 @@
 };
 
 /*! \brief  ${SIPPEER()} Dialplan function - reads peer data */
-static int function_sippeer(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)
+static int function_sippeer_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)
 {
 	struct sip_peer *peer;
 	char *colname;
@@ -22214,7 +22947,7 @@
 		ast_copy_string(buf, peer->useragent, len);
 	} else  if (!strcasecmp(colname, "mailbox")) {
 		struct ast_str *mailbox_str = ast_str_alloca(512);
-		peer_mailboxes_to_str(&mailbox_str, peer);
+		get_peer_mailboxes(&mailbox_str, peer);
 		ast_copy_string(buf, ast_str_buffer(mailbox_str), len);
 	} else  if (!strcasecmp(colname, "context")) {
 		ast_copy_string(buf, peer->context, len);
@@ -22251,11 +22984,76 @@
 		} else {
 			buf[0] = '\0';
 		}
+	} else if (!strncasecmp(colname, "donotdisturb", 12)) {
+		ast_copy_string(buf, peer->donotdisturb ? "yes" : "no", len);
+	} else if (!strncasecmp(colname, "callforward", 11)) {
+		ast_copy_string(buf, peer->callforward, len);
+	} else if (!strncasecmp(colname, "huntgroup", 9)) {
+		ast_copy_string(buf, peer->huntgroup ? "yes" : "no", len);
+	} else if (!strncasecmp(colname, "regcallid", 9)) {
+		ast_copy_string(buf, peer->regcallid, len);
 	} else {
 		buf[0] = '\0';
 	}
 
-	sip_unref_peer(peer, "sip_unref_peer from function_sippeer, just before return");
+	sip_unref_peer(peer, "sip_unref_peer from function_sippeer_read, just before return");
+
+	return 0;
+}
+
+static int function_sippeer_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)
+{
+	struct sip_peer *peer;
+	struct sip_alias *alias;
+	char *colname;
+
+	if ((colname = strchr(data, ','))) {
+		*colname++ = '\0';
+	} else {
+		colname = "";
+	}
+
+	if (!(peer = sip_find_peer(data, NULL, TRUE, FINDPEERS, FALSE, 0))) {
+		return -1;
+	}
+
+	if (!strncasecmp(colname, "donotdisturb", 12)) {
+		peer->donotdisturb = ast_true(value);
+		ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", peer->name);
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			if (alias->peer) {
+				alias->peer->donotdisturb = peer->donotdisturb;
+				ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", alias->peer->name);
+			}
+		}
+		if (!peer->is_realtime) {
+			ast_db_put("SIP/DoNotDisturb", peer->name, peer->donotdisturb ? "yes" : "no");
+		}
+		sip_send_donotdisturb(peer);
+	} else if (!strncasecmp(colname, "callforward", 11)) {
+		ast_string_field_set(peer, callforward, value);
+		if (!peer->is_realtime) {
+			if (ast_strlen_zero(peer->callforward)) {
+				ast_db_del("SIP/CallForward", peer->name);
+			} else {
+				ast_db_put("SIP/CallForward", peer->name, peer->callforward);
+			}
+		}
+		sip_send_callforward(peer);
+	} else if (!strncasecmp(colname, "huntgroup", 9)) {
+		peer->huntgroup = ast_true(value);
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			if (alias->peer) {
+				alias->peer->huntgroup = peer->huntgroup;
+			}
+		}
+		if (!peer->is_realtime) {
+			ast_db_put("SIP/HuntGroup", peer->name, peer->huntgroup ? "yes" : "no");
+		}
+		sip_send_huntgroup(peer);
+	}
+
+	sip_unref_peer(peer, "sip_unref_peer from function_sippeer_write, just before return");
 
 	return 0;
 }
@@ -22263,7 +23061,8 @@
 /*! \brief Structure to declare a dialplan function: SIPPEER */
 static struct ast_custom_function sippeer_function = {
 	.name = "SIPPEER",
-	.read = function_sippeer,
+	.read = function_sippeer_read,
+	.write = function_sippeer_write
 };
 
 /*! \brief ${SIPCHANINFO()} Dialplan function - reads sip channel data */
@@ -23126,6 +23925,22 @@
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
 		xmitres = transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, TRUE);
 		check_pendings(p);
+
+		if (ast_test_flag(&p->flags[2], SIP_PAGE3_RELAY_NEAREND) || ast_test_flag(&p->flags[2], SIP_PAGE3_RELAY_FAREND)) {
+			if (ast_test_flag(&p->flags[2], SIP_PAGE3_RELAY_NEAREND)) {
+				ast_clear_flag(&p->flags[2], SIP_PAGE3_RELAY_NEAREND);
+				start_record_thread(p->join_callid, p->join_tag, p->join_theirtag, 0);
+			} else {
+				ast_clear_flag(&p->flags[2], SIP_PAGE3_RELAY_FAREND);
+			}
+
+			ast_set_flag(&p->flags[2], SIP_PAGE3_SDP_ACK);
+			transmit_invite(p, SIP_INVITE, FALSE, 1, NULL);
+		} else if (ast_test_flag(&p->flags[2], SIP_PAGE3_SDP_ACK)) {
+			ast_clear_flag(&p->flags[2], SIP_PAGE3_SDP_ACK);
+			ast_set_flag(&p->flags[2], SIP_PAGE3_CISCO_RECORDING);
+		}
+
 		break;
 
 	case 407: /* Proxy authentication */
@@ -23421,6 +24236,7 @@
 		return;
 
 	switch (resp) {
+	case 200:   /* Out of Dialog REFER */
 	case 202:   /* Transfer accepted */
 		/* We need  to do something here */
 		/* The transferee is now sending INVITE to target */
@@ -23672,6 +24488,8 @@
 	struct sip_peer *peer = /* sip_ref_peer( */ p->relatedpeer /* , "bump refcount on p, as it is being used in this function(handle_response_peerpoke)")*/ ; /* hope this is already refcounted! */
 	int statechanged, is_reachable, was_reachable;
 	int pingtime = ast_tvdiff_ms(ast_tvnow(), peer->ps);
+	const char *status;
+	char lastms[20];
 
 	/*
 	 * Compute the response time to a ping (goes in peer->lastms.)
@@ -23695,27 +24513,44 @@
 	is_reachable = pingtime <= peer->maxms;
 	statechanged = peer->lastms == 0 /* yes, unknown before */
 		|| was_reachable != is_reachable;
+	status = is_reachable ? "Reachable" : "Lagged";
+	snprintf(lastms, sizeof(lastms), "%d", pingtime);
 
 	peer->lastms = pingtime;
 	peer->call = dialog_unref(peer->call, "unref dialog peer->call");
 	if (statechanged) {
-		const char *s = is_reachable ? "Reachable" : "Lagged";
-		char str_lastms[20];
-		snprintf(str_lastms, sizeof(str_lastms), "%d", pingtime);
-
 		ast_log(LOG_NOTICE, "Peer '%s' is now %s. (%dms / %dms)\n",
-			peer->name, s, pingtime, peer->maxms);
+			peer->name, status, pingtime, peer->maxms);
 		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", peer->name);
 		if (sip_cfg.peer_rtupdate) {
-			ast_update_realtime(ast_check_realtime("sipregs") ? "sipregs" : "sippeers", "name", peer->name, "lastms", str_lastms, SENTINEL);
+			ast_update_realtime(ast_check_realtime("sipregs") ? "sipregs" : "sippeers", "name", peer->name, "lastms", lastms, SENTINEL);
 		}
 		manager_event(EVENT_FLAG_SYSTEM, "PeerStatus",
 			"ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: %s\r\nTime: %d\r\n",
-			peer->name, s, pingtime);
+			peer->name, status, pingtime);
 		if (is_reachable && sip_cfg.regextenonqualify)
 			register_peer_exten(peer, TRUE);
 	}
 
+	if (!AST_LIST_EMPTY(&peer->aliases)) {
+		struct sip_alias *alias;
+
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			alias->peer->lastms = pingtime;
+
+			if (statechanged) {
+				ast_log(LOG_NOTICE, "Peer '%s' is now %s. (%dms / %dms)\n",
+					alias->peer->name, status, pingtime, alias->peer->maxms);
+				ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", alias->peer->name);
+				manager_event(EVENT_FLAG_SYSTEM, "PeerStatus",
+					"ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: %s\r\nTime: %d\r\n",
+					alias->peer->name, status, pingtime);
+				if (is_reachable && sip_cfg.regextenonqualify)
+					register_peer_exten(alias->peer, TRUE);
+			}
+		}
+	}
+
 	pvt_set_needdestroy(p, "got OPTIONS response");
 
 	/* Try again eventually */
@@ -24256,6 +25091,9 @@
 
 				/* Wait for 487, then destroy */
 			} else if (sipmethod == SIP_BYE) {
+				if (ast_test_flag(&p->flags[2], SIP_PAGE3_RTP_STATS_ON_BYE)) {
+					parse_rtp_stats(p, req);
+				}
 				pvt_set_needdestroy(p, "transaction completed");
 			}
 			break;
@@ -24515,6 +25353,2377 @@
 	return 0;
 }
 
+/*! \brief Handle idivert request */
+static int handle_remotecc_idivert(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *targetcall_pvt;
+	struct ast_channel *chan, *bridgedchan;
+
+	/* The remotetag and localtag are swapped here because those are from the viewpoint of the phone */
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+		ast_debug(1, "dialogid call leg does not exist\n");
+		return -1;
+	}
+
+	if (!(chan = targetcall_pvt->owner)) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(targetcall_pvt);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		return -1;
+	}
+
+	ast_channel_ref(chan);
+	sip_pvt_unlock(targetcall_pvt);
+	ast_channel_unlock(targetcall_pvt->owner);
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	if (ast_channel_state(chan) == AST_STATE_RINGING) {
+		ast_queue_control(chan, AST_CONTROL_BUSY);
+	} else if (ast_channel_state(chan) == AST_STATE_UP) {
+		if ((bridgedchan = ast_bridged_channel(chan))) {
+			ast_channel_lock(bridgedchan);
+			pbx_builtin_setvar_helper(bridgedchan, "IDIVERT_PEERNAME", peer->name);
+			ast_channel_unlock(bridgedchan);
+
+			ast_async_goto(bridgedchan, peer->context, "idivert", 1);
+		}
+	}
+
+	ast_channel_unref(chan);
+
+	return 0;
+}
+
+/*! \brief Handle hlog request */
+static int handle_remotecc_hlog(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_alias *alias;
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	peer->huntgroup = !peer->huntgroup;
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		if (alias->peer) {
+			alias->peer->huntgroup = peer->huntgroup;
+		}
+	}
+	if (!peer->is_realtime) {
+		ast_db_put("SIP/HuntGroup", peer->name, peer->huntgroup ? "yes" : "no");
+	}
+	sip_send_huntgroup(peer);
+
+	return 0;
+}
+
+/*! \brief Play a sound when someone joins or leaves an ad-hoc conference, must be called with conference locked */
+static void play_conference_sound(struct sip_conference *conference, const char *filename)
+{
+	struct ast_channel *playback_bridgedchan = ast_channel_tech(conference->playback_chan)->bridged_channel(conference->playback_chan, NULL);
+
+	if (playback_bridgedchan) {
+		ast_bridge_impart(conference->bridge, playback_bridgedchan, NULL, NULL, 0);
+		ast_stream_and_wait(conference->playback_chan, filename, "");
+		ast_bridge_depart(conference->bridge, playback_bridgedchan);
+	}
+}
+
+/*! \brief SIP conference support function
+ *	Starts in a new thread, make channel participate in conference bridge
+ */
+static void *participant_thread(void *obj)
+{
+	struct sip_participant *participant = obj;
+	struct sip_conference *conference = participant->conference;
+
+	if (!participant->administrator && conference->multiadmin) {
+		ast_channel_lock(participant->chan);
+		if (ast_channel_tech(participant->chan) == &sip_tech) {
+			struct sip_pvt *pvt = ast_channel_tech_pvt(participant->chan);	
+
+			sip_pvt_lock(pvt);
+			if (ast_test_flag(&pvt->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER) && ast_test_flag(&pvt->flags[2], SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE)) {
+				pvt->conference = conference;
+				ao2_ref(conference, +1);
+				participant->administrator = 1;
+
+				ast_debug(1, "%s is now an administrator in ad-hoc conference %d\n", ast_channel_name(participant->chan), conference->confid);
+			}
+			sip_pvt_unlock(pvt);
+		}
+		ast_channel_unlock(participant->chan);
+	}
+
+	if (participant->administrator) {
+		struct ast_party_connected_line connected;
+
+		ast_party_connected_line_init(&connected);
+
+		ast_channel_lock(participant->chan);
+		ast_party_connected_line_copy(&connected, ast_channel_connected(participant->chan));
+		ast_channel_unlock(participant->chan);
+
+		ast_free(connected.id.name.str);
+		connected.id.name.str = ast_strdup("\2004"); /* The phone translates \2004 into the localized version of Conference */ 
+		connected.id.name.valid = 1;
+
+		ast_free(connected.id.number.str);
+		connected.id.number.str = ast_strdup("");
+		connected.id.number.valid = 1;
+
+		ast_channel_update_connected_line(participant->chan, &connected, NULL);
+		ast_party_connected_line_free(&connected);
+	}
+
+	ao2_lock(conference);
+	AST_LIST_INSERT_HEAD(&conference->participants, participant, entry);
+
+	if (participant->administrator) {
+		conference->administrators++;
+	} else {
+		conference->users++;
+	}
+	if ((conference->administrators + conference->users) > 2) {
+		play_conference_sound(conference, "confbridge-join");
+	}
+	ao2_unlock(conference);
+
+	ast_bridge_join(conference->bridge, participant->chan, NULL, &participant->features, NULL);
+	ast_verb(3, "%s left ad-hoc conference %d\n", ast_channel_name(participant->chan), conference->confid);
+
+	ao2_lock(conference);
+	AST_LIST_REMOVE(&conference->participants, participant, entry);
+
+	if (participant->administrator) {
+		conference->administrators--;
+	} else {
+		conference->users--;
+	}
+	if ((conference->administrators + conference->users) > 1) {
+		play_conference_sound(conference, "confbridge-leave");
+	}
+
+	if ((conference->administrators + conference->users) == 1) {
+		struct sip_participant *participant;
+
+		ast_debug(1, "Only one participant left in ad-hoc conference %d, hanging them up\n", conference->confid);
+
+		participant = AST_LIST_FIRST(&conference->participants);
+		ast_bridge_remove(conference->bridge, participant->chan);
+	} else if (!conference->administrators && !conference->keep) {
+		struct sip_participant *participant;
+
+		ast_debug(1, "Destroying conference %d as last administrator has left\n", conference->confid);
+
+		AST_LIST_TRAVERSE(&conference->participants, participant, entry) {
+			ast_bridge_remove(conference->bridge, participant->chan);
+		}
+	}
+	ao2_unlock(conference);
+
+	ast_channel_unref(participant->chan);
+	ast_hangup(participant->chan);
+	ao2_ref(participant->conference, -1);
+	ast_free(participant);
+
+	return NULL;
+}
+
+/*! \brief destroy conference callback for ao2_alloc */
+static void destroy_conference(void *obj)
+{
+	struct sip_conference *conference = obj;
+
+	ast_debug(1, "Destroying ad-hoc conference %d\n", conference->confid);
+	if (conference->bridge) {
+		ast_bridge_destroy(conference->bridge);
+		conference->bridge = NULL;
+	}
+	if (conference->playback_chan) {
+		struct ast_channel *playback_bridgedchan = ast_channel_tech(conference->playback_chan)->bridged_channel(conference->playback_chan, NULL);
+
+		if (playback_bridgedchan) {
+			ast_hangup(playback_bridgedchan);
+		}
+		ast_hangup(conference->playback_chan);
+		conference->playback_chan = NULL;
+	}
+
+	AST_LIST_LOCK(&conferencel);
+	AST_LIST_REMOVE(&conferencel, conference, entry);
+	AST_LIST_UNLOCK(&conferencel);
+}
+
+/*! \brief create conference and assign it to a sip_pvt */
+static int create_conference(struct sip_pvt *pvt)
+{
+	struct sip_conference *conference;
+	struct ast_format_cap *cap;
+	struct ast_format format;
+	int cause;
+
+	if (!(conference = ao2_alloc(sizeof(*conference), destroy_conference))) {
+		return -1;
+	}
+
+	if (!(conference->bridge = ast_bridge_new(AST_BRIDGE_CAPABILITY_MULTIMIX, 0))) {
+		ao2_ref(conference, -1);
+		return -1;
+	}
+
+	if (!(cap = ast_format_cap_alloc_nolock())) {
+		ao2_ref(conference, -1);
+		return -1;
+	}
+
+	ast_format_cap_add(cap, ast_format_set(&format, AST_FORMAT_SLINEAR, 0));
+	if (!(conference->playback_chan = ast_request("Bridge", cap, NULL, "", &cause))) {
+		ast_format_cap_destroy(cap);
+		ao2_ref(conference, -1);
+		return -1;
+	}
+
+	ast_format_cap_destroy(cap);
+	ast_channel_internal_bridge_set(conference->playback_chan, conference->bridge);
+
+	conference->confid = ++next_confid;
+	conference->keep = ast_test_flag(&pvt->flags[2], SIP_PAGE3_CISCO_KEEP_CONFERENCE) ? 1 : 0; 
+	conference->multiadmin = ast_test_flag(&pvt->flags[2], SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE) ? 1 : 0;
+	AST_LIST_HEAD_INIT_NOLOCK(&conference->participants);
+
+	pvt->conference = conference;
+
+	AST_LIST_LOCK(&conferencel);
+	AST_LIST_INSERT_TAIL(&conferencel, conference, entry);
+	AST_LIST_UNLOCK(&conferencel);
+
+	ast_debug(1, "Creating ad-hoc conference %d\n", conference->confid);
+
+	return 0;
+}
+
+/*! \brief sets whether the current participant is talking */
+static void participant_talk_detector_cb(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, void *obj)
+{
+	struct sip_participant *participant = obj;
+
+	if (bridge_channel->state == AST_BRIDGE_CHANNEL_STATE_START_TALKING) {
+		participant->talking = 1;
+	} else if (bridge_channel->state == AST_BRIDGE_CHANNEL_STATE_STOP_TALKING) {
+		participant->talking = 0;
+	}
+}
+
+/*! \brief allocate participant structure and spawn thread that adds channel to conference */
+static int join_conference(struct sip_conference *conference, struct ast_channel *chan, int administrator)
+{
+	struct sip_participant *participant;
+	pthread_t threadid;
+
+	if (!(participant = ast_calloc(1, sizeof(*participant)))) {
+		return -1;
+	}
+
+	participant->chan = ast_channel_alloc(0, AST_STATE_DOWN, 0, 0, ast_channel_accountcode(chan), ast_channel_exten(chan), ast_channel_context(chan), ast_channel_linkedid(chan), ast_channel_amaflags(chan), "Conference/%s", ast_channel_name(chan));
+	if (!participant->chan) {
+		ast_free(participant);
+		return -1;
+	}
+
+	ast_format_copy(ast_channel_readformat(participant->chan), ast_channel_readformat(chan));
+	ast_format_copy(ast_channel_writeformat(participant->chan), ast_channel_writeformat(chan));
+
+	if (ast_channel_masquerade(participant->chan, chan)) {
+		ast_hangup(participant->chan);
+		ast_free(participant);
+		return -1;
+	}
+
+	ast_channel_context_set(participant->chan, ast_channel_context(chan));
+	ast_channel_exten_set(participant->chan, ast_channel_exten(chan));
+	ast_channel_priority_set(participant->chan, ast_channel_priority(chan));
+
+	ast_do_masquerade(participant->chan);
+
+	ao2_ref(conference, +1);
+	ast_channel_ref(participant->chan);
+
+	participant->conference = conference;
+	participant->callid = ++conference->next_callid;
+	participant->administrator = administrator;
+	ast_bridge_features_set_talk_detector(&participant->features, participant_talk_detector_cb, NULL, participant);
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, participant_thread, participant)) {
+		ast_channel_unref(participant->chan);
+		ao2_ref(conference, -1);
+		return -1;
+	}
+	ast_verb(3, "%s joined ad-hoc conference %d\n", ast_channel_name(participant->chan), conference->confid);
+
+	return 0;
+}
+
+/*! \brief add channels to conference */
+static void *conference_thread(void *obj)
+{
+	struct conference_data *conference_data = obj;
+	struct sip_pvt *pvt;
+	struct ast_channel *chan, *bridgedchan;
+	struct sip_conference *conference = NULL;
+	struct sip_request req;
+	struct ast_str *content = ast_str_alloca(SIPBUFSIZE * 10);
+	char tmp[64];
+	int res = -1;
+
+	if (!(pvt = get_sip_pvt_byid_locked(conference_data->callid, conference_data->tag, conference_data->theirtag))) {
+		ast_debug(1, "call leg does not exist\n");
+		goto conference_cleanup;
+	}
+
+	/* Is this a new ad-hoc conference? */
+	if (!pvt->conference) {
+		if (create_conference(pvt)) {
+			ast_debug(1, "unable to create conference\n");
+			sip_pvt_unlock(pvt);
+			if (pvt->owner) {
+				ast_channel_unlock(pvt->owner);
+			}
+			dialog_unref(pvt, "drop pvt");
+			goto conference_cleanup;
+		}
+
+		/* Increase ref on conference so we don't need to keep a ref on it's parent dialog */
+		conference = pvt->conference;
+		ao2_ref(conference, +1);
+
+		if (!(chan = pvt->owner)) {
+			ast_debug(1, "no owner channel\n");
+			sip_pvt_unlock(pvt);
+			dialog_unref(pvt, "drop pvt");
+			goto conference_cleanup;
+		}
+
+		if (!(bridgedchan = ast_bridged_channel(pvt->owner))) {
+			ast_debug(1, "no bridged channel\n");
+			sip_pvt_unlock(pvt);
+			ast_channel_unlock(pvt->owner);
+			dialog_unref(pvt, "drop pvt");
+			goto conference_cleanup;
+		}
+
+		ast_channel_ref(chan);
+		ast_channel_ref(bridgedchan);
+
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop pvt");
+
+		if (join_conference(conference, chan, 1)) {
+			ast_channel_unref(chan);
+			ast_channel_unref(bridgedchan);
+			goto conference_cleanup;
+		}
+
+		if (join_conference(conference, bridgedchan, 0)) {
+			ast_channel_unref(chan);
+			ast_channel_unref(bridgedchan);
+			goto conference_cleanup;
+		}
+
+		ast_channel_unref(chan);
+		ast_channel_unref(bridgedchan);
+	} else { 
+		conference = pvt->conference;
+		ao2_ref(conference, +1);
+
+		sip_pvt_unlock(pvt);
+		if (pvt->owner) {
+			ast_channel_unlock(pvt->owner);
+		}
+		dialog_unref(pvt, "drop pvt");
+	}
+
+	if (!(pvt = get_sip_pvt_byid_locked(conference_data->join_callid, conference_data->join_tag, conference_data->join_theirtag))) {
+		ast_debug(1, "join call leg does not exist\n");
+		goto conference_cleanup;
+	}
+
+	if (!pvt->owner) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(pvt);
+		dialog_unref(pvt, "drop pvt");
+		goto conference_cleanup;
+	}
+
+	if (!(bridgedchan = ast_bridged_channel(pvt->owner))) {
+		ast_debug(1, "no bridged channel\n");
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop pvt");
+		goto conference_cleanup;
+	}
+
+	ast_channel_ref(bridgedchan);
+
+	sip_pvt_unlock(pvt);
+	ast_channel_unlock(pvt->owner);
+	dialog_unref(pvt, "drop join pvt"); 
+
+	if (join_conference(conference, bridgedchan, 0)) {
+		ast_channel_unref(bridgedchan);
+		goto conference_cleanup;
+	}
+
+	ast_channel_unref(bridgedchan);
+	res = 0;
+
+	/* We need to signal to the phone to take the first call leg off hold, even though the generator on that
+	   channel has gone due to the masquerade as the phone still thinks that it is on hold */
+	if (!(pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		goto conference_cleanup;
+	}
+	copy_pvt_data(pvt, conference_data->pvt);
+
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<holdretrievereq>\n");
+	ast_str_append(&content, 0, "<dialogid>\n");
+	ast_str_append(&content, 0, "<callid>%s</callid>\n", conference_data->callid);
+	ast_str_append(&content, 0, "<localtag>%s</localtag>\n", conference_data->theirtag);
+	ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", conference_data->tag);
+	ast_str_append(&content, 0, "</dialogid>\n");
+	ast_str_append(&content, 0, "</holdretrievereq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+	transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+	dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+
+conference_cleanup:
+	if (conference) {
+		ao2_ref(conference, -1);
+	}
+
+	reqprep(&req, conference_data->pvt, SIP_NOTIFY, 0, 1);
+	add_header(&req, "Event", "refer");
+	add_header(&req, "Subscription-State", "terminated;reason=noresource");
+	add_header(&req, "Content-Type", "application/x-cisco-remotecc-response+xml");
+
+	add_content(&req, "<x-cisco-remotecc-response>\n");
+	add_content(&req, "<response>\n");
+	snprintf(tmp, sizeof(tmp), "<code>%d</code>\n", res ? 500 : 200);
+	add_content(&req, tmp);
+	add_content(&req, "</response>\n");
+	add_content(&req, "</x-cisco-remotecc-response>\n");
+
+	send_request(conference_data->pvt, &req, XMIT_RELIABLE, conference_data->pvt->ocseq);
+	sip_scheddestroy(conference_data->pvt, SIP_TRANS_TIMEOUT);
+
+	dialog_unref(conference_data->pvt, "drop conference_data->pvt");
+	ast_string_field_free_memory(conference_data);
+	ast_free(conference_data);
+
+	return NULL;
+}
+
+/*! \brief Handle conference request */
+static int handle_remotecc_conference(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	pthread_t threadid;
+	char tmp[64];
+	struct sip_request notify_req;
+	struct conference_data *conference_data;
+
+	if (!(conference_data = ast_calloc_with_stringfields(1, struct conference_data, 128))) {
+		return -1;
+	}
+
+	dialog_ref(pvt, "copying dialog pvt into conference_data struct");
+	conference_data->pvt = pvt; 
+
+	ast_string_field_set(conference_data, callid, remotecc_data->dialogid.callid);
+	ast_string_field_set(conference_data, tag, remotecc_data->dialogid.remotetag);
+	ast_string_field_set(conference_data, theirtag, remotecc_data->dialogid.localtag);
+	ast_string_field_set(conference_data, join_callid, remotecc_data->consultdialogid.callid);
+	ast_string_field_set(conference_data, join_tag, remotecc_data->consultdialogid.remotetag);
+	ast_string_field_set(conference_data, join_theirtag, remotecc_data->consultdialogid.localtag);
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, conference_thread, conference_data)) {
+		dialog_unref(conference_data->pvt, "thread creation failed");
+		ast_string_field_free_memory(conference_data);
+		ast_free(conference_data);
+		return -1;
+	}
+
+	/* If the conference fails we send back a NOTIFY telling the phone */
+	transmit_response(pvt, "202 Accepted", req);
+
+	ast_set_flag(&pvt->flags[0], SIP_OUTGOING);
+	ast_set_flag(&pvt->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+
+	pvt->subscribed = REMOTECC_XML;
+	pvt->expiry = min_expiry;
+
+	initreqprep(&notify_req, pvt, SIP_NOTIFY, NULL);
+	add_header(&notify_req, "Event", "refer");
+	snprintf(tmp, sizeof(tmp), "active;expires=%d", pvt->expiry);
+	add_header(&notify_req, "Subscription-State", tmp);
+
+	if (!pvt->initreq.headers) {
+		initialize_initreq(pvt, &notify_req);
+	}
+	send_request(pvt, &notify_req, XMIT_RELIABLE, pvt->ocseq);
+
+	return 0;
+}
+
+/*! \brief Handle conflist and confdetails requests */
+static int handle_remotecc_conflist(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *refer_pvt;
+	struct sip_conference *conference = NULL;
+	struct sip_participant *participant;
+	struct ast_str *content;
+	int needpos = strstr(sip_get_header(req, "User-Agent"), "CP79") ? 1 : 0;
+
+	if (!ast_strlen_zero(remotecc_data->dialogid.callid)) {
+		struct sip_pvt *targetcall_pvt;
+
+		if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+			ast_debug(1, "dialogid call leg does not exist\n");
+			return -1;
+		}
+
+		if ((conference = targetcall_pvt->conference)) {
+			ao2_ref(conference, +1);
+		}
+
+		sip_pvt_unlock(targetcall_pvt);
+		if (targetcall_pvt->owner) {
+			ast_channel_unlock(targetcall_pvt->owner);
+		}
+		dialog_unref(targetcall_pvt, "drop pvt");
+	} else if (remotecc_data->confid) {
+		AST_LIST_LOCK(&conferencel);
+		AST_LIST_TRAVERSE(&conferencel, conference, entry) {
+			if (conference->confid == remotecc_data->confid) {
+				ao2_ref(conference, +1);
+				break;
+			}
+		}
+		AST_LIST_UNLOCK(&conferencel);
+	}
+
+	if (!conference) {
+		ast_debug(1, "Unable to find conference\n");
+		return -1;
+	}
+
+	if (!ast_strlen_zero(remotecc_data->usercalldata) && strcmp(remotecc_data->usercalldata, "Update")) {
+		int callid;
+
+		if (!strcmp(remotecc_data->usercalldata, "Remove") || !strcmp(remotecc_data->usercalldata, "Mute")) {
+			ast_copy_string(conference->action, remotecc_data->usercalldata, sizeof(conference->action));
+			ao2_ref(conference, -1);
+			transmit_response(pvt, "202 Accepted", req);
+			return 0;
+		}
+
+		/* Default action */
+		if (ast_strlen_zero(conference->action)) {
+			ast_copy_string(conference->action, "Mute", sizeof(conference->action));
+		}
+		callid = atoi(remotecc_data->usercalldata);
+
+		ao2_lock(conference);
+		AST_LIST_TRAVERSE(&conference->participants, participant, entry) {
+			if (participant->callid == callid) {
+				if (!strcmp(conference->action, "Remove")) {
+					ast_bridge_remove(conference->bridge, participant->chan);
+					participant->removed = 1;
+				} else if (!strcmp(conference->action, "Mute")) {
+					participant->features.mute = !participant->features.mute;
+				}
+				break;
+			}
+		}
+
+		conference->action[0] = '\0';
+		ao2_unlock(conference);
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	if (!(content = ast_str_create(SIPBUFSIZE * 10))) {
+		ao2_ref(conference, -1);
+		return 0;
+	}
+
+	if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		ao2_ref(conference, -1);
+		ast_free(content);
+		return 0;
+	}
+	copy_pvt_data(refer_pvt, pvt);
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<datapassthroughreq>\n");
+	ast_str_append(&content, 0, "<applicationid>%d</applicationid>\n", REMOTECC_CONFLIST);
+	ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+	ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+	ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+	ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+	ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+	ast_str_append(&content, 0, "<confid>%d</confid>\n", conference->confid);
+	ast_str_append(&content, 0, "</datapassthroughreq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "\r\n");
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<CiscoIPPhoneIconFileMenu>\n");
+	ast_str_append(&content, 0, "<Title IconIndex=\"4\">Conference</Title>\n");
+	ast_str_append(&content, 0, "<IconItem>\n");
+	ast_str_append(&content, 0, "<Index>1</Index>\n");
+	ast_str_append(&content, 0, "<URL>Resource:Icon.Checked</URL>\n");
+	ast_str_append(&content, 0, "</IconItem>\n");
+	ast_str_append(&content, 0, "<IconItem>\n");
+	ast_str_append(&content, 0, "<Index>2</Index>\n");
+	ast_str_append(&content, 0, "<URL>Resource:Icon.UnChecked</URL>\n");
+	ast_str_append(&content, 0, "</IconItem>\n");
+	ast_str_append(&content, 0, "<IconItem>\n");
+	ast_str_append(&content, 0, "<Index>3</Index>\n");
+	ast_str_append(&content, 0, "<URL>Resource:Icon.Speaker</URL>\n");
+	ast_str_append(&content, 0, "</IconItem>\n");
+	ast_str_append(&content, 0, "<IconItem>\n");
+	ast_str_append(&content, 0, "<Index>4</Index>\n");
+	ast_str_append(&content, 0, "<URL>Resource:Icon.Connected</URL>\n");
+	ast_str_append(&content, 0, "</IconItem>\n");
+
+	ao2_lock(conference);
+	AST_LIST_TRAVERSE(&conference->participants, participant, entry) {
+		char *callerid = NULL;
+		int iconindex;
+
+		if (participant->removed) {
+			continue;
+		}
+
+		if (participant->features.mute) {
+			iconindex = 2;
+		} else if (participant->talking) {
+			iconindex = 3;
+		} else {
+			iconindex = 1;
+		}
+
+		ast_channel_lock(participant->chan);
+		if (ast_strlen_zero(callerid) && ast_channel_caller(participant->chan)->id.name.valid) {
+			callerid = ast_strdupa(ast_channel_caller(participant->chan)->id.name.str);
+		}
+		if (ast_strlen_zero(callerid) && ast_channel_caller(participant->chan)->id.number.valid) {
+			callerid = ast_strdupa(ast_channel_caller(participant->chan)->id.number.str);
+		}
+		ast_channel_unlock(participant->chan);
+
+		ast_str_append(&content, 0, "<MenuItem>\n");
+		ast_str_append(&content, 0, "<IconIndex>%d</IconIndex>\n", iconindex);
+		ast_str_append(&content, 0, "<Name>%s</Name>\n", S_OR(callerid, CALLERID_UNKNOWN));
+		ast_str_append(&content, 0, "<URL>UserCallData:%d:0:%d:0:%d</URL>\n", REMOTECC_CONFLIST, conference->confid, participant->callid);
+		ast_str_append(&content, 0, "</MenuItem>\n");
+
+		ast_channel_unlock(participant->chan);
+	}
+	ao2_unlock(conference);
+
+	ast_str_append(&content, 0, "<Prompt>Please select</Prompt>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Exit</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 3 : 1);
+	ast_str_append(&content, 0, "<URL>SoftKey:Exit</URL>\n");
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Remove</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 1 : 2);
+	ast_str_append(&content, 0, "<URL>UserCallDataSoftKey:Select:%d:0:%d:0:Remove</URL>\n", REMOTECC_CONFLIST, conference->confid);
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Mute</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 2 : 3);
+	ast_str_append(&content, 0, "<URL>UserCallDataSoftKey:Select:%d:0:%d:0:Mute</URL>\n", REMOTECC_CONFLIST, conference->confid);
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Update</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 4 : 4);
+	ast_str_append(&content, 0, "<URL>UserCallDataSoftKey:Update:%d:0:%d:0:Update</URL>\n", REMOTECC_CONFLIST, conference->confid);
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "</CiscoIPPhoneIconFileMenu>\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+	transmit_refer_with_content(refer_pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+	dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+	ao2_ref(conference, -1);
+	ast_free(content);
+
+	return 0;
+}
+
+/*! \brief Handle remove last conference participant requests */
+static int handle_remotecc_rmlastconf(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *targetcall_pvt;
+	struct sip_conference *conference = NULL;
+	struct sip_participant *participant;
+
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+		ast_debug(1, "dialogid call leg does not exist\n");
+		return -1;
+	}
+
+	if (targetcall_pvt->conference) {
+		conference = targetcall_pvt->conference;
+		ao2_ref(conference, +1);
+	}
+
+	sip_pvt_unlock(targetcall_pvt);
+	if (targetcall_pvt->owner) {
+		ast_channel_unlock(targetcall_pvt->owner);
+	}
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	if (!conference) {
+		ast_debug(1, "Not in a conference\n");
+		return -1;
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	ao2_lock(conference);
+	if ((participant = AST_LIST_FIRST(&conference->participants))) {
+		ast_bridge_remove(conference->bridge, participant->chan);
+	}
+	ao2_unlock(conference);
+	ao2_ref(conference, -1);
+
+	return 0;
+}
+
+/*! \brief park call */
+static void *park_notify_thread(void *obj)
+{
+	struct park_data *park_data = obj;
+	struct sip_pvt *pvt;
+	struct ast_channel *chan, *bridgedchan;
+	int exten;
+	struct ast_str *content = ast_str_alloca(SIPBUFSIZE * 10);
+	int res = -1;
+
+	if (!(pvt = get_sip_pvt_byid_locked(park_data->callid, park_data->tag, park_data->theirtag))) {
+		ast_debug(1, "call leg does not exist\n");
+		goto park_cleanup;
+	}
+
+	if (!(chan = pvt->owner)) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(pvt);
+		dialog_unref(pvt, "drop pvt");
+		goto park_cleanup;
+	}
+
+	if (!(bridgedchan = ast_bridged_channel(chan))) {
+		ast_debug(1, "no bridged channel\n");
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop pvt");
+		goto park_cleanup;
+	}
+
+	ast_channel_ref(chan);
+	ast_channel_ref(bridgedchan);
+
+	sip_pvt_unlock(pvt);
+	ast_channel_unlock(pvt->owner);
+	dialog_unref(pvt, "drop pvt");
+
+	/* Needed so that comebacktoorigin will work */
+	pbx_builtin_setvar_helper(bridgedchan, "BLINDTRANSFER", ast_channel_name(chan));
+	ast_channel_unref(chan);
+
+	res = ast_masq_park_call_exten(bridgedchan, NULL, "park", park_data->context, 0, &exten);
+	ast_channel_unref(bridgedchan);
+
+park_cleanup:
+	if (res) {
+		transmit_response(park_data->pvt, "503 Service Unavailable", &park_data->req);	
+	} else {
+		transmit_response(park_data->pvt, "202 Accepted", &park_data->req);
+	}
+
+	if ((pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		copy_pvt_data(pvt, park_data->pvt);
+
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<statuslineupdatereq>\n");
+		ast_str_append(&content, 0, "<action>notify_display</action>\n");
+		ast_str_append(&content, 0, "<dialogid>\n");
+		ast_str_append(&content, 0, "<callid>%s</callid>\n", park_data->callid);
+		ast_str_append(&content, 0, "<localtag>%s</localtag>\n", park_data->theirtag);
+		ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", park_data->tag);
+		ast_str_append(&content, 0, "</dialogid>\n");
+		if (res) {
+			ast_str_append(&content, 0, "<statustext>\200^</statustext>\n");
+		} else {
+			ast_str_append(&content, 0, "<statustext>\200! %d</statustext>\n", exten);
+		}
+		ast_str_append(&content, 0, "<displaytimeout>10</displaytimeout>\n");
+		ast_str_append(&content, 0, "<linenumber>0</linenumber>\n");
+		ast_str_append(&content, 0, "<priority>5</priority>\n");
+		ast_str_append(&content, 0, "</statuslineupdatereq>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	}
+
+	dialog_unref(park_data->pvt, "drop park_data->pvt");
+	deinit_req(&park_data->req);
+	ast_string_field_free_memory(park_data);
+	ast_free(park_data);
+
+	return NULL;
+}
+
+/*! \brief Handle remotecc park requests */
+static int handle_remotecc_park(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	pthread_t threadid;
+	struct park_data *park_data;
+
+	if (!(park_data = ast_calloc_with_stringfields(1, struct park_data, 128))) {
+		return -1;
+	}
+
+	dialog_ref(pvt, "copying dialog pvt into park_data struct");
+	park_data->pvt = pvt;
+	copy_request(&park_data->req, req);
+
+	ast_string_field_set(park_data, context, peer->context);
+	ast_string_field_set(park_data, callid, remotecc_data->dialogid.callid);
+	ast_string_field_set(park_data, tag, remotecc_data->dialogid.remotetag);
+	ast_string_field_set(park_data, theirtag, remotecc_data->dialogid.localtag);
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, park_notify_thread, park_data)) {
+		dialog_unref(park_data->pvt, "thread creation failed");
+		ast_string_field_free_memory(park_data);
+		ast_free(park_data);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void park_monitor_event_cb(const struct ast_event *event, void *userdata)
+{
+	struct sip_pvt *pvt = userdata;
+	struct sip_request req;
+	char tmp[512];
+	const char *fromdomain = S_OR(pvt->fromdomain, ast_sockaddr_stringify_host_remote(&pvt->ourip));
+	int state, exten, done;
+	const char *cid_num, *parkevent;
+
+	if (pvt->subscribed == NONE) {
+		return;
+	}
+
+	state = ast_event_get_ie_uint(event, AST_EVENT_IE_STATE);
+	exten = ast_event_get_ie_uint(event, AST_EVENT_IE_EXTEN);
+	cid_num = ast_event_get_ie_str(event, AST_EVENT_IE_CIDNUM);
+
+	if (state == AST_PARKED_CALL_PARKED) {
+		parkevent = "parked";
+		done = 0;
+	} else if (state == AST_PARKED_CALL_REMINDER) {
+		parkevent = "reminder";
+		done = 0;
+	} else if (state == AST_PARKED_CALL_RETRIEVED) {
+		parkevent = "retrieved";
+		done = 1;
+	} else if (state == AST_PARKED_CALL_TIMEOUT) {
+		parkevent = "forwarded";
+		done = 1;
+	} else if (state == AST_PARKED_CALL_HANGUP) {
+		parkevent = "abandoned";
+		done = 1;
+	} else {
+		return;
+	}
+
+	if (!pvt->initreq.headers) {
+		initreqprep(&req, pvt, SIP_NOTIFY, NULL);
+	} else {
+		reqprep(&req, pvt, SIP_NOTIFY, 0, 1);
+	}
+	pvt->dialogver++;
+
+	add_header(&req, "Event", "refer");
+	if (done) {
+		add_header(&req, "Subscription-State", "terminated;reason=noresource");
+	} else {
+		snprintf(tmp, sizeof(tmp), "active;expires=%d", pvt->expiry);
+		add_header(&req, "Subscription-State", tmp);
+	}
+	add_header(&req, "Content-Type", "application/dialog-info+xml");
+
+	/* "parmams" is a typo in the the Cisco API, duh. */
+	snprintf(tmp, sizeof(tmp), "<dialog-info xmlns=\"urn:ietf:parmams:xml:ns:dialog-info\" xmlns:call=\"urn:x-cisco:parmams:xml:ns:dialog-info:dialog:callinfo-dialog\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"%d\" state=\"full\" entity=\"%d@%s\">\n", pvt->dialogver, exten, fromdomain);
+	add_content(&req, tmp);
+	snprintf(tmp, sizeof(tmp), "<dialog id=\"%d\">\n", exten);
+	add_content(&req, tmp);
+	snprintf(tmp, sizeof(tmp), "<state>%s</state>\n", done ? "terminated" : "confirmed");
+	add_content(&req, tmp);
+	snprintf(tmp, sizeof(tmp), "<call:park><event>%s</event></call:park>\n", parkevent);
+	add_content(&req, tmp);
+	snprintf(tmp, sizeof(tmp), "<local><identity display=\"\">sip:%d@%s</identity></local>\n", exten, fromdomain);
+	add_content(&req, tmp);
+	snprintf(tmp, sizeof(tmp), "<remote><identity display=\"\">sip:%s@%s</identity></remote>\n", cid_num, fromdomain);
+	add_content(&req, tmp);
+	add_content(&req, "</dialog>\n");
+	add_content(&req, "</dialog-info>\n");
+
+	if (!pvt->initreq.headers) {
+		initialize_initreq(pvt, &req);
+	}
+	send_request(pvt, &req, XMIT_RELIABLE, pvt->ocseq++);
+
+	if (done) {
+		/* Don't try and unsubscribe the event in callback as the event processor will deadlock trying to lock event sub list,
+		   instead just set subscibed to NONE to ignore additional events and unsubscribe in dialog_unlink_all */ 
+		pvt->subscribed = NONE;
+		sip_scheddestroy(pvt, DEFAULT_TRANS_TIMEOUT);
+		dialog_unref(pvt, "drop pvt");
+	}
+}
+
+/*! \brief park call and subscribe to park events */
+static void *park_monitor_thread(void *obj)
+{
+	struct park_data *park_data = obj;
+	struct sip_pvt *pvt;
+	struct ast_channel *chan, *bridgedchan;
+	int exten, timeout;
+	struct ast_event *event;
+	struct ast_str *content = ast_str_alloca(SIPBUFSIZE * 10);
+	int res = -1;
+
+	if (!(pvt = get_sip_pvt_byid_locked(park_data->callid, park_data->tag, park_data->theirtag))) {
+		ast_debug(1, "call leg does not exist\n");
+		goto park_cleanup;
+	}
+
+	if (!(chan = pvt->owner)) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(pvt);
+		dialog_unref(pvt, "drop pvt");
+		goto park_cleanup;
+	}
+
+	if (!(bridgedchan = ast_bridged_channel(chan))) {
+		ast_debug(1, "no bridged channel\n");
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop pvt");
+		goto park_cleanup;
+	}
+
+	ast_channel_ref(chan);
+	ast_channel_ref(bridgedchan);
+
+	sip_pvt_unlock(pvt);
+	ast_channel_unlock(pvt->owner);
+	dialog_unref(pvt, "drop pvt");
+
+	/* Needed so that comebacktoorigin will work */
+	pbx_builtin_setvar_helper(bridgedchan, "BLINDTRANSFER", ast_channel_name(chan));
+	ast_channel_unref(chan);
+
+	res = ast_masq_park_call_exten(bridgedchan, NULL, "park", park_data->context, 0, &exten);
+	ast_channel_unref(bridgedchan);
+
+	if (res) {
+		goto park_cleanup;
+	}
+
+	/* Now that we know the parking extension we can query the event cache to get the timeout */
+	for (;;) {
+		if ((event = ast_event_get_cached(AST_EVENT_PARKED_CALL,
+						AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_PARKED,
+						AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, exten,
+						AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, park_data->context,
+						AST_EVENT_IE_END))) {
+			break;
+		}
+
+		usleep(1000); /* Wait for 1ms as the event processor may not have got round to handling the event yet */
+	}
+	timeout = ast_event_get_ie_uint(event, AST_EVENT_IE_TIMEOUT);
+
+	dialog_ref(park_data->pvt, "copying park_data->pvt into event_sub");
+	if (!(park_data->pvt->park_event_sub = ast_event_subscribe(AST_EVENT_PARKED_CALL, park_monitor_event_cb, "Park monitor event", park_data->pvt,
+								AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, exten,
+								AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, park_data->context,
+								AST_EVENT_IE_END))) {
+		ast_event_destroy(event);
+		dialog_unref(park_data->pvt, "event subscription failed");
+		res = -1;
+		goto park_cleanup;
+	}
+
+	transmit_response(park_data->pvt, "202 Accepted", &park_data->req);
+
+	ast_set_flag(&park_data->pvt->flags[0], SIP_OUTGOING);
+	ast_set_flag(&park_data->pvt->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+
+	park_data->pvt->subscribed = DIALOG_INFO_XML;
+	park_data->pvt->expiry = timeout / 1000;
+
+	/* Manually send the event to the call back */
+	park_monitor_event_cb(event, park_data->pvt);
+	ast_event_destroy(event);
+
+park_cleanup:
+	if (res) {
+		transmit_response(park_data->pvt, "503 Service Unavailable", &park_data->req);
+	}
+
+	if (res && (pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		copy_pvt_data(pvt, park_data->pvt);
+
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<statuslineupdatereq>\n");
+		ast_str_append(&content, 0, "<action>notify_display</action>\n");
+		ast_str_append(&content, 0, "<dialogid>\n");
+		ast_str_append(&content, 0, "<callid>%s</callid>\n", park_data->callid);
+		ast_str_append(&content, 0, "<localtag>%s</localtag>\n", park_data->theirtag);
+		ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", park_data->tag);
+		ast_str_append(&content, 0, "</dialogid>\n");
+		ast_str_append(&content, 0, "<statustext>\200G</statustext>\n");
+		ast_str_append(&content, 0, "<displaytimeout>10</displaytimeout>\n");
+		ast_str_append(&content, 0, "<linenumber>0</linenumber>\n");
+		ast_str_append(&content, 0, "<priority>1</priority>\n");
+		ast_str_append(&content, 0, "</statuslineupdatereq>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	}
+
+	dialog_unref(park_data->pvt, "drop park_data->pvt");
+	deinit_req(&park_data->req);
+	ast_string_field_free_memory(park_data);
+	ast_free(park_data);
+
+	return NULL;
+}
+
+/*! \brief Handle remotecc park monitor requests */
+static int handle_remotecc_parkmonitor(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	pthread_t threadid;
+	struct park_data *park_data;
+
+	if (!(park_data = ast_calloc_with_stringfields(1, struct park_data, 128))) {
+		return -1;
+	}
+
+	dialog_ref(pvt, "copying dialog pvt into park_data struct");
+	park_data->pvt = pvt;
+	copy_request(&park_data->req, req);
+
+	ast_string_field_set(park_data, context, peer->context);
+	ast_string_field_set(park_data, callid, remotecc_data->dialogid.callid);
+	ast_string_field_set(park_data, tag, remotecc_data->dialogid.remotetag);
+	ast_string_field_set(park_data, theirtag, remotecc_data->dialogid.localtag);
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, park_monitor_thread, park_data)) {
+		dialog_unref(park_data->pvt, "thread creation failed");
+		ast_string_field_free_memory(park_data);
+		ast_free(park_data);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int wait_for_recording(void *obj)
+{
+	struct sip_pvt *pvt = obj;
+
+	sip_pvt_lock(pvt);
+	if (ast_channel_state(pvt->owner) != AST_STATE_UP) {
+		sip_pvt_unlock(pvt);
+		return -1;
+	}
+
+	if (!ast_test_flag(&pvt->flags[2], SIP_PAGE3_CISCO_RECORDING)) {
+		sip_pvt_unlock(pvt);
+		return -1;
+	}
+
+	sip_pvt_unlock(pvt);
+	return 0;
+}
+
+static void *record_thread(void *obj)
+{
+	struct record_data *record_data = obj;
+	struct sip_pvt *pvt, *targetcall_pvt;
+	struct ast_channel *chan;
+	struct ast_format_cap *cap;
+	struct ast_party_connected_line connected;
+	char *peername, *uniqueid, *channame;
+	int cause;
+
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(record_data->callid, record_data->tag, record_data->theirtag))) {
+		ast_debug(1, "call leg does not exist\n");
+		goto record_cleanup;
+	}
+
+	if (!(chan = targetcall_pvt->owner)) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(targetcall_pvt);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		goto record_cleanup;
+	}
+
+	peername = ast_strdupa(targetcall_pvt->peername);
+	channame = ast_strdupa(ast_channel_name(chan));
+	uniqueid = ast_strdupa(ast_channel_uniqueid(chan));
+
+	sip_pvt_unlock(targetcall_pvt);
+	ast_channel_unlock(chan);
+
+	cap = ast_format_cap_alloc_nolock();
+	ast_format_cap_set(cap, ast_channel_readformat(chan));
+
+	if (!(chan = ast_request("SIP", cap, NULL, peername, &cause))) {
+		ast_debug(1, "unable to request channel\n");
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		goto record_cleanup;
+	}
+
+	ast_format_cap_destroy(cap);
+	pvt = ast_channel_tech_pvt(chan);
+
+	ast_string_field_set(pvt, join_callid, record_data->callid);
+	ast_string_field_set(pvt, join_tag, record_data->tag);
+	ast_string_field_set(pvt, join_theirtag, record_data->theirtag);
+
+	ast_set_flag(&pvt->flags[1], SIP_PAGE2_CALL_ONHOLD_INACTIVE);
+	ast_set_flag(&pvt->flags[2], record_data->outgoing ? SIP_PAGE3_RELAY_NEAREND : SIP_PAGE3_RELAY_FAREND);
+
+	/* We are abusing the onhold flags to set the inactive attribute in the SDP, bump the onhold counter
+	   because when recording starts the reinvite code will decrement onhold when those flags are cleared */
+	if (pvt->relatedpeer) {
+		ast_atomic_fetchadd_int(&pvt->relatedpeer->onhold, +1);
+	}
+
+	ast_party_connected_line_set_init(&connected, ast_channel_connected(chan));
+	connected.id.name.valid = 1;
+	connected.id.name.str = "Record";
+	ast_channel_set_connected_line(chan, &connected, NULL);
+
+	ast_channel_context_set(chan, pvt->context);
+	ast_channel_exten_set(chan, "record");
+	ast_channel_priority_set(chan, 1);
+
+	pbx_builtin_setvar_helper(chan, "RECORD_PEERNAME", peername);
+	pbx_builtin_setvar_helper(chan, "RECORD_UNIQUEID", uniqueid);
+	pbx_builtin_setvar_helper(chan, "RECORD_CHANNEL", channame);
+	pbx_builtin_setvar_helper(chan, "RECORD_DIRECTION", record_data->outgoing ? "out" : "in");
+
+	if (ast_call(chan, peername, 5000)) {
+		ast_debug(1, "unable to call\n");
+		ast_hangup(chan);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		goto record_cleanup;
+	}
+
+	if (ast_safe_sleep_conditional(chan, 5000, wait_for_recording, pvt)) {
+		ast_debug(1, "no answer\n");
+		ast_hangup(chan);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		goto record_cleanup;
+	}
+
+	sip_pvt_lock(targetcall_pvt);
+
+	if (record_data->outgoing) {
+		targetcall_pvt->recordoutpvt = dialog_ref(pvt, "copying pvt into recordoutpvt");
+	} else {
+		targetcall_pvt->recordinpvt = dialog_ref(pvt, "copying pvt into recordinpvt");
+	}
+
+	sip_pvt_unlock(targetcall_pvt);
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	if (!ast_check_hangup(chan)) {
+		ast_pbx_run(chan);
+	}
+
+record_cleanup:
+	ast_string_field_free_memory(record_data);
+	ast_free(record_data);
+
+	return NULL;
+}
+
+static void start_record_thread(const char *callid, const char *tag, const char *theirtag, int outgoing)
+{
+	pthread_t threadid;
+	struct record_data *record_data;
+
+	if (!(record_data = ast_calloc_with_stringfields(1, struct record_data, 128))) {
+		return;
+	}
+
+	ast_string_field_set(record_data, callid, callid);
+	ast_string_field_set(record_data, tag, tag);
+	ast_string_field_set(record_data, theirtag, theirtag);
+	record_data->outgoing = outgoing;
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, record_thread, record_data)) {
+		ast_string_field_free_memory(record_data);
+		ast_free(record_data);
+	}
+}
+
+/*! \brief Handle remotecc start recording requests */
+static int handle_remotecc_startrecording(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	transmit_response(pvt, "202 Accepted", req);
+	start_record_thread(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag, 1);
+
+	return 0;
+}
+
+/*! \brief Handle remotecc stop recording requests */
+static int handle_remotecc_stoprecording(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *targetcall_pvt;
+	struct ast_channel *chan;
+
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+		ast_debug(1, "dialogid call leg does not exist\n");
+		return -1;
+	}
+
+	sip_pvt_unlock(targetcall_pvt);
+	if (targetcall_pvt->owner) {
+		ast_channel_unlock(targetcall_pvt->owner);
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	if (targetcall_pvt->recordoutpvt) {
+		sip_pvt_lock(targetcall_pvt->recordoutpvt);
+		if ((chan = targetcall_pvt->recordoutpvt->owner)) {
+			ast_softhangup(chan, AST_SOFTHANGUP_EXPLICIT);
+		}
+		sip_pvt_unlock(targetcall_pvt->recordoutpvt);
+
+		sip_pvt_lock(targetcall_pvt);
+		targetcall_pvt->recordoutpvt = dialog_unref(targetcall_pvt->recordoutpvt, "drop recordoutpvt");
+		sip_pvt_unlock(targetcall_pvt);
+	}
+
+	if (targetcall_pvt->recordinpvt) {
+		sip_pvt_lock(targetcall_pvt->recordinpvt);
+		if ((chan = targetcall_pvt->recordinpvt->owner)) {
+			ast_softhangup(chan, AST_SOFTHANGUP_EXPLICIT);
+		}
+		sip_pvt_unlock(targetcall_pvt->recordinpvt);
+
+		sip_pvt_lock(targetcall_pvt);
+		targetcall_pvt->recordinpvt = dialog_unref(targetcall_pvt->recordinpvt, "drop recordinpvt");
+		sip_pvt_unlock(targetcall_pvt);
+	}
+
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	return 0;
+}
+
+static void parse_rtp_stats(struct sip_pvt *pvt, struct sip_request *req)
+{
+	char *rxstat, *txstat; 
+	int dur = 0, rxpkt = 0, rxoct = 0, txpkt = 0, txoct = 0, latepkt = 0, lostpkt = 0, avgjit = 0;
+
+	rxstat = ast_strdupa(sip_get_header(req, "RTP-RxStat"));
+	while (!ast_strlen_zero(rxstat)) {
+		char *tag, *value;
+
+		tag = strsep(&rxstat, "=");
+		if (!(value = strsep(&rxstat, ","))) {
+			break;
+		}
+
+		if (!strcasecmp(tag, "Dur")) {
+			dur = atoi(value);
+		} else if (!strcasecmp(tag, "Pkt")) {
+			rxpkt = atoi(value);
+		} else if (!strcasecmp(tag, "Oct")) {
+			rxoct = atoi(value);
+		} else if (!strcasecmp(tag, "LatePkt")) {
+			latepkt = atoi(value);
+		} else if (!strcasecmp(tag, "LostPkt")) {
+			lostpkt = atoi(value);
+		} else if (!strcasecmp(tag, "AvgJit")) {
+			avgjit = atoi(value);
+		}
+	}
+
+	txstat = ast_strdupa(sip_get_header(req, "RTP-TxStat"));
+	while (!ast_strlen_zero(txstat)) {
+		char *tag, *value;
+
+		tag = strsep(&txstat, "=");
+		if (!(value = strsep(&txstat, ","))) {
+			break;
+		}
+
+		if (!strcasecmp(tag, "Pkt")) {
+			txpkt = atoi(value);
+		} else if (!strcasecmp(tag, "Oct")) {
+			txoct = atoi(value);
+		}
+	}
+
+	ast_verb(3, "Call Quality Report for %s\n"
+		"  Duration        : %d\n"
+		"  Sent Packets    : %d\n"
+		"  Sent Bytes      : %d\n"
+		"  Received Packets: %d\n"
+		"  Received Bytes  : %d\n"
+		"  Late Packets    : %d\n"
+		"  Lost Packets    : %d\n"
+		"  Average Jitter  : %d\n",
+		pvt->peername, dur, txpkt, txoct, rxpkt, rxoct, latepkt, lostpkt, avgjit);
+}
+
+/*! \brief Handle remotecc quality reporting tool requests */
+static int handle_remotecc_qrt(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *targetcall_pvt;
+
+	/* The remotetag and localtag are swapped here because those are from the viewpoint of the phone */
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+		ast_debug(1, "dialogid call leg does not exist\n");
+		return -1;
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+	ast_set_flag(&targetcall_pvt->flags[2], SIP_PAGE3_RTP_STATS_ON_BYE);
+
+	sip_pvt_unlock(targetcall_pvt);
+	if (targetcall_pvt->owner) {
+		ast_channel_unlock(targetcall_pvt->owner);
+	}
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	return 0;
+}
+
+/*! \brief Handle remotecc malicious call requests */
+static int handle_remotecc_mcid(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *targetcall_pvt, *refer_pvt;
+	struct ast_channel *chan, *bridgedchan;
+	struct ast_str *content = ast_str_alloca(8192);
+
+	/* The remotetag and localtag are swapped here because those are from the viewpoint of the phone */
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+		ast_debug(1, "dialogid call leg does not exist\n");
+		return -1;
+	}
+
+	if (!(chan = targetcall_pvt->owner)) {
+		ast_debug(1, "no owner channel\n");
+		sip_pvt_unlock(targetcall_pvt);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+		return -1;
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	if ((bridgedchan = ast_bridged_channel(chan))) {
+		ast_queue_control(chan, AST_CONTROL_MCID);
+		ast_verb(3, "%s has a malicious call from '%s'\n", targetcall_pvt->peername, ast_channel_name(bridgedchan));
+	}
+
+	sip_pvt_unlock(targetcall_pvt);
+	ast_channel_unlock(targetcall_pvt->owner);
+	dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+	if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		return 0;
+	}
+	copy_pvt_data(refer_pvt, pvt);
+
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<statuslineupdatereq>\n");
+	ast_str_append(&content, 0, "<action>notify_display</action>\n");
+	ast_str_append(&content, 0, "<dialogid>\n");
+	ast_str_append(&content, 0, "<callid>%s</callid>\n", remotecc_data->dialogid.callid);
+	ast_str_append(&content, 0, "<localtag>%s</localtag>\n", remotecc_data->dialogid.localtag);
+	ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", remotecc_data->dialogid.remotetag);
+	ast_str_append(&content, 0, "</dialogid>\n");
+	ast_str_append(&content, 0, "<statustext>\200T</statustext>\n");
+	ast_str_append(&content, 0, "<displaytimeout>10</displaytimeout>\n");
+	ast_str_append(&content, 0, "<linenumber>0</linenumber>\n");
+	ast_str_append(&content, 0, "<priority>1</priority>\n");
+	ast_str_append(&content, 0, "</statuslineupdatereq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+	transmit_refer_with_content(refer_pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+	dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+	ast_str_reset(content);
+
+	if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		return 0;
+	}
+	copy_pvt_data(refer_pvt, pvt);
+
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<playtonereq>\n");
+	ast_str_append(&content, 0, "<dialogid>\n");
+	ast_str_append(&content, 0, "<callid>%s</callid>\n", remotecc_data->dialogid.callid);
+	ast_str_append(&content, 0, "<localtag>%s</localtag>\n", remotecc_data->dialogid.localtag);
+	ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", remotecc_data->dialogid.remotetag);
+	ast_str_append(&content, 0, "</dialogid>\n");
+	ast_str_append(&content, 0, "<tonetype>DtZipZip</tonetype>\n");
+	ast_str_append(&content, 0, "<direction>all</direction>\n");
+	ast_str_append(&content, 0, "</playtonereq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+	transmit_refer_with_content(refer_pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+	dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+	return 0;
+}
+
+static int remotecc_callback_notify(char *context, char *exten, struct ast_state_cb_info *info, void *data)
+{
+	struct sip_peer *peer = data;
+	struct sip_pvt *pvt;
+	struct ast_str *content = ast_str_alloca(8192);
+	int needpos = strstr(peer->useragent, "CP79") ? 1 : 0;
+	struct timeval tv;
+	struct ast_tm tm;
+	char date[32];
+
+	if (info->exten_state & (AST_EXTENSION_INUSE | AST_EXTENSION_BUSY) || info->presence_state == AST_PRESENCE_DND) {
+		peer->callback->busy = 1;
+		return 0;
+	} else if (info->exten_state != AST_EXTENSION_NOT_INUSE || info->presence_state != AST_PRESENCE_AVAILABLE || !peer->callback->busy) {
+		return 0;
+	}
+
+	tv = ast_tvnow();
+	ast_strftime(date, sizeof(date), "%H:%M %d/%m/%Y", ast_localtime(&tv, &tm, NULL));
+
+	if (!((pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL)))) {
+		return 0;
+	}
+
+	set_socket_transport(&pvt->socket, 0);
+	if (create_addr_from_peer(pvt, peer)) {
+		dialog_unref(pvt, "create_addr_from_peer failed");
+		return 0;
+	}
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<datapassthroughreq>\n");
+	ast_str_append(&content, 0, "<applicationid>0</applicationid>\n");
+	ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+	ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+	ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+	ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+	ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+	ast_str_append(&content, 0, "<confid>0</confid>\n");
+	ast_str_append(&content, 0, "</datapassthroughreq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "\r\n");
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<CiscoIPPhoneExecute>\n");
+	ast_str_append(&content, 0, "<ExecuteItem URL=\"Play:callback.raw\" />\n");
+	ast_str_append(&content, 0, "</CiscoIPPhoneExecute>\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+	transmit_refer_with_content(pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+	dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+
+	ast_str_reset(content);
+
+	if (!((pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL)))) {
+		return 0;
+	}
+
+	set_socket_transport(&pvt->socket, 0);
+	if (create_addr_from_peer(pvt, peer)) {
+		dialog_unref(pvt, "create_addr_from_peer failed");
+		return 0;
+	}
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<datapassthroughreq>\n");
+	ast_str_append(&content, 0, "<applicationid>%d</applicationid>\n", REMOTECC_CALLBACK);
+	ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+	ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+	ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+	ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+	ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+	ast_str_append(&content, 0, "<confid>0</confid>\n");
+	ast_str_append(&content, 0, "</datapassthroughreq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "\r\n");
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<CiscoIPPhoneText>\n");
+	ast_str_append(&content, 0, "<Title>CallBack</Title>\n");
+	ast_str_append(&content, 0, "<Text>%s is now available at %s.\n\nPress Dial to call.\nPress Cancel to deactivate.\nPress Exit to quit this screen.</Text>\n", peer->callback->exten, date);
+	ast_str_append(&content, 0, "<Prompt>Please select</Prompt>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Exit</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 3 : 1);
+	ast_str_append(&content, 0, "<URL>SoftKey:Exit</URL>\n");
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Cancel</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 2 : 2);
+	ast_str_append(&content, 0, "<URL>UserCallData:%d:0:0:0:Cancel</URL>\n", REMOTECC_CALLBACK);
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Dial</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 1 : 3);
+	ast_str_append(&content, 0, "<URL>UserCallData:%d:0:0:0:Dial</URL>\n", REMOTECC_CALLBACK);
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	ast_str_append(&content, 0, "</CiscoIPPhoneText>\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+	transmit_refer_with_content(pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+	dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+
+	return 0;
+}
+
+/*! \brief Handle remotecc callback requests */
+static int handle_remotecc_callback(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_pvt *refer_pvt;
+	struct ast_str *content = ast_str_alloca(8192);
+	int needpos = strstr(sip_get_header(req, "User-Agent"), "CP79") ? 1 : 0;
+
+	if (!ast_strlen_zero(remotecc_data->dialogid.callid)) {
+		struct sip_pvt *targetcall_pvt;
+		struct ast_channel *chan = NULL;
+		struct ast_party_id connected_id;
+		char *exten, *subtype, *message;
+		int exten_state, presence_state;
+		int res = -1;
+
+		/* The remotetag and localtag are swapped here because those are from the viewpoint of the phone */
+		if (!(targetcall_pvt = get_sip_pvt_byid_locked(remotecc_data->dialogid.callid, remotecc_data->dialogid.remotetag, remotecc_data->dialogid.localtag))) {
+			ast_debug(1, "dialogid call leg does not exist\n");
+			return -1;
+		}
+
+		if (!(chan = targetcall_pvt->owner)) {
+			ast_debug(1, "no owner channel\n");
+			sip_pvt_unlock(targetcall_pvt);
+			dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+			return -1;
+		}
+
+		ast_channel_ref(chan);
+		connected_id = ast_channel_connected_effective_id(chan);
+		exten = ast_strdupa(S_COR(connected_id.number.valid, connected_id.number.str, targetcall_pvt->exten));
+
+		sip_pvt_unlock(targetcall_pvt);
+		ast_channel_unlock(targetcall_pvt->owner);
+		dialog_unref(targetcall_pvt, "drop targetcall_pvt");
+
+		if (peer->callback) {
+			destroy_callback(peer);
+			peer->callback = NULL;
+		}
+
+		if (ast_strlen_zero(exten)) {
+			goto callback_cleanup;
+		}
+		if (!(peer->callback = ast_calloc(1, sizeof(*peer->callback)))) {
+			goto callback_cleanup;
+		}
+		if (!(peer->callback->exten = ast_strdup(exten))) {
+			ast_free(peer->callback);
+			peer->callback = NULL;
+			goto callback_cleanup;
+		}
+		sip_ref_peer(peer, "copying peer into callback struct");
+		if (!(peer->callback->stateid = ast_extension_state_add(peer->context, peer->callback->exten, remotecc_callback_notify, peer))) {
+			sip_unref_peer(peer, "copying peer into callback struct failed");
+			ast_free(peer->callback->exten);
+			ast_free(peer->callback);
+			goto callback_cleanup;
+		}
+
+		exten_state = ast_extension_state(NULL, peer->context, peer->callback->exten);
+		presence_state = ast_hint_presence_state(NULL, peer->context, peer->callback->exten, &subtype, &message);
+
+		ast_free(subtype);
+		ast_free(message);
+
+		if (exten_state & (AST_EXTENSION_INUSE | AST_EXTENSION_BUSY) || presence_state == AST_PRESENCE_DND) {
+			peer->callback->busy = 1;
+		}
+
+		ast_channel_hangupcause_set(chan, AST_CAUSE_FAILURE);
+		ast_softhangup(chan, AST_SOFTHANGUP_EXPLICIT);
+		res = 0;
+
+	callback_cleanup:
+		if (chan) {
+			ast_channel_unref(chan);
+		}
+
+		if (res) {
+			transmit_response(pvt, "202 Accepted", req);
+
+			if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+				return 0;
+			}
+			copy_pvt_data(refer_pvt, pvt);
+
+			ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+			ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+			ast_str_append(&content, 0, "\r\n");
+			ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "<datapassthroughreq>\n");
+			ast_str_append(&content, 0, "<applicationid>0</applicationid>\n");
+			ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+			ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+			ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+			ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+			ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+			ast_str_append(&content, 0, "<confid>0</confid>\n");
+			ast_str_append(&content, 0, "</datapassthroughreq>\n");
+			ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "\r\n");
+
+			ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+			ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+			ast_str_append(&content, 0, "\r\n");
+			ast_str_append(&content, 0, "<CiscoIPPhoneText>\n");
+			ast_str_append(&content, 0, "<Title>CallBack</Title>\n");
+			ast_str_append(&content, 0, "<Text>Unable to activate callback on %s</Text>\n", S_OR(exten, CALLERID_UNKNOWN));
+			ast_str_append(&content, 0, "<Prompt>Please select</Prompt>\n");
+			ast_str_append(&content, 0, "<SoftKeyItem>\n");
+			ast_str_append(&content, 0, "<Name>Exit</Name>\n");
+			ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 3 : 1);
+			ast_str_append(&content, 0, "<URL>SoftKey:Exit</URL>\n");
+			ast_str_append(&content, 0, "</SoftKeyItem>\n");
+			ast_str_append(&content, 0, "</CiscoIPPhoneText>\n");
+			ast_str_append(&content, 0, "\r\n");
+			ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+			transmit_refer_with_content(refer_pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+			dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+			return 0;
+		}
+	} else if (!ast_strlen_zero(remotecc_data->usercalldata) && peer->callback) {
+		transmit_response(pvt, "202 Accepted", req);
+
+		if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+			return 0;
+		}
+		copy_pvt_data(refer_pvt, pvt);
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<datapassthroughreq>\n");
+		ast_str_append(&content, 0, "<applicationid>0</applicationid>\n");
+		ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+		ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+		ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+		ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+		ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+		ast_str_append(&content, 0, "<confid>0</confid>\n");
+		ast_str_append(&content, 0, "</datapassthroughreq>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "\r\n");
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<CiscoIPPhoneExecute>\n");
+		ast_str_append(&content, 0, "<ExecuteItem URL=\"Init:Services\" />\n");
+		ast_str_append(&content, 0, "</CiscoIPPhoneExecute>\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+		transmit_refer_with_content(refer_pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+		dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+		if (!strcmp(remotecc_data->usercalldata, "Dial")) {
+			ast_str_reset(content);
+
+			if (!(refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+				return 0;
+			}
+			copy_pvt_data(refer_pvt, pvt);
+
+			ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "<initiatecallreq>\n");
+			ast_str_append(&content, 0, "<dialstring>%s</dialstring>\n", peer->callback->exten);
+			ast_str_append(&content, 0, "<linenumber>%d</linenumber>\n", peer->cisco_lineindex);
+			ast_str_append(&content, 0, "<globalcallid></globalcallid>\n");
+			ast_str_append(&content, 0, "</initiatecallreq>\n");
+			ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+
+			transmit_refer_with_content(refer_pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+			dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+			destroy_callback(peer);
+			peer->callback = NULL;
+		} else if (!strcmp(remotecc_data->usercalldata, "Cancel")) {
+			destroy_callback(peer);
+			peer->callback = NULL;
+		}
+
+		return 0;
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	if (!((refer_pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL)))) {
+		return 0;
+	}
+	copy_pvt_data(refer_pvt, pvt);
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "<datapassthroughreq>\n");
+	ast_str_append(&content, 0, "<applicationid>%d</applicationid>\n", REMOTECC_CALLBACK);
+	ast_str_append(&content, 0, "<transactionid>0</transactionid>\n");
+	ast_str_append(&content, 0, "<stationsequence>StationSequenceLast</stationsequence>\n");
+	ast_str_append(&content, 0, "<displaypriority>2</displaypriority>\n");
+	ast_str_append(&content, 0, "<appinstance>0</appinstance>\n");
+	ast_str_append(&content, 0, "<routingid>0</routingid>\n");
+	ast_str_append(&content, 0, "<confid>0</confid>\n");
+	ast_str_append(&content, 0, "</datapassthroughreq>\n");
+	ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+	ast_str_append(&content, 0, "\r\n");
+
+	ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+	ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-cm+xml\r\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "<CiscoIPPhoneText>\n");
+	ast_str_append(&content, 0, "<Title>CallBack</Title>\n");
+
+	if (peer->callback) {
+		ast_str_append(&content, 0, "<Text>CallBack is activated on %s.\n\nPress Cancel to deactivate.\nPress Exit to quit this screen.</Text>", peer->callback->exten);
+	} else {
+		ast_str_append(&content, 0, "<Text>CallBack is not activated.</Text>");
+	}
+
+	ast_str_append(&content, 0, "<Prompt>Please select</Prompt>\n");
+	ast_str_append(&content, 0, "<SoftKeyItem>\n");
+	ast_str_append(&content, 0, "<Name>Exit</Name>\n");
+	ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 3 : 1);
+	ast_str_append(&content, 0, "<URL>SoftKey:Exit</URL>\n");
+	ast_str_append(&content, 0, "</SoftKeyItem>\n");
+
+	if (peer->callback) {
+		ast_str_append(&content, 0, "<SoftKeyItem>\n");
+		ast_str_append(&content, 0, "<Name>Cancel</Name>\n");
+		ast_str_append(&content, 0, "<Position>%d</Position>\n", needpos ? 2 : 2);
+		ast_str_append(&content, 0, "<URL>UserCallData:%d:0:0:0:Cancel</URL>\n", REMOTECC_CALLBACK);
+		ast_str_append(&content, 0, "</SoftKeyItem>\n");
+	}
+
+	ast_str_append(&content, 0, "</CiscoIPPhoneText>\n");
+	ast_str_append(&content, 0, "\r\n");
+	ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+	transmit_refer_with_content(refer_pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+	dialog_unref(refer_pvt, "bump down the count of refer_pvt since we're done with it.");
+
+	return 0;
+}
+
+/*! \brief Handle remotecc select requests */
+static int handle_remotecc_select(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_selected *selected;
+	int found = 0;
+
+	ao2_lock(peer);
+	AST_LIST_TRAVERSE(&peer->selected, selected, entry) {
+		if (!strcmp(remotecc_data->dialogid.callid, selected->callid) && !strcmp(remotecc_data->dialogid.remotetag, selected->tag) && !strcmp(remotecc_data->dialogid.localtag, selected->theirtag)) {
+			found = 1;
+			break;
+		}
+	}
+	ao2_unlock(peer);
+
+	if (!found) {
+		if (!(selected = ast_calloc_with_stringfields(1, struct sip_selected, 128))) {
+			return -1;
+		}
+
+		ast_string_field_set(selected, callid, remotecc_data->dialogid.callid);
+		ast_string_field_set(selected, tag, remotecc_data->dialogid.remotetag);
+		ast_string_field_set(selected, theirtag, remotecc_data->dialogid.localtag);
+
+		ao2_lock(peer);
+		AST_LIST_INSERT_TAIL(&peer->selected, selected, entry);
+		ao2_unlock(peer);
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	return 0;
+}
+
+/*! \brief Handle remotecc requests */
+static int handle_remotecc_unselect(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	struct sip_selected *selected;
+
+	ao2_lock(peer);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&peer->selected, selected, entry) {
+		if (!strcmp(remotecc_data->dialogid.callid, selected->callid) && !strcmp(remotecc_data->dialogid.remotetag, selected->tag) && !strcmp(remotecc_data->dialogid.localtag, selected->theirtag)) {
+			AST_LIST_REMOVE_CURRENT(entry);
+			destroy_selected(selected);
+			break;
+		}
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	ao2_unlock(peer);
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	return 0;
+}
+
+/*! \brief join calls together into a conference */
+static void *join_thread(void *obj)
+{
+	struct join_data *join_data = obj;
+	struct sip_pvt *pvt;
+	struct ast_channel *chan, *bridgedchan;
+	struct sip_conference *conference = NULL;
+	struct ast_str *content = ast_str_alloca(SIPBUFSIZE * 10);
+	struct sip_selected *selected;
+	int res = -1;
+
+	if (!(pvt = get_sip_pvt_byid_locked(join_data->callid, join_data->tag, join_data->theirtag))) {
+		ast_debug(1, "call leg does not exist\n");
+		goto join_cleanup;
+	}
+
+	/* Is this a new ad-hoc conference? */
+	if (!pvt->conference) {
+		if (create_conference(pvt)) {
+			ast_debug(1, "unable to create conference\n");
+			sip_pvt_unlock(pvt);
+			if (pvt->owner) {
+				ast_channel_unlock(pvt->owner);
+			}
+			dialog_unref(pvt, "drop pvt");
+			goto join_cleanup;
+		}
+
+		/* Increase ref on conference so we don't need to keep a ref on it's parent dialog */
+		conference = pvt->conference;
+		ao2_ref(conference, +1);
+
+		if (!(chan = pvt->owner)) {
+			ast_debug(1, "no owner channel\n");
+			sip_pvt_unlock(pvt);
+			dialog_unref(pvt, "drop pvt");
+			goto join_cleanup;
+		}
+
+		if (!(bridgedchan = ast_bridged_channel(pvt->owner))) {
+			ast_debug(1, "no bridged channel\n");
+			sip_pvt_unlock(pvt);
+			ast_channel_unlock(pvt->owner);
+			dialog_unref(pvt, "drop pvt");
+			goto join_cleanup;
+		}
+
+		ast_channel_ref(chan);
+		ast_channel_ref(bridgedchan);
+
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop pvt");
+
+		if (join_conference(conference, chan, 1)) {
+			ast_channel_unref(chan);
+			ast_channel_unref(bridgedchan);
+			goto join_cleanup;
+		}
+
+		if (join_conference(conference, bridgedchan, 0)) {
+			ast_channel_unref(chan);
+			ast_channel_unref(bridgedchan);
+			goto join_cleanup;
+		}
+
+		ast_channel_unref(chan);
+		ast_channel_unref(bridgedchan);
+	} else {
+		conference = pvt->conference;
+		ao2_ref(conference, +1);
+
+		sip_pvt_unlock(pvt);
+		if (pvt->owner) {
+			ast_channel_unlock(pvt->owner);
+		}
+		dialog_unref(pvt, "drop pvt");
+	}
+
+	for (;;) {
+		ao2_lock(join_data->peer);
+		selected = AST_LIST_REMOVE_HEAD(&join_data->peer->selected, entry);
+		ao2_unlock(join_data->peer);
+	
+		if (!selected) {
+			break;
+		}
+
+		/* Skip the join dialog as that was added to the conference above */
+		if (!strcmp(join_data->callid, selected->callid) && !strcmp(join_data->tag, selected->tag) && !strcmp(join_data->theirtag, selected->theirtag)) {
+			destroy_selected(selected);
+			continue;
+		}
+
+		if (!(pvt = get_sip_pvt_byid_locked(selected->callid, selected->tag, selected->theirtag))) {
+			ast_debug(1, "call leg does not exist\n");
+			destroy_selected(selected);
+			continue;
+		}
+
+		if (!pvt->owner) {
+			ast_debug(1, "no owner channel\n");
+			sip_pvt_unlock(pvt);
+			dialog_unref(pvt, "drop pvt");
+			destroy_selected(selected);
+			goto join_cleanup;
+		}
+
+		if (!(bridgedchan = ast_bridged_channel(pvt->owner))) {
+			ast_debug(1, "no bridged channel\n");
+			sip_pvt_unlock(pvt);
+			ast_channel_unlock(pvt->owner);
+			dialog_unref(pvt, "drop pvt");
+			destroy_selected(selected);
+			goto join_cleanup;
+		}
+
+		ast_channel_ref(bridgedchan);
+
+		sip_pvt_unlock(pvt);
+		ast_channel_unlock(pvt->owner);
+		dialog_unref(pvt, "drop join pvt");
+
+		if (join_conference(conference, bridgedchan, 0)) {
+			ast_channel_unref(bridgedchan);
+			destroy_selected(selected);
+			goto join_cleanup;
+		}
+
+		ast_channel_unref(bridgedchan);
+		destroy_selected(selected);
+	}
+
+	res = 0;
+
+join_cleanup:
+	if (conference) {
+		ao2_ref(conference, -1);
+	}
+
+	if ((pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+		copy_pvt_data(pvt, join_data->pvt);
+
+		if (res) {
+			ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "<statuslineupdatereq>\n");
+			ast_str_append(&content, 0, "<action>notify_display</action>\n");
+			ast_str_append(&content, 0, "<dialogid>\n");
+			ast_str_append(&content, 0, "<callid>%s</callid>\n", join_data->callid);
+			ast_str_append(&content, 0, "<localtag>%s</localtag>\n", join_data->theirtag);
+			ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", join_data->tag);
+			ast_str_append(&content, 0, "</dialogid>\n");
+			ast_str_append(&content, 0, "<statustext>\200S</statustext>\n");
+			ast_str_append(&content, 0, "<displaytimeout>10</displaytimeout>\n");
+			ast_str_append(&content, 0, "<linenumber>0</linenumber>\n");
+			ast_str_append(&content, 0, "<priority>1</priority>\n");
+			ast_str_append(&content, 0, "</statuslineupdatereq>\n");
+			ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		} else {
+			ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "<notifyreq>\n");
+			ast_str_append(&content, 0, "<dialogid>\n");
+			ast_str_append(&content, 0, "<callid>%s</callid>\n", join_data->callid);
+			ast_str_append(&content, 0, "<localtag>%s</localtag>\n", join_data->theirtag);
+			ast_str_append(&content, 0, "<remotetag>%s</remotetag>\n", join_data->tag);
+			ast_str_append(&content, 0, "</dialogid>\n");
+			ast_str_append(&content, 0, "<feature>Join</feature>\n");
+			ast_str_append(&content, 0, "<status>Complete</status>\n");
+			ast_str_append(&content, 0, "</notifyreq>\n");
+			ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		}
+
+		transmit_refer_with_content(pvt, "application/x-cisco-remotecc-request+xml", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+	}
+
+	dialog_unref(join_data->pvt, "drop join_data->pvt");
+	sip_unref_peer(join_data->peer, "sip_unref_peer in join_thread");
+	ast_string_field_free_memory(join_data);
+	ast_free(join_data);
+
+	return NULL;
+}
+
+/*! \brief Handle remotecc join requests */
+static int handle_remotecc_join(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer, struct remotecc_data *remotecc_data)
+{
+	pthread_t threadid;
+	struct join_data *join_data;
+
+	if (!(join_data = ast_calloc_with_stringfields(1, struct join_data, 128))) {
+		return -1;
+	}
+
+	dialog_ref(pvt, "copying dialog pvt into join_data struct");
+	join_data->pvt = pvt;
+
+	sip_ref_peer(peer, "copying peer into join_data struct");
+	join_data->peer = peer;
+
+	ast_string_field_set(join_data, callid, remotecc_data->joindialogid.callid);
+	ast_string_field_set(join_data, tag, remotecc_data->joindialogid.remotetag);
+	ast_string_field_set(join_data, theirtag, remotecc_data->joindialogid.localtag);
+
+	if (ast_pthread_create_detached_background(&threadid, NULL, join_thread, join_data)) {
+		dialog_unref(join_data->pvt, "thread creation failed");
+		ast_string_field_free_memory(join_data);
+		ast_free(join_data);
+		return -1;
+	}
+
+	transmit_response(pvt, "202 Accepted", req);
+
+	return 0;
+}
+
+/*! \brief Handle incoming remotecc request */
+static int handle_refer_remotecc(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer)
+{
+#ifdef HAVE_LIBXML2
+	const char *content_type = sip_get_header(req, "Content-Type");
+	char *remotecc_body;
+	struct ast_xml_doc *remotecc_doc = NULL;
+	struct ast_xml_node *remotecc_request_node, *remotecc_request_children;
+	struct ast_xml_node *softkeyeventmsg_node, *softkeyeventmsg_children;
+	struct ast_xml_node *datapassthroughreq_node, *datapassthroughreq_children;
+	struct remotecc_data remotecc_data;
+	int start, end, done = 0;
+	char *boundary = NULL;
+
+	if (!strncasecmp(content_type, "multipart/mixed", 15)) {
+		if ((boundary = strcasestr(content_type, ";boundary="))) {
+			boundary += 10;
+		} else if ((boundary = strcasestr(content_type, "; boundary="))) {
+			boundary += 11;
+		} else {
+			return -1;
+		}
+		boundary = ast_strdupa(boundary);
+		boundary = strsep(&boundary, ";");
+
+		if ((start = find_boundary(req, boundary, 0, &done)) == -1) {
+			return -1;
+		}
+		start += 1;
+		if ((end = find_boundary(req, boundary, start, &done)) == -1) {
+			return -1;
+		}
+
+		content_type = NULL;
+		while (start < end) {
+			const char *line = REQ_OFFSET_TO_STR(req, line[start++]);
+
+			if (!strncasecmp(line, "Content-Type:", 13)) {
+				content_type = ast_skip_blanks(line + 13);
+			} else if (ast_strlen_zero(line)) {
+				break;
+			}
+		}
+
+		if (ast_strlen_zero(content_type)) {
+			return -1;
+		}
+	} else {
+		start = 0;
+		end = req->lines;
+	}
+
+	if (strcasecmp(content_type, "application/x-cisco-remotecc-request+xml")) {
+		ast_log(LOG_WARNING, "Content type is not x-cisco-remotecc-request+xml\n");
+		return -1;
+	}
+
+	if (!(remotecc_body = get_content(req, start, end - 1))) {
+		ast_log(LOG_WARNING, "Unable to get remotecc body\n");
+		return -1;
+	}
+
+	if (!(remotecc_doc = ast_xml_read_memory(remotecc_body, strlen(remotecc_body)))) {
+		ast_log(LOG_WARNING, "Unable to open XML remotecc document. Is it malformed?\n");
+		return -1;
+	}
+
+	if (!(remotecc_request_node = ast_xml_get_root(remotecc_doc))) {
+		ast_log(LOG_WARNING, "Unable to get root node\n");
+		ast_xml_close(remotecc_doc);
+		return -1;
+	}
+
+	if (strcasecmp(ast_xml_node_get_name(remotecc_request_node), "x-cisco-remotecc-request")) {
+		ast_log(LOG_WARNING, "Missing x-cisco-remotecc-request node\n");
+		ast_xml_close(remotecc_doc);
+		return -1;
+	}
+
+	if (!(remotecc_request_children = ast_xml_node_get_children(remotecc_request_node))) {
+		ast_log(LOG_WARNING, "No tuples in x-cisco-remotecc-request node\n");
+		ast_xml_close(remotecc_doc);
+		return -1;
+	}
+
+	memset(&remotecc_data, 0, sizeof(remotecc_data));
+
+	if ((softkeyeventmsg_node = ast_xml_find_element(remotecc_request_children, "softkeyeventmsg", NULL, NULL)) &&
+	    (softkeyeventmsg_children = ast_xml_node_get_children(softkeyeventmsg_node))) {
+		struct ast_xml_node *softkeyevent_node;
+		struct ast_xml_node *dialogid_node, *dialogid_children;
+		struct ast_xml_node *consultdialogid_node, *consultdialogid_children;
+		struct ast_xml_node *joindialogid_node, *joindialogid_children;
+		struct ast_xml_node *callid_node, *localtag_node, *remotetag_node;
+		const char *softkeyevent_text, *callid_text, *localtag_text, *remotetag_text;
+
+		if ((softkeyevent_node = ast_xml_find_element(softkeyeventmsg_children, "softkeyevent", NULL, NULL))) {
+			softkeyevent_text = ast_xml_get_text(softkeyevent_node);
+			remotecc_data.softkeyevent = ast_strdupa(softkeyevent_text);
+			ast_xml_free_text(softkeyevent_text);
+		}
+
+		if ((dialogid_node = ast_xml_find_element(softkeyeventmsg_children, "dialogid", NULL, NULL)) && 
+		    (dialogid_children = ast_xml_node_get_children(dialogid_node))) {
+			if ((callid_node = ast_xml_find_element(dialogid_children, "callid", NULL, NULL))) {
+				callid_text = ast_xml_get_text(callid_node);
+				remotecc_data.dialogid.callid = ast_strdupa(callid_text);
+				ast_xml_free_text(callid_text);
+			}
+
+			if ((localtag_node = ast_xml_find_element(dialogid_children, "localtag", NULL, NULL))) {
+				localtag_text = ast_xml_get_text(localtag_node);
+				remotecc_data.dialogid.localtag = ast_strdupa(localtag_text);
+				ast_xml_free_text(localtag_text);
+			}
+
+			if ((remotetag_node = ast_xml_find_element(dialogid_children, "remotetag", NULL, NULL))) {
+				remotetag_text = ast_xml_get_text(remotetag_node);
+				remotecc_data.dialogid.remotetag = ast_strdupa(remotetag_text);
+				ast_xml_free_text(remotetag_text);
+			}
+		}
+
+		if ((consultdialogid_node = ast_xml_find_element(softkeyeventmsg_children, "consultdialogid", NULL, NULL)) &&
+		    (consultdialogid_children = ast_xml_node_get_children(consultdialogid_node))) {
+			if ((callid_node = ast_xml_find_element(consultdialogid_children, "callid", NULL, NULL))) {
+				callid_text = ast_xml_get_text(callid_node);
+				remotecc_data.consultdialogid.callid = ast_strdupa(callid_text);
+				ast_xml_free_text(callid_text);
+			}
+
+			if ((localtag_node = ast_xml_find_element(consultdialogid_children, "localtag", NULL, NULL))) {
+				localtag_text = ast_xml_get_text(localtag_node);
+				remotecc_data.consultdialogid.localtag = ast_strdupa(localtag_text);
+				ast_xml_free_text(localtag_text);
+			}
+
+			if ((remotetag_node = ast_xml_find_element(consultdialogid_children, "remotetag", NULL, NULL))) {
+				remotetag_text = ast_xml_get_text(remotetag_node);
+				remotecc_data.consultdialogid.remotetag = ast_strdupa(remotetag_text);
+				ast_xml_free_text(remotetag_text);
+			}
+		}
+
+		if ((joindialogid_node = ast_xml_find_element(softkeyeventmsg_children, "joindialogid", NULL, NULL)) &&
+		    (joindialogid_children = ast_xml_node_get_children(joindialogid_node))) {
+			if ((callid_node = ast_xml_find_element(joindialogid_children, "callid", NULL, NULL))) {
+				callid_text = ast_xml_get_text(callid_node);
+				remotecc_data.joindialogid.callid = ast_strdupa(callid_text);
+				ast_xml_free_text(callid_text); 
+			}
+
+			if ((localtag_node = ast_xml_find_element(joindialogid_children, "localtag", NULL, NULL))) {
+				localtag_text = ast_xml_get_text(localtag_node);
+				remotecc_data.joindialogid.localtag = ast_strdupa(localtag_text);
+				ast_xml_free_text(localtag_text);
+			}
+
+			if ((remotetag_node = ast_xml_find_element(joindialogid_children, "remotetag", NULL, NULL))) {
+				remotetag_text = ast_xml_get_text(remotetag_node);
+				remotecc_data.joindialogid.remotetag = ast_strdupa(remotetag_text);
+				ast_xml_free_text(remotetag_text);
+			}
+		}
+	} else if ((datapassthroughreq_node = ast_xml_find_element(remotecc_request_children, "datapassthroughreq", NULL, NULL)) &&
+		   (datapassthroughreq_children = ast_xml_node_get_children(datapassthroughreq_node))) {
+		struct ast_xml_node *applicationid_node, *confid_node;
+		const char *applicationid_text, *confid_text;
+
+		if ((applicationid_node = ast_xml_find_element(datapassthroughreq_children, "applicationid", NULL, NULL))) {
+			applicationid_text = ast_xml_get_text(applicationid_node);
+			remotecc_data.applicationid = atoi(S_OR(applicationid_text, ""));
+			ast_xml_free_text(applicationid_text);
+		}
+
+		if ((confid_node = ast_xml_find_element(datapassthroughreq_children, "confid", NULL, NULL))) {
+			confid_text = ast_xml_get_text(confid_node);
+			remotecc_data.confid = atoi(S_OR(confid_text, ""));
+			ast_xml_free_text(confid_text);
+		}
+	}
+
+	ast_xml_close(remotecc_doc);
+
+	if (boundary && !done) {
+		start = end + 1;
+		if ((end = find_boundary(req, boundary, start, &done)) == -1) {
+			ast_log(LOG_WARNING, "Failed to find end boundary\n");
+			return -1;
+		}
+
+		content_type = NULL;
+		while (start < end) {
+			const char *line = REQ_OFFSET_TO_STR(req, line[start++]);
+
+			if (!strncasecmp(line, "Content-Type:", 13)) {
+				content_type = ast_skip_blanks(line + 13);
+			} else if (ast_strlen_zero(line)) {
+				break;
+			}
+		}
+
+		if (ast_strlen_zero(content_type)) {
+			return -1;
+		}
+		if (!strcasecmp(content_type, "application/x-cisco-remotecc-cm+xml")) {
+			char *usercalldata;
+
+			if (!(usercalldata = get_content(req, start, end - 1))) {
+				ast_log(LOG_WARNING, "Unable to get usercalldata body\n");
+				return -1;
+			}
+
+			remotecc_data.usercalldata = ast_trim_blanks(ast_strdupa(usercalldata));
+		}
+	}
+
+	if (!ast_strlen_zero(remotecc_data.softkeyevent)) {
+		if (!strcmp(remotecc_data.softkeyevent, "IDivert")) {
+			return handle_remotecc_idivert(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "HLog")) {
+			return handle_remotecc_hlog(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "Conference")) {
+			return handle_remotecc_conference(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "ConfList")) {
+			return handle_remotecc_conflist(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "ConfDetails")) {
+			return handle_remotecc_conflist(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "RmLastConf")) {
+			return handle_remotecc_rmlastconf(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "Cancel")) {
+			transmit_response(pvt, "202 Accepted", req);
+			return 0;
+		} else if (!strcmp(remotecc_data.softkeyevent, "Park")) {
+			return handle_remotecc_park(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "ParkMonitor")) {
+			return handle_remotecc_parkmonitor(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "StartRecording")) {
+			return handle_remotecc_startrecording(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "StopRecording")) {
+			return handle_remotecc_stoprecording(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "QRT")) {
+			return handle_remotecc_qrt(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "MCID")) {
+			return handle_remotecc_mcid(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "CallBack")) {
+			return handle_remotecc_callback(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "Select")) {
+			return handle_remotecc_select(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "Unselect")) {
+			return handle_remotecc_unselect(pvt, req, peer, &remotecc_data);
+		} else if (!strcmp(remotecc_data.softkeyevent, "Join")) {
+			return handle_remotecc_join(pvt, req, peer, &remotecc_data);
+		}
+
+		ast_log(LOG_WARNING, "Unsupported softkeyevent: %s\n", remotecc_data.softkeyevent);
+	} else if (remotecc_data.applicationid) {
+		if (remotecc_data.applicationid == REMOTECC_CONFLIST) {
+			return handle_remotecc_conflist(pvt, req, peer, &remotecc_data);
+		} else if (remotecc_data.applicationid == REMOTECC_CALLBACK) {
+			return handle_remotecc_callback(pvt, req, peer, &remotecc_data);
+		}
+
+		ast_log(LOG_WARNING, "Unsupported applicationid: %d\n", remotecc_data.applicationid);
+	} else {
+		ast_log(LOG_WARNING, "Unsupported x-cisco-remotecc-request+xml request\n");
+	}
+#endif
+	return -1;
+}
 
 /*! \brief Turn off generator data
 	XXX Does this function belong in the SIP channel?
@@ -24683,16 +27892,108 @@
 	return 0;
 }
 
+/*! \brief Handle dialog notifications */
+static int handle_notify_dialog(struct sip_pvt *pvt, struct sip_request *req, struct sip_peer *peer)
+{
+#ifdef HAVE_LIBXML2
+	const char *content_type = sip_get_header(req, "Content-Type");
+	char *dialog_body;
+	struct ast_xml_doc *dialog_doc = NULL;
+	struct ast_xml_node *dialog_info_node, *dialog_info_children;
+	struct ast_xml_node *dialog_node, *dialog_children;
+	struct ast_xml_node *state_node;
+	const char *state_text;
+	int offhook = 0;
+
+	if (strcasecmp(content_type, "application/dialog-info+xml")) {
+		ast_log(LOG_WARNING, "Content type is not application/dialog-info+xml\n");
+		return -1;
+	}
+
+	if (!(dialog_body = get_content(req, 0, req->lines - 1))) {
+		ast_log(LOG_WARNING, "Unable to get dialog body\n");
+		return -1;
+	}
+
+	if (!(dialog_doc = ast_xml_read_memory(dialog_body, strlen(dialog_body)))) {
+		ast_log(LOG_WARNING, "Unable to open XML dialog document. Is it malformed?\n");
+		return -1;
+	}
+
+	if (!(dialog_info_node = ast_xml_get_root(dialog_doc))) {
+		ast_log(LOG_WARNING, "Unable to get root node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	if (strcasecmp(ast_xml_node_get_name(dialog_info_node), "dialog-info")) {
+		ast_log(LOG_WARNING, "Missing dialog-info node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	if (!(dialog_info_children = ast_xml_node_get_children(dialog_info_node))) {
+		ast_log(LOG_WARNING, "No tuples in dialog-info node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	if (!(dialog_node = ast_xml_find_element(dialog_info_children, "dialog", NULL, NULL))) {
+		ast_log(LOG_WARNING, "Missing dialog node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	if (!(dialog_children = ast_xml_node_get_children(dialog_node))) {
+		ast_log(LOG_WARNING, "No tuples in dialog node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	if (!(state_node = ast_xml_find_element(dialog_children, "state", NULL, NULL))) {
+		ast_log(LOG_WARNING, "Missing state node\n");
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	state_text = ast_xml_get_text(state_node);
+
+	if (!strcasecmp(state_text, "trying")) {
+		offhook = 1;
+	} else if (!strcasecmp(state_text, "terminated")) {
+		offhook = -1;
+	} else {
+		ast_log(LOG_WARNING, "Invalid content in state node %s\n", state_text);
+		ast_xml_free_text(state_text);
+		ast_xml_close(dialog_doc);
+		return -1;
+	}
+
+	ast_xml_free_text(state_text);
+	ast_xml_close(dialog_doc);
+
+	if ((peer->offhook += offhook) < 0) {
+		peer->offhook = 0;
+	}
+	ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", peer->name);
+
+	transmit_response(pvt, "200 OK", req);
+	return 0;
+#else
+	return -1;
+#endif
+}
+
 /*! \brief Handle incoming notifications */
 static int handle_request_notify(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, uint32_t seqno, const char *e)
 {
 	/* This is mostly a skeleton for future improvements */
 	/* Mostly created to return proper answers on notifications on outbound REFER's */
 	int res = 0;
-	const char *event = sip_get_header(req, "Event");
+	char *event = ast_strdupa(sip_get_header(req, "Event"));
 	char *sep;
 
-	if( (sep = strchr(event, ';')) ) {	/* XXX bug here - overwriting string ? */
+	if ((sep = strchr(event, ';'))) {
 		*sep++ = '\0';
 	}
 
@@ -24707,6 +28008,7 @@
 		char *buf, *cmd, *code;
 		int respcode;
 		int success = TRUE;
+		const char *type = find_content_type(req);
 
 		/* EventID for each transfer... EventID is basically the REFER cseq
 
@@ -24715,7 +28017,13 @@
 		 Check if we have an owner of this event */
 
 		/* Check the content type */
-		if (strncasecmp(sip_get_header(req, "Content-Type"), "message/sipfrag", strlen("message/sipfrag"))) {
+		if (strncasecmp(type, "message/sipfrag", strlen("message/sipfrag"))) {
+			if (!strcasecmp(type, "application/x-cisco-remotecc-response+xml")) {
+				transmit_response(p, "200 OK", req);
+				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+				return 0;
+			}
+
 			/* We need a sipfrag */
 			transmit_response(p, "400 Bad request", req);
 			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
@@ -24723,7 +28031,7 @@
 		}
 
 		/* Get the text of the attachment */
-		if (ast_strlen_zero(buf = get_content(req))) {
+		if (ast_strlen_zero(buf = get_content(req, 0, req->lines - 1))) {
 			ast_log(LOG_WARNING, "Unable to retrieve attachment from NOTIFY %s\n", p->callid);
 			transmit_response(p, "400 Bad request", req);
 			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
@@ -24844,6 +28152,19 @@
 		transmit_response(p, "200 OK", req);
 	} else if (!strcmp(event, "call-completion")) {
 		res = handle_cc_notify(p, req);
+	} else if (!strcmp(event, "dialog")) {
+		struct sip_peer *peer = sip_find_peer(NULL, &p->recv, TRUE, FINDPEERS, FALSE, p->socket.type);
+
+		if (peer) {
+			if (handle_notify_dialog(p, req, peer)) {
+				transmit_response(p, "489 Bad event", req);
+				res = -1;
+			}
+			sip_unref_peer(peer, "removing unsolicited dialoginfo ref");
+		} else {
+			transmit_response(p, "489 Bad event", req);
+			res = -1;
+		}
 	} else {
 		/* We don't understand this event. */
 		transmit_response(p, "489 Bad event", req);
@@ -26388,7 +29709,7 @@
 	We can't destroy dialogs, since we want the call to continue.
 	
 	*/
-static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, uint32_t seqno, int *nounlock)
+static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, uint32_t seqno, const char *e, int *nounlock)
 {
 	/*!
 	 * Chan1: Call between asterisk and transferer
@@ -26406,6 +29727,40 @@
 	int res = 0;
 	struct ast_party_redirecting redirecting;
 	struct ast_set_party_redirecting update_redirecting;
+	const char *type = find_content_type(req);
+
+	if (!strcasecmp(type, "application/x-cisco-alarm+xml") || !strcasecmp(type, "application/x-cisco-remotecc-response+xml")) {
+		transmit_response(p, "202 Accepted", req);
+		if (!p->owner) {
+			sip_alreadygone(p);
+			pvt_set_needdestroy(p, "alarm/remotecc device notificaton");
+		}
+		return 0;
+	} else if (!strcasecmp(type, "application/x-cisco-remotecc-request+xml")) {
+		struct sip_peer *authpeer = NULL;
+
+		res = check_user_full(p, req, SIP_REFER, e, 0, addr, &authpeer);
+
+		/* if an authentication response was sent, we are done here */
+		if (res == AUTH_CHALLENGE_SENT) {
+			return 0;
+		}
+
+		if (res != AUTH_SUCCESSFUL) {
+			ast_log(LOG_NOTICE, "Failed to authenticate device %s for REFER\n", sip_get_header(req, "From"));
+			transmit_response_reliable(p, "403 Forbidden", req);
+		} else if (handle_refer_remotecc(p, req, authpeer)) {
+			transmit_response(p, "603 Declined (Remotecc failed)", req);
+			if (authpeer) {
+				sip_unref_peer(authpeer, "sip_unref_peer, from handle_request_refer");
+			}
+		}
+		if (!p->owner) {
+			sip_alreadygone(p);
+			pvt_set_needdestroy(p, "remotecc request");
+		}
+		return 0;
+	}
 
 	if (req->debug) {
 		ast_verbose("Call %s got a SIP call transfer from %s: (REFER)!\n",
@@ -26930,6 +30285,9 @@
 				ast_rtp_instance_set_stats_vars(p->owner, p->rtp);
 			}
 
+			if (ast_test_flag(&p->flags[2], SIP_PAGE3_RTP_STATS_ON_BYE)) {
+				parse_rtp_stats(p, req);
+			}
 		}
 
 		if (bridge) {
@@ -27385,7 +30743,7 @@
 		return FALSE;
 	}
 
-	if (!(pidf_body = get_content(req))) {
+	if (!(pidf_body = get_content(req, 0, req->lines - 1))) {
 		ast_log(LOG_WARNING, "Unable to get PIDF body\n");
 		return FALSE;
 	}
@@ -27505,6 +30863,100 @@
 	return res;
 }
 
+static int presence_esc_publish_handler(struct sip_pvt *pvt, struct sip_request *req, struct event_state_compositor *esc, struct sip_esc_entry *esc_entry)
+{
+	struct ast_xml_doc *pidf_doc = NULL;
+	struct ast_xml_node *presence_node;
+	struct ast_xml_node *presence_children;
+	struct ast_xml_node *person_node;
+	struct ast_xml_node *person_children;
+	struct ast_xml_node *activities_node;
+	struct ast_xml_node *activities_children;
+	struct ast_xml_node *dnd_node;
+	struct ast_xml_node *available_node;
+	struct sip_peer *peer;
+	struct sip_alias *alias;
+	int res = 0;
+	int donotdisturb = 0;
+
+	if (sip_pidf_validate(req, &pidf_doc) == FALSE) {
+		res = -1;
+	} else if (ast_test_flag(&pvt->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		presence_node = ast_xml_get_root(pidf_doc);
+		if (!(presence_children = ast_xml_node_get_children(presence_node))) {
+			ast_log(LOG_WARNING, "No tuples within presence element.\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (!(person_node = ast_xml_find_element(presence_children, "person", NULL, NULL))) {
+			ast_log(LOG_NOTICE, "Couldn't find person node?\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (!(person_children = ast_xml_node_get_children(person_node))) {
+			ast_log(LOG_NOTICE, "No tuples within person node.\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (!(activities_node = ast_xml_find_element(person_children, "activities", NULL, NULL))) {
+			ast_log(LOG_NOTICE, "Couldn't find activities node?\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (!(activities_children = ast_xml_node_get_children(activities_node))) {
+			ast_log(LOG_NOTICE, "No tuples within activities node.\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if ((dnd_node = ast_xml_find_element(activities_children, "dnd", NULL, NULL))) {
+			donotdisturb = 1;
+		} else if ((available_node = ast_xml_find_element(activities_children, "available", NULL, NULL))) {
+			donotdisturb = 0;
+		} else {
+			ast_log(LOG_NOTICE, "Couldn't find dnd or available node?\n");
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (!(peer = sip_find_peer(pvt->peername, NULL, TRUE, FINDALLDEVICES, FALSE, 0))) {
+			ast_log(LOG_NOTICE, "No such peer '%s'\n", pvt->peername);
+			res = -1;
+			goto presence_publish_cleanup;
+		}
+
+		if (peer->donotdisturb != donotdisturb) {
+			peer->donotdisturb = donotdisturb;
+			ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", peer->name);
+			AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+				if (alias->peer) {
+					alias->peer->donotdisturb = peer->donotdisturb;
+					ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", alias->peer->name);
+				}
+			}
+			if (!peer->is_realtime) {
+				ast_db_put("SIP/DoNotDisturb", peer->name, peer->donotdisturb ? "yes" : "no");
+			}
+		}
+
+		sip_unref_peer(peer, "presence_esc_publish_handler: from sip_find_peer call, setting DoNotDisturb/Available");
+	} else {
+		res = -1;
+	}
+
+presence_publish_cleanup:
+	if (pidf_doc) {
+		ast_xml_close(pidf_doc);
+	}
+	if (res) {
+		transmit_response(pvt, "400 Bad Request", req);
+	}
+	return res;
+}
 #endif /* HAVE_LIBXML2 */
 
 static int handle_sip_publish_initial(struct sip_pvt *p, struct sip_request *req, struct event_state_compositor *esc, const int expires)
@@ -27774,6 +31226,167 @@
 	return 0;
 }
 
+/*! \brief  Handle incoming feature event SUBSCRIBE body */
+static int handle_subscribe_featureevent(struct sip_peer *peer, struct sip_request *req)
+{
+#ifdef HAVE_LIBXML2
+	const char *content_type = sip_get_header(req, "Content-Type");
+	char *featureevent_body;
+	struct ast_xml_doc *featureevent_doc = NULL;
+	struct ast_xml_node *root_node;
+
+	if (!atoi(sip_get_header(req, "Content-Length"))) {
+		/* Peer is subscribing to the current DoNotDisturb and CallForward state */
+		return 0;
+	}
+
+	if (strcasecmp(content_type, "application/x-as-feature-event+xml")) {
+		ast_log(LOG_WARNING, "Content type is not x-as-feature-event+xml\n");
+		return -1;
+	}
+
+	if (!(featureevent_body = get_content(req, 0, req->lines - 1))) {
+		ast_log(LOG_WARNING, "Unable to get feature event body\n");
+		return -1;
+	}
+
+	if (!(featureevent_doc = ast_xml_read_memory(featureevent_body, strlen(featureevent_body)))) {
+		ast_log(LOG_WARNING, "Unable to open XML as-feature-event document. Is it malformed?\n");
+		return -1;
+	}
+
+	if (!(root_node = ast_xml_get_root(featureevent_doc))) {
+		ast_log(LOG_WARNING, "Unable to get root node\n");
+		ast_xml_close(featureevent_doc);
+		return -1;
+	}
+
+	if (!strcmp(ast_xml_node_get_name(root_node), "SetDoNotDisturb")) {
+		int donotdisturb;
+		struct ast_xml_node *set_donotdisturb_node, *set_donotdisturb_children;
+		struct ast_xml_node *donotdisturb_on_node;
+		const char *donotdisturb_on_text;
+
+		set_donotdisturb_node = root_node;
+
+		if (!(set_donotdisturb_children = ast_xml_node_get_children(set_donotdisturb_node))) {
+			ast_log(LOG_WARNING, "No tuples within SetDoNotDisturb node");
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		if (!(donotdisturb_on_node = ast_xml_find_element(set_donotdisturb_children, "doNotDisturbOn", NULL, NULL))) {
+			ast_log(LOG_WARNING, "Couldn't find doNotDisturbOn node");
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		donotdisturb_on_text = ast_xml_get_text(donotdisturb_on_node);
+
+		if (!strcmp(donotdisturb_on_text, "true")) {
+			donotdisturb = 1;
+		} else if (!strcmp(donotdisturb_on_text, "false")) {
+			donotdisturb = 0;
+		} else {
+			ast_log(LOG_WARNING, "Invalid content in doNotDisturbOn node %s\n", donotdisturb_on_text);
+			ast_xml_free_text(donotdisturb_on_text);
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		ast_xml_free_text(donotdisturb_on_text);
+
+		if (peer->donotdisturb != donotdisturb) {
+			peer->donotdisturb = donotdisturb;
+			ast_presence_state_changed(AST_PRESENCE_NOT_SET, NULL, NULL, "SIP/%s", peer->name);
+			if (!peer->is_realtime) {
+				ast_db_put("SIP/DoNotDisturb", peer->name, peer->donotdisturb ? "yes" : "no");
+			}
+		}
+	} else if (!strcmp(ast_xml_node_get_name(root_node), "SetForwarding")) {
+		char callforward[AST_MAX_EXTENSION];
+		struct ast_xml_node *set_forwarding_node, *set_forwarding_children;
+		struct ast_xml_node *forwarding_type_node, *activate_forward_node, *forward_dn_node;
+		const char *forwarding_type_text, *activate_forward_text, *forward_dn_text;
+
+		set_forwarding_node = root_node;
+
+		if (!(set_forwarding_children = ast_xml_node_get_children(set_forwarding_node))) {
+			ast_log(LOG_WARNING, "No tuples within SetForwarding node");
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		if (!(forwarding_type_node = ast_xml_find_element(set_forwarding_children, "forwardingType", NULL, NULL))) {
+			ast_log(LOG_WARNING, "Couldn't find forwardingType node\n");
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		forwarding_type_text = ast_xml_get_text(forwarding_type_node);
+
+		if (strcmp(forwarding_type_text, "forwardImmediate")) {
+			ast_log(LOG_WARNING, "forwardingType not supported: %s\n", forwarding_type_text);
+			ast_xml_free_text(forwarding_type_text);
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		ast_xml_free_text(forwarding_type_text);
+
+		if (!(activate_forward_node = ast_xml_find_element(set_forwarding_children, "activateForward", NULL, NULL))) {
+			ast_log(LOG_WARNING, "Couldn't find activateForward node");
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		activate_forward_text = ast_xml_get_text(activate_forward_node);
+
+		if (!strcmp(activate_forward_text, "true")) {
+			if (!(forward_dn_node = ast_xml_find_element(set_forwarding_children, "forwardDN", NULL, NULL))) {
+				ast_log(LOG_WARNING, "Couldn't find forwardDN node\n");
+				ast_xml_free_text(activate_forward_text);
+				ast_xml_close(featureevent_doc);
+				return -1;
+			}
+
+			forward_dn_text = ast_xml_get_text(forward_dn_node);
+			ast_copy_string(callforward, S_OR(forward_dn_text, ""), sizeof(callforward));
+			ast_xml_free_text(forward_dn_text);
+		} else if (!strcmp(activate_forward_text, "false")) {
+			callforward[0] = '\0';
+		} else {
+			ast_log(LOG_WARNING, "Invalid content in activateForward node: %s\n", activate_forward_text);
+			ast_xml_free_text(activate_forward_text);
+			ast_xml_close(featureevent_doc);
+			return -1;
+		}
+
+		ast_xml_free_text(activate_forward_text);
+
+		if (strcmp(peer->callforward, callforward)) {
+			ast_string_field_set(peer, callforward, callforward);
+			if (!peer->is_realtime) {
+				if (ast_strlen_zero(peer->callforward)) {
+					ast_db_del("SIP/CallForward", peer->name);
+				} else {
+					ast_db_put("SIP/CallForward", peer->name, peer->callforward);
+				}
+			}
+		}
+	} else {
+		ast_log(LOG_WARNING, "Couldn't find SetDoNotDisturb or SetForwarding node: %s\n", ast_xml_node_get_name(root_node));
+		ast_xml_close(featureevent_doc);
+		return -1;
+	}
+
+	ast_xml_close(featureevent_doc);
+	return 0;
+#else
+	return -1
+#endif
+}
+
 /*! \brief  Handle incoming SUBSCRIBE request */
 static int handle_request_subscribe(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, uint32_t seqno, const char *e)
 {
@@ -27917,14 +31530,20 @@
 					subscribed = XPIDF_XML; /* Older versions of Polycom firmware will claim pidf+xml, but really they only support xpidf+xml */
 				} else {
 					subscribed = PIDF_XML; /* RFC 3863 format */
+					if (strstr(p->useragent, "Digium")) {
+						ast_set_flag(&p->flags[2], SIP_PAGE3_WHY_DIDNT_DIGIUM_THINK_OF_THIS);
+					}
 				}
 			} else if (strstr(accept, "application/dialog-info+xml")) {
-				subscribed = DIALOG_INFO_XML;
-				/* IETF draft: draft-ietf-sipping-dialog-package-05.txt */
+				subscribed = DIALOG_INFO_XML; /* IETF draft: draft-ietf-sipping-dialog-package-05.txt */
 			} else if (strstr(accept, "application/cpim-pidf+xml")) {
-				subscribed = CPIM_PIDF_XML;    /* RFC 3863 format */
+				if (ast_test_flag(&p->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+					subscribed = PIDF_XML; /* RFC 3863 format with Cisco USECALLMANAGER additions */
+				} else {
+					subscribed = CPIM_PIDF_XML; /* RFC 3863 format */
+				}
 			} else if (strstr(accept, "application/xpidf+xml")) {
-				subscribed = XPIDF_XML;        /* Early pre-RFC 3863 format with MSN additions (Microsoft Messenger) */
+				subscribed = XPIDF_XML; /* Early pre-RFC 3863 format with MSN additions (Microsoft Messenger) */
 			} else {
 				unknown_accept = accept;
 			}
@@ -28044,6 +31663,33 @@
 			p->relatedpeer = sip_ref_peer(authpeer, "setting dialog's relatedpeer pointer");
 		}
 		/* Do not release authpeer here */
+	} else if (!strcmp(event, "as-feature-event")) {
+		if (!authpeer || handle_subscribe_featureevent(authpeer, req) == -1) {
+			transmit_response(p, "489 Bad Event", req);
+			pvt_set_needdestroy(p, "unknown format");
+			if (authpeer) {
+				sip_unref_peer(authpeer, "sip_unref_peer, from handle_request_subscribe (authpeer 4)");
+			}
+			return 0;
+		}
+
+		p->subscribed = FEATURE_EVENTS;
+		if (authpeer->fepvt != p) {	/* Destroy old PVT if this is a new one */
+			/* We only allow one subscription per peer */
+			if (authpeer->fepvt) {
+				dialog_unlink_all(authpeer->fepvt);
+				authpeer->fepvt = dialog_unref(authpeer->fepvt, "unref dialog authpeer->fepvt");
+			}
+			authpeer->fepvt = dialog_ref(p, "setting peers' fepvt to p");
+		}
+
+		if (p->relatedpeer != authpeer) {
+			if (p->relatedpeer) {
+				sip_unref_peer(p->relatedpeer, "Unref previously stored relatedpeer ptr");
+			}
+			p->relatedpeer = sip_ref_peer(authpeer, "setting dialog's relatedpeer pointer");
+		}
+		/* Do not release authpeer here */
 	} else if (!strcmp(event, "call-completion")) {
 		handle_cc_subscribe(p, req);
 	} else { /* At this point, Asterisk does not understand the specified event */
@@ -28082,6 +31728,9 @@
 			if (p->subscribed == MWI_NOTIFICATION && p->relatedpeer) {
 				ast_debug(2, "%s subscription for mailbox notification - peer %s\n",
 						action, p->relatedpeer->name);
+			} else if (p->subscribed == FEATURE_EVENTS) {
+				ast_debug(2, "%s feature event subscription for peer %s\n",
+						action, p->username);
 			} else if (p->subscribed == CALL_COMPLETION) {
 				ast_debug(2, "%s CC subscription for peer %s\n", action, p->username);
 			} else {
@@ -28101,10 +31750,19 @@
 				struct sip_peer *peer = p->relatedpeer;
 				sip_ref_peer(peer, "ensure a peer ref is held during MWI sending");
 				ao2_unlock(p);
-				sip_send_mwi_to_peer(peer, 0);
+				sip_send_mwi(peer, 0);
 				ao2_lock(p);
 				sip_unref_peer(peer, "release a peer ref now that MWI is sent");
 			}
+		} else if (p->subscribed == FEATURE_EVENTS) {
+			ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+			transmit_response(p, "200 OK", req);
+			if (p->relatedpeer && !atoi(sip_get_header(req, "Content-Length"))) {
+				struct sip_peer *peer = p->relatedpeer;
+				sip_ref_peer(peer, "ensure a peer ref is held during feature events sending");
+				sip_send_bulkupdate(peer);
+				sip_unref_peer(peer, "release a peer ref now that feature events is sent");
+			}
 		} else if (p->subscribed != CALL_COMPLETION) {
 			struct state_notify_data data = { 0, };
 			char *subtype = NULL;
@@ -28139,11 +31797,9 @@
 				}
 				return 0;
 			}
-			if (allow_notify_user_presence(p)) {
-				data.presence_state = ast_hint_presence_state(NULL, p->context, p->exten, &subtype, &message);
-				data.presence_subtype = subtype;
-				data.presence_message = message;
-			}
+			data.presence_state = ast_hint_presence_state(NULL, p->context, p->exten, &subtype, &message);
+			data.presence_subtype = subtype;
+			data.presence_message = message;
 			ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
 			transmit_response(p, "200 OK", req);
 			/* RFC 3265: A notification must be sent on every subscribe, so force it */
@@ -28161,8 +31817,10 @@
 				 * is due to a custom device state. These do not have associated channels.
 				 */
 			}
-			extensionstate_update(p->context, p->exten, &data, p, TRUE);
-			append_history(p, "Subscribestatus", "%s", ast_extension_state2str(data.state));
+			if (p->expiry > 0 || !resubscribe) {
+				extensionstate_update(p->context, p->exten, &data, p, TRUE);
+				append_history(p, "Subscribestatus", "%s", ast_extension_state2str(data.state));
+			}
 			/* hide the 'complete' exten/context in the refer_to field for later display */
 			ast_string_field_build(p, subscribeuri, "%s@%s", p->exten, p->context);
 			/* Deleted the slow iteration of all sip dialogs to find old subscribes from this peer for exten@context */
@@ -28490,7 +32148,7 @@
 
 		break;
 	case SIP_REFER:
-		res = handle_request_refer(p, req, seqno, nounlock);
+		res = handle_request_refer(p, req, addr, seqno, e, nounlock);
 		break;
 	case SIP_CANCEL:
 		res = handle_request_cancel(p, req);
@@ -28934,7 +32592,7 @@
  *  \note Both peer and associated sip_pvt must be unlocked prior to calling this function
  *  \returns -1 on failure, 0 on success
  */
-static int sip_send_mwi_to_peer(struct sip_peer *peer, int cache_only)
+static int sip_send_mwi(struct sip_peer *peer, int cache_only)
 {
 	/* Called with peer lock, but releases it */
 	struct sip_pvt *p;
@@ -28964,7 +32622,7 @@
 	if (!get_cached_mwi(peer, &newmsgs, &oldmsgs) && !cache_only) {
 		/* Fall back to manually checking the mailbox if not cache_only and get_cached_mwi failed */
 		struct ast_str *mailbox_str = ast_str_alloca(512);
-		peer_mailboxes_to_str(&mailbox_str, peer);
+		get_peer_mailboxes(&mailbox_str, peer);
 		/* if there is no mailbox do nothing */
 		if (!ast_str_strlen(mailbox_str)) {
 			ao2_unlock(peer);
@@ -28982,7 +32640,7 @@
 
 	if (peer->mwipvt) {
 		/* Base message on subscription */
-		p = dialog_ref(peer->mwipvt, "sip_send_mwi_to_peer: Setting dialog ptr p from peer->mwipvt");
+		p = dialog_ref(peer->mwipvt, "sip_send_mwi: Setting dialog ptr p from peer->mwipvt");
 		ao2_unlock(peer);
 	} else {
 		ao2_unlock(peer);
@@ -29032,7 +32690,7 @@
 	/* the following will decrement the refcount on p as it finishes */
 	transmit_notify_with_mwi(p, newmsgs, oldmsgs, vmexten);
 	sip_pvt_unlock(p);
-	dialog_unref(p, "unref dialog ptr p just before it goes out of scope at the end of sip_send_mwi_to_peer.");
+	dialog_unref(p, "unref dialog ptr p just before it goes out of scope at the end of sip_send_mwi.");
 
 	update_peer_lastmsgssent(peer, ((newmsgs > 0x7fff ? 0x7fff0000 : (newmsgs << 16)) | (oldmsgs > 0xffff ? 0xffff : oldmsgs)), 0);
 
@@ -29040,6 +32698,468 @@
 }
 
 /*!
+ * \brief Update bulk-register aliases 
+ */
+static void register_peer_aliases(struct sip_peer *peer, int force)
+{
+	struct sip_alias *alias;
+	char *scheme, *hostport;
+
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+                return;
+	}
+
+	scheme = ast_strdupa(peer->fullcontact);
+	if ((hostport = strchr(scheme, ':')) != NULL) {
+		*hostport++ = '\0';
+		if ((hostport = strchr(hostport, '@')) != NULL) {
+			*hostport++ = '\0';
+		}
+	}
+
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		struct ast_sockaddr oldaddr;
+
+		if (alias->peer) {
+			if (!force) {
+				continue;
+			}
+
+			sip_unref_peer(alias->peer, "unref after sip_find_peer");
+			alias->peer = NULL;
+		}
+
+		if (!(alias->peer = sip_find_peer(alias->name, NULL, TRUE, FINDPEERS, FALSE, 0))) {
+			ast_log(LOG_WARNING, "No such register peer '%s'\n", alias->name);
+			continue;
+		}
+
+		alias->peer->cisco_lineindex = alias->lineindex;
+		oldaddr = alias->peer->addr;
+
+		alias->peer->addr = peer->addr;
+		alias->peer->portinuri = peer->portinuri;
+		alias->peer->sipoptions = peer->sipoptions;
+		copy_socket_data(&alias->peer->socket, &peer->socket);
+
+		ast_string_field_build(alias->peer, fullcontact, "%s:%s@%s", scheme, alias->peer->name, hostport);
+		ast_string_field_set(alias->peer, username, alias->name);
+		ast_string_field_set(alias->peer, useragent, peer->useragent);
+		ast_string_field_set(alias->peer, regcallid, peer->regcallid);
+
+		alias->peer->donotdisturb = peer->donotdisturb;
+		alias->peer->huntgroup = peer->huntgroup;
+
+		manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Registered\r\nAddress: %s\r\n",
+			alias->peer->name, ast_sockaddr_stringify(&alias->peer->addr));
+		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", alias->peer->name);
+		register_peer_exten(alias->peer, 1);
+
+		if (ast_sockaddr_cmp(&alias->peer->addr, &oldaddr)) {
+			ast_verb(3, "Registered SIP '%s' at %s\n", alias->peer->name, ast_sockaddr_stringify(&alias->peer->addr));
+			alias->peer->offhook = 0;
+		}
+
+		update_peer_lastmsgssent(alias->peer, -1, 0);
+	}
+}
+
+/*!
+ * \brief Expire bulk-register aliases 
+ */
+static void expire_peer_aliases(struct sip_peer *peer)
+{
+	struct sip_alias *alias;
+
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		if (!alias->peer) {
+			continue;
+		}
+
+		ast_verb(3, "Unregistered SIP '%s'\n", alias->name);
+		alias->peer->lastms = -1;
+		memset(&alias->peer->addr, 0, sizeof(alias->peer->addr));
+
+		if (alias->peer->socket.tcptls_session) {
+			ao2_ref(alias->peer->socket.tcptls_session, -1);
+			alias->peer->socket.tcptls_session = NULL;
+		} else if (alias->peer->socket.ws_session) {
+			ast_websocket_unref(alias->peer->socket.ws_session);
+			alias->peer->socket.ws_session = NULL;
+		}
+
+		ast_string_field_set(alias->peer, fullcontact, "");
+		ast_string_field_set(alias->peer, username, "");
+		ast_string_field_set(alias->peer, useragent, "");
+
+		manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n",
+			alias->peer->name);
+		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", alias->peer->name);
+		register_peer_exten(alias->peer, 0);
+
+		sip_unref_peer(alias->peer, "unref after sip_find_peer");
+		alias->peer = NULL;
+	}
+}
+
+/*!
+ * \brief Register all bulk-register aliases
+ */
+static void register_all_aliases(void)
+{
+	struct ao2_iterator i;
+	struct sip_peer *peer;
+	struct sip_alias *alias;
+
+	if (!speerobjs) {
+		return;
+	}
+
+	i = ao2_iterator_init(peers, 0);
+	while ((peer = ao2_t_iterator_next(&i, "iterate thru peers table"))) {
+		ao2_lock(peer);
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			if (alias->peer) {
+				alias->peer->addr = peer->addr;
+			}
+		}
+		register_peer_aliases(peer, 0);
+		ao2_unlock(peer);
+		sip_unref_peer(peer, "toss iterator peer ptr");
+	}
+	ao2_iterator_destroy(&i);
+}
+
+/*!
+ * \brief Send initial subscription state updates to peer
+ */
+static void extensionstate_subscriptions(struct sip_peer *peer, int force)
+{
+	struct sip_subscription *subscription;
+
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+		return;
+	}
+
+	AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+		struct ao2_container *device_state_info = NULL;
+		struct state_notify_data notify_data = { 0, };
+		char *subtype = NULL, *message = NULL;
+		struct sip_request req;
+
+		if (subscription->pvt) {
+			if (force || subscription->pvt->stateid == -1) {
+				ast_debug(1, "Removing subscription %s@%s (%s)\n", subscription->exten, subscription->context, subscription->pvt->callid);
+
+				/* dialog_unlink_all calls ast_extension_state_del */
+				dialog_unlink_all(subscription->pvt);
+				dialog_unref(subscription->pvt, "destroying old subscription pvt");
+				subscription->pvt = NULL;
+			}
+		}
+
+		if (!subscription->pvt) {
+			if (!(subscription->pvt = sip_alloc(NULL, NULL, 0, SIP_NOTIFY, NULL, NULL))) {
+				return;
+			}
+
+			/* Don't use create_addr_from_peer here as it may fail due to the peer not having responded to an OPTIONS request yet */
+			subscription->pvt->sa = peer->addr;
+			subscription->pvt->recv = peer->addr;
+			copy_socket_data(&subscription->pvt->socket, &peer->socket);
+
+			if (!ast_strlen_zero(peer->tohost)) {
+				ast_string_field_set(subscription->pvt, tohost, peer->tohost);
+			} else {
+				ast_string_field_set(subscription->pvt, tohost, ast_sockaddr_stringify_host_remote(&peer->addr));
+			}
+			if (!subscription->pvt->portinuri) {
+				subscription->pvt->portinuri = peer->portinuri;
+			}
+			if (peer->fromdomainport) {
+				subscription->pvt->fromdomainport = peer->fromdomainport;
+			}
+
+			ast_string_field_set(subscription->pvt, fullcontact, peer->fullcontact);
+			ast_string_field_set(subscription->pvt, username, peer->username);
+			ast_string_field_set(subscription->pvt, fromuser, subscription->exten);
+			ast_string_field_set(subscription->pvt, fromname, "");
+
+			ast_string_field_set(subscription->pvt, context, subscription->context);
+			ast_string_field_set(subscription->pvt, exten, subscription->exten);
+			ast_string_field_build(subscription->pvt, subscribeuri, "%s@%s", subscription->exten, subscription->context);
+
+			ast_copy_flags(&subscription->pvt->flags[0], &peer->flags[0], SIP_FLAGS_TO_COPY);
+			ast_copy_flags(&subscription->pvt->flags[1], &peer->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
+			ast_copy_flags(&subscription->pvt->flags[2], &peer->flags[2], SIP_PAGE3_FLAGS_TO_COPY);
+
+			/* Recalculate our side, and recalculate Call ID */
+			ast_sip_ouraddrfor(&subscription->pvt->sa, &subscription->pvt->ourip, subscription->pvt);
+			change_callid_pvt(subscription->pvt, NULL);
+
+			/* Notify is outgoing call */
+			ast_set_flag(&subscription->pvt->flags[0], SIP_OUTGOING);
+			ast_set_flag(&subscription->pvt->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+			ast_set_flag(&subscription->pvt->flags[2], SIP_PAGE3_SUBSCRIPTIONSTATE_ACTIVE);
+
+			subscription->pvt->subscribed = PIDF_XML; /* XXX Needs to be configurable */
+			subscription->pvt->expiry = 0;
+
+			initreqprep(&req, subscription->pvt, SIP_NOTIFY, NULL);
+			if (!subscription->pvt->initreq.headers) {
+				initialize_initreq(subscription->pvt, &req);
+			}
+
+			dialog_ref(subscription->pvt, "copying dialog ptr into extension state struct");
+			subscription->pvt->stateid = ast_extension_state_add_destroy_extended(subscription->pvt->context, subscription->pvt->exten, cb_extensionstate, cb_extensionstate_destroy, subscription->pvt);
+
+			if (subscription->pvt->stateid == -1) {
+				dialog_unref(subscription->pvt, "copying dialog ptr into extension state struct failed");
+
+				dialog_unlink_all(subscription->pvt);
+				dialog_unref(subscription->pvt, "destroying old subscription pvt");
+				subscription->pvt = NULL;
+
+				continue;
+			}
+
+			ast_debug(1, "Adding subscription for %s@%s (%s)\n", subscription->exten, subscription->context, subscription->pvt->callid);
+		}
+
+		notify_data.state = ast_extension_state_extended(NULL, subscription->context, subscription->exten, &device_state_info);
+		if (notify_data.state < 0) {
+			ao2_cleanup(device_state_info);
+			continue;
+		}
+
+		notify_data.presence_state = ast_hint_presence_state(NULL, subscription->context, subscription->exten, &subtype, &message);
+		notify_data.presence_subtype = subtype;
+		notify_data.presence_message = message;
+		notify_data.device_state_info = device_state_info;
+
+		if (notify_data.state & AST_EXTENSION_RINGING) {
+			struct ast_channel *ringing = find_ringing_channel(notify_data.device_state_info, NULL);
+
+			if (ringing) {
+				subscription->pvt->last_ringing_channel_time = ast_channel_creationtime(ringing);
+				ao2_ref(ringing, -1);
+			}
+		}
+
+		extensionstate_update(subscription->context, subscription->exten, &notify_data, subscription->pvt, force);
+
+		ao2_cleanup(device_state_info);
+		ast_free(subtype);
+		ast_free(message);
+	}
+}
+
+/*!
+ * \brief Send donotdisturb, call forward and huntgroup in one bulk update
+ */
+static int sip_send_bulkupdate(struct sip_peer *peer)
+{
+	if (ast_sockaddr_isnull(&peer->addr) && ast_sockaddr_isnull(&peer->defaddr)) {
+		return 0;
+	}
+
+	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_CISCO_USECALLMANAGER)) {
+		struct sip_pvt *pvt;
+		struct ast_str *content;
+		int newmsgs = 0, oldmsgs = 0;
+		struct sip_alias *alias;
+
+		if (!(pvt = sip_alloc(NULL, NULL, 0, SIP_REFER, NULL, NULL))) {
+			return -1;
+		}
+
+		if (!(content = ast_str_create(8192))) {
+			dialog_unref(pvt, "drop pvt");
+			return -1;
+		}
+
+		/* Don't use create_addr_from_peer here as it may fail due to the peer not having responded to an OPTIONS request yet */
+		pvt->sa = peer->addr;
+		pvt->recv = peer->addr;
+		copy_socket_data(&pvt->socket, &peer->socket);
+		ast_copy_flags(&pvt->flags[0], &peer->flags[0], SIP_FLAGS_TO_COPY);
+		ast_copy_flags(&pvt->flags[1], &peer->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
+		ast_copy_flags(&pvt->flags[2], &peer->flags[2], SIP_PAGE3_FLAGS_TO_COPY);
+
+		/* Recalculate our side, and recalculate Call ID */
+		ast_sip_ouraddrfor(&pvt->sa, &pvt->ourip, pvt);
+		change_callid_pvt(pvt, NULL);
+
+		if (!ast_strlen_zero(peer->tohost)) {
+			ast_string_field_set(pvt, tohost, peer->tohost);
+		} else {
+			ast_string_field_set(pvt, tohost, ast_sockaddr_stringify_host_remote(&peer->addr));
+		}
+		if (!pvt->portinuri) {
+			pvt->portinuri = peer->portinuri;
+		}
+		if (peer->fromdomainport) {
+			pvt->fromdomainport = peer->fromdomainport;
+		}
+
+		ast_string_field_set(pvt, fullcontact, peer->fullcontact);
+		ast_string_field_set(pvt, username, peer->username);
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<dndupdate>\n");
+		ast_str_append(&content, 0, "<state>%s</state>\n", peer->donotdisturb ? "enable" : "disable");
+		ast_str_append(&content, 0, "<option>%s</option>\n", ast_test_flag(&peer->flags[2], SIP_PAGE3_DND_BUSY) ? "callreject" : "ringeroff");
+		ast_str_append(&content, 0, "</dndupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "\r\n");
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<cfwdallupdate>\n");
+		ast_str_append(&content, 0, "<linenumber>%d</linenumber>\n", peer->cisco_lineindex);
+		ast_str_append(&content, 0, "<fwdaddress>%s</fwdaddress>\n", peer->callforward);
+		ast_str_append(&content, 0, "<tovoicemail>%s</tovoicemail>\n", !strcmp(peer->callforward, peer->vmexten) ? "on" : "off");
+		ast_str_append(&content, 0, "</cfwdallupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "\r\n");
+
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			if (!alias->peer) {
+				continue;
+			}
+
+			ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+			ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+			ast_str_append(&content, 0, "\r\n");
+			ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "<cfwdallupdate>\n");
+			ast_str_append(&content, 0, "<linenumber>%d</linenumber>\n", alias->peer->cisco_lineindex);
+			ast_str_append(&content, 0, "<fwdaddress>%s</fwdaddress>\n", alias->peer->callforward);
+			ast_str_append(&content, 0, "<tovoicemail>%s</tovoicemail>\n", !strcmp(alias->peer->callforward, alias->peer->vmexten) ? "on" : "off");
+			ast_str_append(&content, 0, "</cfwdallupdate>\n");
+			ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+			ast_str_append(&content, 0, "\r\n");
+		}
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "<hlogupdate>\n");
+		ast_str_append(&content, 0, "<status>%s</status>\n", peer->huntgroup ? "on" : "off");
+		ast_str_append(&content, 0, "</hlogupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "\r\n");
+
+		ast_str_append(&content, 0, "--uniqueBoundary\r\n");
+		ast_str_append(&content, 0, "Content-Type: application/x-cisco-remotecc-request+xml\r\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "<x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 9, "<bulkupdate>\n");
+
+		if (!get_cached_mwi(peer, &newmsgs, &oldmsgs)) {
+			struct ast_str *mailbox = ast_str_alloca(512);
+
+			get_peer_mailboxes(&mailbox, peer);
+			if (ast_str_strlen(mailbox)) {
+				ast_app_inboxcount(ast_str_buffer(mailbox), &newmsgs, &oldmsgs);
+			} else {
+				update_peer_lastmsgssent(peer, -1, 0);
+			}
+		}
+
+		ast_str_append(&content, 0, "<contact line=\"%d\">\n", peer->cisco_lineindex);
+		ast_str_append(&content, 0, "<mwi>%s</mwi>\n", newmsgs ? "yes" : "no");
+		ast_str_append(&content, 0, "</contact>\n");
+
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			int newmsgs = 0, oldmsgs = 0;
+
+			if (!alias->peer) {
+				continue;
+			}
+
+			if (!get_cached_mwi(alias->peer, &newmsgs, &oldmsgs)) {
+				struct ast_str *mailbox = ast_str_alloca(512);
+
+				get_peer_mailboxes(&mailbox, alias->peer);
+				if (ast_str_strlen(mailbox)) {
+					ast_app_inboxcount(ast_str_buffer(mailbox), &newmsgs, &oldmsgs);
+				} else {
+					update_peer_lastmsgssent(peer, -1, 0);
+				}
+			}
+
+			ast_str_append(&content, 0, "<contact line=\"%d\">\n", alias->peer->cisco_lineindex);
+			ast_str_append(&content, 0, "<mwi>%s</mwi>\n", newmsgs ? "yes" : "no");
+			ast_str_append(&content, 0, "</contact>\n");
+		}
+
+		ast_str_append(&content, 0, "</bulkupdate>\n");
+		ast_str_append(&content, 0, "</x-cisco-remotecc-request>\n");
+		ast_str_append(&content, 0, "\r\n");
+		ast_str_append(&content, 0, "--uniqueBoundary--\r\n");
+
+		transmit_refer_with_content(pvt, "multipart/mixed; boundary=uniqueBoundary", ast_str_buffer(content));
+		dialog_unref(pvt, "bump down the count of pvt since we're done with it.");
+
+		ast_free(content);
+	} else if (peer->fepvt) {
+		struct sip_request req;
+		struct sip_pvt *pvt = peer->fepvt;
+		char tmp[512], boundary[32];
+
+		ast_set_flag(&pvt->flags[0], SIP_OUTGOING);
+		reqprep(&req, pvt, SIP_NOTIFY, 0, 1);
+
+		snprintf(boundary, sizeof(boundary), "%08lx%08lx%08lx", ast_random(), ast_random(), ast_random());
+
+		add_header(&req, "Event", "as-feature-event");
+		if (pvt->expiry) {
+			add_header(&req, "Subscription-State", "active");
+		} else {
+			add_header(&req, "Subscription-State", "terminated;reason=timeout");
+		}
+		snprintf(tmp, sizeof(tmp), "multipart/mixed; boundary=%s", boundary); 
+		add_header(&req, "Content-Type", tmp);
+
+		snprintf(tmp, sizeof(tmp), "--%s\r\n", boundary);
+		add_content(&req, tmp);
+		add_content(&req, "Content-Type: application/x-as-feature-event+xml\r\n");
+		add_content(&req, "\r\n");
+		add_content(&req, "<?xml version=\"1.0\"?>\n");
+		add_content(&req, "<DoNotDisturbEvent xmlns=\"http://www.ecma-international.org/standards/ecma-323/csta/ed3\">\n");
+		snprintf(tmp, sizeof(tmp), "<device><notKnown /></device>\n<doNotDisturbOn>%s</doNotDisturbOn>\n", peer->donotdisturb ? "true" : "false");
+		add_content(&req, tmp);
+		add_content(&req, "</DoNotDisturbEvent>\n");
+		add_content(&req, "\r\n");
+
+		snprintf(tmp, sizeof(tmp), "--%s\r\n", boundary);
+		add_content(&req, tmp);
+		add_content(&req, "Content-Type: application/x-as-feature-event+xml\r\n");
+		add_content(&req, "\r\n");
+		add_content(&req, "<?xml version=\"1.0\"?>\n");
+		add_content(&req, "<ForwardingEvent xmlns=\"http://www.ecma-international.org/standards/ecma-323/csta/ed3\">\n");
+		add_content(&req, "<device><notKnown /></device>\n<forwardingType>forwardImmediate</forwardingType>\n");
+		snprintf(tmp, sizeof(tmp), "<forwardStatus>%s</forwardStatus>\n<forwardTo>%s</forwardTo>\n", !ast_strlen_zero(peer->callforward) ? "true" : "false", peer->callforward);
+		add_content(&req, tmp);
+		add_content(&req, "</ForwardingEvent>\n");
+		add_content(&req, "\r\n");
+
+		snprintf(tmp, sizeof(tmp), "--%s--\r\n", boundary);
+		add_content(&req, tmp);
+		send_request(pvt, &req, XMIT_RELIABLE, pvt->ocseq);
+	}
+
+	return 0;
+}
+
+/*!
  * \brief helper function for the monitoring thread -- seems to be called with the assumption that the dialog is locked
  *
  * \return CMP_MATCH for items to be unlinked from dialogs_rtpcheck.
@@ -29674,6 +33794,25 @@
 			sip_unref_peer(peer, "removing poke peer ref"),
 			sip_ref_peer(peer, "adding poke peer ref"));
 
+	if (!AST_LIST_EMPTY(&peer->aliases)) {
+		struct sip_alias *alias;
+
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			if (!alias->peer || alias->peer->lastms == -1) {
+				continue;
+			}
+
+			ast_log(LOG_NOTICE, "Peer '%s' is now UNREACHABLE!  Last qualify: %d\n", alias->peer->name, alias->peer->lastms);
+			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Unreachable\r\nTime: %d\r\n", alias->peer->name, -1);
+
+			alias->peer->lastms = -1;
+			ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", alias->peer->name);
+			if (sip_cfg.regextenonqualify) {
+				register_peer_exten(peer, FALSE);
+			}
+		}
+	}
+
 	/* Release the ref held by the running scheduler entry */
 	sip_unref_peer(peer, "release peer poke noanswer ref");
 
@@ -29815,13 +33954,13 @@
 	char *host;
 	char *tmp;
 	struct sip_peer *p;
-
 	int res = AST_DEVICE_INVALID;
 
 	/* make sure data is not null. Maybe unnecessary, but better be safe */
 	host = ast_strdupa(data ? data : "");
-	if ((tmp = strchr(host, '@')))
+	if ((tmp = strchr(host, '@'))) {
 		host = tmp + 1;
+	}
 
 	ast_debug(3, "Checking device state for peer %s\n", host);
 
@@ -29859,7 +33998,7 @@
 			else if (p->call_limit && p->busy_level && p->inuse >= p->busy_level)
 				/* We're forcing busy before we've reached the call limit */
 				res = AST_DEVICE_BUSY;
-			else if (p->call_limit && p->inuse)
+			else if (p->call_limit && (p->inuse || p->offhook))
 				/* Not busy, but we do have a call */
 				res = AST_DEVICE_INUSE;
 			else if (p->maxms && ((p->lastms > p->maxms) || (p->lastms < 0)))
@@ -29877,6 +34016,35 @@
 	return res;
 }
 
+static int sip_presencestate(const char *data, char **subtype, char **message)
+{
+	char *host;
+	char *tmp;
+	struct sip_peer *p;
+	int res = AST_PRESENCE_INVALID;
+
+	/* make sure data is not null. Maybe unnecessary, but better be safe */
+	host = ast_strdupa(data ? data : "");
+	if ((tmp = strchr(host, '@'))) {
+		host = tmp + 1;
+	}
+
+	ast_debug(3, "Checking presence state for peer %s\n", host);
+
+	if ((p = sip_find_peer(host, NULL, FALSE, FINDALLDEVICES, TRUE, 0))) {
+		if (!(ast_sockaddr_isnull(&p->addr) && ast_sockaddr_isnull(&p->defaddr))) {
+			if (p->donotdisturb) {
+				res = AST_PRESENCE_DND;
+			} else {
+				res = AST_PRESENCE_AVAILABLE;
+			}
+		}
+		sip_unref_peer(p, "sip_unref_peer, from sip_presencestate, release ref from sip_find_peer");
+	}
+
+	return res;
+}
+
 /*! \brief PBX interface function -build SIP pvt structure
  *	SIP calls initiated by the PBX arrive here.
  *
@@ -30345,9 +34513,21 @@
 	} else if (!strcasecmp(v->name, "rfc2833compensate")) {
 		ast_set_flag(&mask[1], SIP_PAGE2_RFC2833_COMPENSATE);
 		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_RFC2833_COMPENSATE);
-	} else if (!strcasecmp(v->name, "buggymwi")) {
-		ast_set_flag(&mask[1], SIP_PAGE2_BUGGY_MWI);
-		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_BUGGY_MWI);
+	} else if (!strcasecmp(v->name, "dndbusy")) {
+		ast_set_flag(&mask[2], SIP_PAGE3_DND_BUSY);
+		ast_set2_flag(&flags[2], ast_true(v->value), SIP_PAGE3_DND_BUSY);
+	} else if (!strcasecmp(v->name, "huntgroup_default")) {
+		ast_set_flag(&mask[2], SIP_PAGE3_HUNTGROUP_DEFAULT);
+		ast_set2_flag(&flags[2], ast_true(v->value), SIP_PAGE3_HUNTGROUP_DEFAULT);
+	} else if (!strcasecmp(v->name, "cisco_usecallmanager")) {
+		ast_set_flag(&mask[1], SIP_PAGE2_CISCO_USECALLMANAGER);
+		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_CISCO_USECALLMANAGER);
+	} else if (!strcasecmp(v->name, "cisco_keep_conference")) {
+		ast_set_flag(&mask[2], SIP_PAGE3_CISCO_KEEP_CONFERENCE);
+		ast_set2_flag(&flags[2], ast_true(v->value), SIP_PAGE3_CISCO_KEEP_CONFERENCE);
+	} else if (!strcasecmp(v->name, "cisco_multiadmin_conference")) {
+		ast_set_flag(&mask[2], SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE);
+		ast_set2_flag(&flags[2], ast_true(v->value), SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE);
 	} else
 		res = 0;
 
@@ -30619,6 +34799,7 @@
 		ao2_ref(peer->outboundproxy, -1);
 		peer->outboundproxy = NULL;
 	}
+	peer->cisco_lineindex = 1;
 }
 
 /*! \brief Create temporary peer (used in autocreatepeer mode) */
@@ -30700,6 +34881,66 @@
 	}
 }
 
+static void add_peer_alias(struct sip_peer *peer, const char *value, int lineindex)
+{
+	struct sip_alias *alias;
+
+	AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+		if (!strcmp(alias->name, value)) {
+			break;
+		}
+	}
+
+	if (alias) {
+		alias->delme = 0;
+	} else {
+		if (!(alias = ast_calloc(1, sizeof(*alias)))) {
+			return;
+		}
+
+		if (!(alias->name = ast_strdup(value))) {
+			ast_free(alias);
+			return;
+		}
+
+		AST_LIST_INSERT_TAIL(&peer->aliases, alias, entry);
+	}
+
+	alias->lineindex = lineindex;
+}
+
+static void add_peer_subscription(struct sip_peer *peer, const char *value)
+{
+	char *exten, *context;
+	struct sip_subscription *subscription;
+
+	exten = ast_strdupa(value);
+	if ((context = strchr(exten, '@'))) {
+		*context++ = '\0';
+	} else {
+		context = ast_strdupa(S_OR(peer->subscribecontext, peer->context));
+	}
+
+	AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+		if (!strcmp(subscription->exten, exten) && !strcmp(subscription->context, context)) {
+			break;
+		}
+	}
+
+	if (subscription) {
+		subscription->delme = 0;
+	} else {
+		if (!(subscription = ast_calloc_with_stringfields(1, struct sip_subscription, 32))) {
+			return;
+		}
+
+		ast_string_field_set(subscription, exten, exten);
+		ast_string_field_set(subscription, context, context);
+
+		AST_LIST_INSERT_TAIL(&peer->subscriptions, subscription, entry);
+	}
+}
+
 /*! \brief Build peer from configuration (file or realtime static/dynamic) */
 static struct sip_peer *build_peer(const char *name, struct ast_variable *v, struct ast_variable *alt, int realtime, int devstate_only)
 {
@@ -30720,6 +34961,7 @@
 	int alt_fullcontact = alt ? 1 : 0, headercount = 0;
 	struct ast_str *fullcontact = ast_str_alloca(512);
 	int acl_change_subscription_needed = 0;
+	int lineindex = 2;
 
 	if (!realtime || ast_test_flag(&global_flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
 		/* Note we do NOT use sip_find_peer here, to avoid realtime recursion */
@@ -30803,9 +35045,18 @@
 
 	if (!devstate_only) {
 		struct sip_mailbox *mailbox;
+		struct sip_alias *alias;
+		struct sip_subscription *subscription;
+
 		AST_LIST_TRAVERSE(&peer->mailboxes, mailbox, entry) {
 			mailbox->delme = 1;
 		}
+		AST_LIST_TRAVERSE(&peer->aliases, alias, entry) {
+			alias->delme = 1;
+		}
+		AST_LIST_TRAVERSE(&peer->subscriptions, subscription, entry) {
+			subscription->delme = 1;
+		}
 	}
 
 	/* clear named callgroup and named pickup group container */
@@ -31007,7 +35258,7 @@
 			} else if (!strcasecmp(v->name, "regexten")) {
 				ast_string_field_set(peer, regexten, v->value);
 			} else if (!strcasecmp(v->name, "callbackextension")) {
-				ast_string_field_set(peer, callback, v->value);
+				ast_string_field_set(peer, callbackexten, v->value);
 			} else if (!strcasecmp(v->name, "amaflags")) {
 				format = ast_cdr_amaflags2int(v->value);
 				if (format < 0) {
@@ -31043,6 +35294,10 @@
 				ast_set2_flag(&peer->flags[1], ast_true(v->value), SIP_PAGE2_SUBSCRIBEMWIONLY);
 			} else if (!strcasecmp(v->name, "vmexten")) {
 				ast_string_field_set(peer, vmexten, v->value);
+			} else if (!strcasecmp(v->name, "register")) {
+				add_peer_alias(peer, v->value, lineindex++);
+			} else if (!strcasecmp(v->name, "subscribe")) {
+				add_peer_subscription(peer, v->value);
 			} else if (!strcasecmp(v->name, "callgroup")) {
 				peer->callgroup = ast_get_group(v->value);
 			} else if (!strcasecmp(v->name, "allowtransfer")) {
@@ -31236,6 +35491,9 @@
 
 	if (!devstate_only) {
 		struct sip_mailbox *mailbox;
+		struct sip_alias *alias;
+		struct sip_subscription *subscription;
+
 		AST_LIST_TRAVERSE_SAFE_BEGIN(&peer->mailboxes, mailbox, entry) {
 			if (mailbox->delme) {
 				AST_LIST_REMOVE_CURRENT(entry);
@@ -31243,6 +35501,20 @@
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&peer->aliases, alias, entry) {
+			if (alias->delme) {
+				AST_LIST_REMOVE_CURRENT(entry);
+				destroy_alias(alias);
+			}
+		}
+		AST_LIST_TRAVERSE_SAFE_END;
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&peer->subscriptions, subscription, entry) {
+			if (subscription->delme) {
+				AST_LIST_REMOVE_CURRENT(entry);
+				destroy_subscription(subscription);
+			}
+		}
+		AST_LIST_TRAVERSE_SAFE_END;
 	}
 
 	if (!can_parse_xml && (ast_get_cc_agent_policy(peer->cc_params) == AST_CC_AGENT_NATIVE)) {
@@ -31403,6 +35675,22 @@
 		reg_source_db(peer);
 	}
 
+	if (!peer->is_realtime) {
+		char data[128];
+
+		if (!ast_db_get("SIP/DoNotDisturb", peer->name, data, sizeof(data))) {
+			peer->donotdisturb = ast_true(data);
+		}
+		if (!ast_db_get("SIP/CallForward", peer->name, data, sizeof(data))) {
+			ast_string_field_set(peer, callforward, data);
+		}
+		if (!ast_db_get("SIP/HuntGroup", peer->name, data, sizeof(data))) {
+			peer->huntgroup = ast_true(data);
+		} else {
+			peer->huntgroup = ast_test_flag(&peer->flags[2], SIP_PAGE3_HUNTGROUP_DEFAULT) ? 1 : 0;
+		}
+	}
+
 	/* If they didn't request that MWI is sent *only* on subscribe, go ahead and
 	 * subscribe to it now. */
 	if (!devstate_only && !ast_test_flag(&peer->flags[1], SIP_PAGE2_SUBSCRIBEMWIONLY) &&
@@ -31411,16 +35699,20 @@
 		/* Send MWI from the event cache only.  This is so we can send initial
 		 * MWI if app_voicemail got loaded before chan_sip.  If it is the other
 		 * way, then we will get events when app_voicemail gets loaded. */
-		sip_send_mwi_to_peer(peer, 1);
+		sip_send_mwi(peer, 1);
+	}
+
+	if (!devstate_only && !AST_LIST_EMPTY(&peer->subscriptions)) {
+		extensionstate_subscriptions(peer, 0);
 	}
 
 	peer->the_mark = 0;
 
 	oldacl = ast_free_acl_list(oldacl);
 	olddirectmediaacl = ast_free_acl_list(olddirectmediaacl);
-	if (!ast_strlen_zero(peer->callback)) { /* build string from peer info */
+	if (!ast_strlen_zero(peer->callbackexten)) { /* build string from peer info */
 		char *reg_string;
-		if (ast_asprintf(&reg_string, "%s?%s:%s@%s/%s", peer->name, peer->username, !ast_strlen_zero(peer->remotesecret) ? peer->remotesecret : peer->secret, peer->tohost, peer->callback) >= 0) {
+		if (ast_asprintf(&reg_string, "%s?%s:%s@%s/%s", peer->name, peer->username, !ast_strlen_zero(peer->remotesecret) ? peer->remotesecret : peer->secret, peer->tohost, peer->callbackexten) >= 0) {
 			sip_register(reg_string, 0); /* XXX TODO: count in registry_count */
 			ast_free(reg_string);
 		}
@@ -32319,6 +36611,16 @@
 				ast_log(LOG_WARNING, "'%s' is not a valid websocket_write_timeout value at line %d. Using default '%d'.\n", v->value, v->lineno, AST_DEFAULT_WEBSOCKET_WRITE_TIMEOUT);
 				sip_cfg.websocket_write_timeout = AST_DEFAULT_WEBSOCKET_WRITE_TIMEOUT;
 			}
+		} else if (!strcasecmp(v->name, "dndbusy")) {
+			ast_set2_flag(&global_flags[2], ast_true(v->value), SIP_PAGE3_DND_BUSY);
+		} else if (!strcasecmp(v->name, "huntgroup_default")) {
+			ast_set2_flag(&global_flags[2], ast_true(v->value), SIP_PAGE3_HUNTGROUP_DEFAULT);
+		} else if (!strcasecmp(v->name, "cisco_usecallmanager")) {
+			ast_set2_flag(&global_flags[1], ast_true(v->value), SIP_PAGE2_CISCO_USECALLMANAGER);
+		} else if (!strcasecmp(v->name, "cisco_keep_conference")) {
+			ast_set2_flag(&global_flags[2], ast_true(v->value), SIP_PAGE3_CISCO_KEEP_CONFERENCE);
+		} else if (!strcasecmp(v->name, "cisco_multiadmin_conference")) {
+			ast_set2_flag(&global_flags[2], ast_true(v->value), SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE);
 		}
 	}
 
@@ -33302,6 +37604,10 @@
 
 	i = ao2_iterator_init(peers, 0);
 	while ((peer = ao2_t_iterator_next(&i, "iterate thru peers table"))) {
+		/* Only poke the primary line */
+		if (peer->cisco_lineindex > 1) {
+			continue;
+		}
 		ao2_lock(peer);
 		/* Don't schedule poking on a peer without qualify */
 		if (peer->maxms) {
@@ -33456,6 +37762,9 @@
 
 	ast_debug(4, "--------------- Done destroying pruned peers\n");
 
+	/* Register aliases now that all peers have been added */
+	register_all_aliases();
+
 	/* Send qualify (OPTIONS) to all peers */
 	sip_poke_all_peers();
 
@@ -33634,9 +37943,9 @@
 static int peer_ipcmp_cb_full(void *obj, void *arg, void *data, int flags)
 {
 	struct sip_peer *peer = obj, *peer2 = arg;
-	char *callback = data;
+	char *callbackexten = data;
 
-	if (!ast_strlen_zero(callback) && strcasecmp(peer->callback, callback)) {
+	if (!ast_strlen_zero(callbackexten) && strcasecmp(peer->callbackexten, callbackexten)) {
 		/* We require a callback extension match, but don't have one */
 		return 0;
 	}
@@ -33726,6 +38035,9 @@
 	AST_CLI_DEFINE(sip_show_settings, "Show SIP global settings"),
 	AST_CLI_DEFINE(sip_show_mwi, "Show MWI subscriptions"),
 	AST_CLI_DEFINE(sip_cli_notify, "Send a notify packet to a SIP peer"),
+	AST_CLI_DEFINE(sip_cli_donotdisturb, "Enables/Disables do not disturb on a SIP peer"),
+	AST_CLI_DEFINE(sip_cli_callforward, "Sets/Removes the call forwarding extension for a SIP peer"),
+	AST_CLI_DEFINE(sip_cli_huntgroup, "Login to/Logout from Hunt Group for a SIP peer"),
 	AST_CLI_DEFINE(sip_show_channel, "Show detailed SIP channel info"),
 	AST_CLI_DEFINE(sip_show_history, "Show SIP dialog history"),
 	AST_CLI_DEFINE(sip_show_peer, "Show details on specific SIP peer"),
@@ -34540,6 +38852,9 @@
 	MEMBER(sip_peer, ringing, AST_DATA_INTEGER)		\
 	MEMBER(sip_peer, onhold, AST_DATA_INTEGER)		\
 	MEMBER(sip_peer, call_limit, AST_DATA_INTEGER)		\
+	MEMBER(sip_peer, donotdisturb, AST_DATA_INTEGER)        \
+	MEMBER(sip_peer, huntgroup, AST_DATA_INTEGER)		\
+	MEMBER(sip_peer, callforward, AST_DATA_STRING)          \
 	MEMBER(sip_peer, t38_maxdatagram, AST_DATA_INTEGER)	\
 	MEMBER(sip_peer, maxcallbitrate, AST_DATA_INTEGER)	\
 	MEMBER(sip_peer, rtptimeout, AST_DATA_SECONDS)		\
diff -durN asterisk-11.17.1.orig/channels/sip/config_parser.c asterisk-11.17.1/channels/sip/config_parser.c
--- asterisk-11.17.1.orig/channels/sip/config_parser.c	2015-05-01 14:15:02.424636985 +1200
+++ asterisk-11.17.1/channels/sip/config_parser.c	2015-05-01 14:15:13.944387216 +1200
@@ -252,7 +252,7 @@
 	}
 
 	/* copy into sip_registry object */
-	ast_string_field_set(reg, callback, ast_strip_quoted(S_OR(host2.extension, "s"), "\"", "\""));
+	ast_string_field_set(reg, exten, ast_strip_quoted(S_OR(host2.extension, "s"), "\"", "\""));
 	ast_string_field_set(reg, username, ast_strip_quoted(S_OR(user2.user, ""), "\"", "\""));
 	ast_string_field_set(reg, hostname, ast_strip_quoted(S_OR(host3.host, ""), "\"", "\""));
 	ast_string_field_set(reg, authuser, ast_strip_quoted(S_OR(user3.authuser, ""), "\"", "\""));
@@ -307,7 +307,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg1, 1) ||
-		strcmp(reg->callback, "s")           ||
+		strcmp(reg->exten, "s")           ||
 		strcmp(reg->username, "name")       ||
 		strcmp(reg->regdomain, "")          ||
 		strcmp(reg->hostname, "domain")     ||
@@ -336,7 +336,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg2, 1) ||
-		strcmp(reg->callback, "s")           ||
+		strcmp(reg->exten, "s")           ||
 		strcmp(reg->username, "name")       ||
 		strcmp(reg->regdomain, "")          ||
 		strcmp(reg->hostname, "domain")     ||
@@ -365,7 +365,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg3, 1) ||
-		strcmp(reg->callback, "s")           ||
+		strcmp(reg->exten, "s")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -394,7 +394,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg4, 1) ||
-		strcmp(reg->callback, "extension")           ||
+		strcmp(reg->exten, "extension")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -423,7 +423,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg5, 1) ||
-		strcmp(reg->callback, "extension")           ||
+		strcmp(reg->exten, "extension")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -452,7 +452,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg6, 1) ||
-		strcmp(reg->callback, "extension")           ||
+		strcmp(reg->exten, "extension")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -481,7 +481,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg7, 1) ||
-		strcmp(reg->callback, "extension")           ||
+		strcmp(reg->exten, "extension")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -510,7 +510,7 @@
 		goto alloc_fail;
 	} else if (
 	    sip_parse_register_line(reg, default_expiry, reg8, 1) ||
-		strcmp(reg->callback, "extension")           ||
+		strcmp(reg->exten, "extension")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -580,7 +580,7 @@
 		goto alloc_fail;
 	} else if (
 	   sip_parse_register_line(reg, default_expiry, reg12, 1) ||
-		strcmp(reg->callback, "s")           ||
+		strcmp(reg->exten, "s")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
@@ -609,7 +609,7 @@
 		goto alloc_fail;
 	} else if (
 	   sip_parse_register_line(reg, default_expiry, reg13, 1) ||
-		strcmp(reg->callback, "s")           ||
+		strcmp(reg->exten, "s")           ||
 		strcmp(reg->username, "name") ||
 		strcmp(reg->regdomain, "namedomain") ||
 		strcmp(reg->hostname, "domain")     ||
diff -durN asterisk-11.17.1.orig/channels/sip/include/sip.h asterisk-11.17.1/channels/sip/include/sip.h
--- asterisk-11.17.1.orig/channels/sip/include/sip.h	2015-05-01 14:15:02.424636985 +1200
+++ asterisk-11.17.1/channels/sip/include/sip.h	2015-05-01 14:15:13.944387216 +1200
@@ -37,6 +37,9 @@
 #include "asterisk/features.h"
 #include "asterisk/http_websocket.h"
 #include "asterisk/rtp_engine.h"
+#include "asterisk/bridging.h"
+#include "asterisk/bridging_features.h"
+#include "asterisk/event.h"
 
 #ifndef FALSE
 #define FALSE    0
@@ -105,7 +108,7 @@
 #define SIP_MIN_PACKET            4096   /*!< Initialize size of memory to allocate for packets */
 #define MAX_HISTORY_ENTRIES		  50	 /*!< Max entires in the history list for a sip_pvt */
 
-#define INITIAL_CSEQ              101    /*!< Our initial sip sequence number */
+#define INITIAL_CSEQ              100    /*!< Our initial sip sequence number */
 
 #define DEFAULT_MAX_SE            1800   /*!< Session-Timer Default Session-Expires period (RFC 4028) */
 #define DEFAULT_MIN_SE            90     /*!< Session-Timer Default Min-SE period (RFC 4028) */
@@ -161,7 +164,7 @@
  *  \todo This string should be set dynamically. We only support REFER and SUBSCRIBE if we have
  *  allowsubscribe and allowrefer on in sip.conf.
  */
-#define ALLOWED_METHODS "INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY, INFO, PUBLISH, MESSAGE"
+#define ALLOWED_METHODS "INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, REGISTER, SUBSCRIBE, NOTIFY, INFO, PUBLISH, MESSAGE"
 
 /*! \brief Standard SIP unsecure port for UDP and TCP from RFC 3261. DO NOT CHANGE THIS */
 #define STANDARD_SIP_PORT	5060
@@ -345,7 +348,7 @@
 #define SIP_PAGE2_CALL_ONHOLD_INACTIVE      (3 << 19)   /*!< D: Inactive hold */
 
 #define SIP_PAGE2_RFC2833_COMPENSATE        (1 << 21)   /*!< DP: Compensate for buggy RFC2833 implementations */
-#define SIP_PAGE2_BUGGY_MWI                 (1 << 22)   /*!< DP: Buggy CISCO MWI fix */
+#define SIP_PAGE2_CISCO_USECALLMANAGER      (1 << 22)   /*!< DP: Unfied Cisco Phone Features (and Bugs) */
 #define SIP_PAGE2_DIALOG_ESTABLISHED        (1 << 23)   /*!< 29: Has a dialog been established? */
 
 #define SIP_PAGE2_FAX_DETECT                (3 << 24)   /*!< DP: Fax Detection support */
@@ -366,7 +369,7 @@
 #define SIP_PAGE2_FLAGS_TO_COPY \
 	(SIP_PAGE2_ALLOWSUBSCRIBE | SIP_PAGE2_ALLOWOVERLAP | SIP_PAGE2_IGNORESDPVERSION | \
 	SIP_PAGE2_VIDEOSUPPORT | SIP_PAGE2_T38SUPPORT | SIP_PAGE2_RFC2833_COMPENSATE | \
-	SIP_PAGE2_BUGGY_MWI | SIP_PAGE2_TEXTSUPPORT | SIP_PAGE2_FAX_DETECT | \
+	SIP_PAGE2_CISCO_USECALLMANAGER | SIP_PAGE2_TEXTSUPPORT | SIP_PAGE2_FAX_DETECT | \
 	SIP_PAGE2_UDPTL_DESTINATION | SIP_PAGE2_VIDEOSUPPORT_ALWAYS | SIP_PAGE2_PREFERRED_CODEC | \
 	SIP_PAGE2_RPID_IMMEDIATE | SIP_PAGE2_RPID_UPDATE | SIP_PAGE2_SYMMETRICRTP |\
 	SIP_PAGE2_Q850_REASON | SIP_PAGE2_HAVEPEERCONTEXT | SIP_PAGE2_USE_SRTP | SIP_PAGE2_TRUST_ID_OUTBOUND)
@@ -380,10 +383,23 @@
 #define SIP_PAGE3_USE_AVPF               (1 << 5)  /*!< DGP: Support a minimal AVPF-compatible profile */
 #define SIP_PAGE3_ICE_SUPPORT            (1 << 6)  /*!< DGP: Enable ICE support */
 #define SIP_PAGE3_FORCE_AVP              (1 << 7)  /*!< DGP: Force 'RTP/AVP' for all streams, even DTLS */
+#define SIP_PAGE3_WHY_DIDNT_DIGIUM_THINK_OF_THIS (1 << 8) /*!< Duh */
+#define SIP_PAGE3_DND_BUSY               (1 << 9)  /*!< DPG: Treat endpoint as busy when DND is enabled */
+#define SIP_PAGE3_SUBSCRIPTIONSTATE_ACTIVE (1 << 10) /*!< D: Force Subscription-State to be active for NOTIFYs */
+#define SIP_PAGE3_CISCO_KEEP_CONFERENCE  (1 << 11) /*!< DGP: Keep ad-hoc conference after initiator hangs up */
+#define SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE (1 << 12) /*!<< DGP: Allow participants to administrate conference */
+#define SIP_PAGE3_RELAY_NEAREND          (1 << 13) /*!< D: Add x-relay-nearend attribute to SDP */
+#define SIP_PAGE3_RELAY_FAREND           (1 << 14) /*!< D: Add x-relay-farend attribute to SDP */
+#define SIP_PAGE3_SDP_ACK                (1 << 15) /*!< D: Add SDP to ACK */
+#define SIP_PAGE3_CISCO_RECORDING        (1 << 16) /*!< D: Call is now being recorded */
+#define SIP_PAGE3_RTP_STATS_ON_BYE       (1 << 17) /*!< D: Display RTP stats on BYE */
+#define SIP_PAGE3_HUNTGROUP_DEFAULT      (1 << 18) /*!< GP: If peer is logged into huntgroup by default */
 
 #define SIP_PAGE3_FLAGS_TO_COPY \
 	(SIP_PAGE3_SNOM_AOC | SIP_PAGE3_SRTP_TAG_32 | SIP_PAGE3_NAT_AUTO_RPORT | SIP_PAGE3_NAT_AUTO_COMEDIA | \
-	 SIP_PAGE3_DIRECT_MEDIA_OUTGOING | SIP_PAGE3_USE_AVPF | SIP_PAGE3_ICE_SUPPORT | SIP_PAGE3_FORCE_AVP)
+	 SIP_PAGE3_DIRECT_MEDIA_OUTGOING | SIP_PAGE3_USE_AVPF | SIP_PAGE3_ICE_SUPPORT | SIP_PAGE3_FORCE_AVP | \
+	 SIP_PAGE3_WHY_DIDNT_DIGIUM_THINK_OF_THIS | SIP_PAGE3_DND_BUSY | SIP_PAGE3_CISCO_KEEP_CONFERENCE | \
+	 SIP_PAGE3_CISCO_MULTIADMIN_CONFERENCE | SIP_PAGE3_HUNTGROUP_DEFAULT)
 
 #define CHECK_AUTH_BUF_INITLEN   256
 
@@ -465,6 +481,9 @@
 	PIDF_XML,
 	MWI_NOTIFICATION,
 	CALL_COMPLETION,
+	PRESENCE,
+	FEATURE_EVENTS,
+	REMOTECC_XML,
 };
 
 /*! \brief The number of media types in enum \ref media_type below. */
@@ -946,6 +965,9 @@
 		AST_STRING_FIELD(replaces_callid);      /*!< Replace info: callid */
 		AST_STRING_FIELD(replaces_callid_totag);   /*!< Replace info: to-tag */
 		AST_STRING_FIELD(replaces_callid_fromtag); /*!< Replace info: from-tag */
+		AST_STRING_FIELD(require);              /*!< Outgoing Require header */
+		AST_STRING_FIELD(content_id);           /*!< Outgoing Content-ID header */
+		AST_STRING_FIELD(content_type);         /*!< Outgoing Content-Type header */
 	);
 	struct sip_pvt *refer_call;                     /*!< Call we are referring. This is just a reference to a
 							 * dialog owned by someone else, so we should not destroy
@@ -954,6 +976,7 @@
 	int attendedtransfer;                           /*!< Attended or blind transfer? */
 	int localtransfer;                              /*!< Transfer to local domain? */
 	enum referstatus status;                        /*!< REFER status */
+	struct ast_str *content;			/*!< Outgoing content body */
 };
 
 /*! \brief Struct to handle custom SIP notify requests. Dynamically allocated when needed */
@@ -1068,6 +1091,10 @@
 		AST_STRING_FIELD(last_presence_subtype);   /*!< The last presence subtype sent for a subscription. */
 		AST_STRING_FIELD(last_presence_message);   /*!< The last presence message for a subscription */
 		AST_STRING_FIELD(msg_body);     /*!< Text for a MESSAGE body */
+		AST_STRING_FIELD(callforward);  /*!< Call Forward target */
+		AST_STRING_FIELD(join_callid);  /*!< Join callid */
+		AST_STRING_FIELD(join_tag);     /*!< Join tag */
+		AST_STRING_FIELD(join_theirtag); /*!< Join theirtag */
 	);
 	char via[128];                          /*!< Via: header */
 	int maxforwards;                        /*!< SIP Loop prevention */
@@ -1195,6 +1222,9 @@
 	struct sip_srtp *srtp;              /*!< Structure to hold Secure RTP session data for audio */
 	struct sip_srtp *vsrtp;             /*!< Structure to hold Secure RTP session data for video */
 	struct sip_srtp *tsrtp;             /*!< Structure to hold Secure RTP session data for text */
+	int donotdisturb:1;                 /*!< Peer has set DoNotDisturb */
+	struct sip_pvt *recordoutpvt;       /*!< Pvt for the outbound recording leg */
+	struct sip_pvt *recordinpvt;        /*!< Pvt for the inbound recording leg */
 
 	int red;                            /*!< T.140 RTP Redundancy */
 	int hangupcause;                    /*!< Storage of hangupcause copied from our owner before we disconnect from the AST channel (only used at hangup) */
@@ -1228,6 +1258,8 @@
 	struct ast_cc_config_params *cc_params;
 	struct sip_epa_entry *epa_entry;
 	int fromdomainport;                 /*!< Domain port to show in from field */
+	struct sip_conference *conference;  /*!< Ad-hoc n-way conference support */ 
+	struct ast_event_sub *park_event_sub; /*!< Event subscription for parked calls */
 
 	struct ast_rtp_dtls_cfg dtls_cfg;
 };
@@ -1271,6 +1303,30 @@
 	char mailbox[2];
 };
 
+/*!
+ * \brief A peer's bulk register aliases 
+ */
+struct sip_alias {
+	char *name;
+	AST_LIST_ENTRY(sip_alias) entry;
+	struct sip_peer *peer;
+	int lineindex;
+	unsigned int delme:1;
+};
+
+/*!
+ * \brief A peer's subscription
+ */
+struct sip_subscription {
+	struct sip_pvt *pvt;
+	AST_LIST_ENTRY(sip_subscription) entry;
+	unsigned int delme:1;
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(exten);
+		AST_STRING_FIELD(context);
+	);
+};
+
 /*! \brief Structure for SIP peer data, we place calls to peers if registered  or fixed IP address (host)
 */
 /* XXX field 'name' must be first otherwise sip_addrcmp() will fail, as will astobj2 hashing of the structure */
@@ -1306,7 +1362,9 @@
 		AST_STRING_FIELD(zone);         /*!< Tonezone for this device */
 		AST_STRING_FIELD(record_on_feature); /*!< Feature to use when receiving INFO with record: on during a call */
 		AST_STRING_FIELD(record_off_feature); /*!< Feature to use when receiving INFO with record: off during a call */
-		AST_STRING_FIELD(callback); /*!< Callback extension */
+		AST_STRING_FIELD(callbackexten); /*!< Callback extension */
+		AST_STRING_FIELD(callforward);  /*!< Call forwarding extension */
+		AST_STRING_FIELD(regcallid);    /*!< Call-ID of the REGISTER dialog */
 		);
 	struct sip_socket socket;       /*!< Socket used for this peer */
 	enum sip_transport default_outbound_transport;   /*!< Peer Registration may change the default outbound transport.
@@ -1329,6 +1387,9 @@
 	int inuse;                      /*!< Number of calls in use */
 	int ringing;                    /*!< Number of calls ringing */
 	int onhold;                     /*!< Peer has someone on hold */
+	int donotdisturb:1;             /*!< Peer has set DoNotDisturb */
+	int huntgroup:1;		/*!< Peer is logged into the HuntGroup */
+	int offhook;			/*!< Peer has signalled that they are off-hook */
 	int call_limit;                 /*!< Limit of concurrent calls */
 	unsigned int t38_maxdatagram;            /*!< T.38 FaxMaxDatagram override */
 	int busy_level;                 /*!< Level of active channels where we signal busy */
@@ -1342,6 +1403,15 @@
 	/*! Mailboxes that this peer cares about */
 	AST_LIST_HEAD_NOLOCK(, sip_mailbox) mailboxes;
 
+	/*! Bulk register aliases that this peer cares about */
+	AST_LIST_HEAD_NOLOCK(, sip_alias) aliases;
+
+	/*! Subscriptions that this peer cares about */
+	AST_LIST_HEAD_NOLOCK(, sip_subscription) subscriptions;
+
+	/*! Dialogs selected for joining */
+	AST_LIST_HEAD_NOLOCK(, sip_selected) selected;
+
 	int maxcallbitrate;             /*!<  Maximum Bitrate for a video call */
 	int expire;                     /*!<  When to expire this peer registration */
 	struct ast_format_cap *caps;            /*!<  Codec capability */
@@ -1370,10 +1440,13 @@
 	struct ast_acl_list *directmediaacl;   /*!<  Restrict what IPs are allowed to interchange direct media with */
 	struct ast_variable *chanvars;  /*!<  Variables to set for channel created by user */
 	struct sip_pvt *mwipvt;         /*!<  Subscription for MWI */
+	struct sip_pvt *fepvt;          /*!<  Subscription for Feature Events */
+	struct sip_callback *callback;  /*!<  Extension State watcher for Call Back requests */
 	struct sip_st_cfg stimer;       /*!<  SIP Session-Timers */
 	int timer_t1;                   /*!<  The maximum T1 value for the peer */
 	int timer_b;                    /*!<  The maximum timer B (transaction timeouts) */
 	int fromdomainport;             /*!<  The From: domain port */
+	int cisco_lineindex;		/*!<  Line index number */
 
 	/*XXX Seems like we suddenly have two flags with the same content. Why? To be continued... */
 	enum sip_peer_type type; /*!< Distinguish between "user" and "peer" types. This is used solely for CLI and manager commands */
@@ -1412,7 +1485,7 @@
 		AST_STRING_FIELD(hostname);   /*!< Domain or host we register to */
 		AST_STRING_FIELD(secret);     /*!< Password in clear text */
 		AST_STRING_FIELD(md5secret);  /*!< Password in md5 */
-		AST_STRING_FIELD(callback);   /*!< Contact extension */
+		AST_STRING_FIELD(exten);      /*!< Contact extension */
 		AST_STRING_FIELD(peername);   /*!< Peer registering to */
 		AST_STRING_FIELD(localtag);   /*!< Local tag generated same time as callid */
 	);
@@ -1453,6 +1526,52 @@
 };
 
 /*!
+ * \brief Container for server-side n-way conference bridging
+ */
+struct sip_conference {
+	int confid;
+	int next_callid;
+	struct ast_bridge *bridge;
+	struct ast_channel *playback_chan;
+	int keep:1;
+	int multiadmin:1;
+	int administrators;
+	int users;
+	AST_LIST_HEAD_NOLOCK(, sip_participant) participants;
+	char action[16];
+	AST_LIST_ENTRY(sip_conference) entry;
+};
+
+struct sip_participant {
+	int callid;
+	struct sip_conference *conference;
+	struct ast_channel *chan;
+	struct ast_bridge_features features;
+	int administrator:1;
+	int removed:1;
+	int talking:1;
+	AST_LIST_ENTRY(sip_participant) entry;
+};
+
+struct sip_selected {
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(callid);
+		AST_STRING_FIELD(tag);
+		AST_STRING_FIELD(theirtag);
+	);
+	AST_LIST_ENTRY(sip_selected) entry;
+};
+
+/*!
+ * \brief Container for peer callback (camp-on) watcher
+ */
+struct sip_callback {
+	int stateid;
+	char *exten;
+	int busy:1;
+};
+
+/*!
  * \brief Definition of an MWI subscription to another server
  * 
  * \todo Convert this to astobj2.
diff -durN asterisk-11.17.1.orig/configs/features.conf.sample asterisk-11.17.1/configs/features.conf.sample
--- asterisk-11.17.1.orig/configs/features.conf.sample	2015-05-01 14:15:02.388637765 +1200
+++ asterisk-11.17.1/configs/features.conf.sample	2015-05-01 14:15:13.944387216 +1200
@@ -66,6 +66,7 @@
 ;parkinghints = no              ; Add hints priorities automatically for parking slots (default is no for all lots).
 ;parkingtime => 45              ; Number of seconds a call can be parked before returning.
                                 ; (default is 45 for all lots)
+;remindertime => 30             ; Number of seconds a call can be parked before sending a reminder event.
 ;parkedcalltransfers = caller   ; Enables or disables DTMF based transfers when picking up a parked call.
                                 ; one of: callee, caller, both, no (default is no for all lots)
 ;parkedcallreparking = caller   ; Enables or disables DTMF based parking when picking up a parked call.
diff -durN asterisk-11.17.1.orig/configs/sip.conf.sample asterisk-11.17.1/configs/sip.conf.sample
--- asterisk-11.17.1.orig/configs/sip.conf.sample	2015-05-01 14:15:02.388637765 +1200
+++ asterisk-11.17.1/configs/sip.conf.sample	2015-05-01 14:15:13.944387216 +1200
@@ -1537,6 +1537,18 @@
 ;defaultip=192.168.0.4           ; IP address to use until registration
 ;defaultuser=goran               ; Username to use when calling this device before registration
                                  ; Normally you do NOT need to set this parameter
+;dndbusy=yes                     ; Automatically send back a busy signal when trying to call a peer that is DND
+;huntgroup_default=yes           ; If peer is logged into huntgroup by default
+;cisco_usecallmanager=yes        ; Enable Cisco phone features, required to make hints, presence and call-forwarding work,
+                                 ; DO NOT enable this on any other type of device
+;register=cisco2                 ; cisco_usecallmanager phones only REGISTER their first line so any other lines have to
+                                 ; be configured here as well.
+;subscribe=123                   ; cisco_usecallmanager phones don't SUBSCRIBE to hints so they need to be configured
+                                 ; both in SEPMAC.cnf.xml and here as well
+;cisco_keep_conference=no        ; When there are no more administrators in an ad-hoc conference hang up the other
+                                 ; participants
+;cisco_multiadmin_conference=yes ; If the participant added to an ad-hoc conference has cisco_usecallmanager=yes and
+                                 ; cisco_multiadmin_conference=yes then make them an administrator as well
 ;setvar=CUSTID=5678              ; Channel variable to be set for all calls from or to this device
 ;setvar=ATTENDED_TRANSFER_COMPLETE_SOUND=beep   ; This channel variable will
                                                 ; cause the given audio file to
diff -durN asterisk-11.17.1.orig/configs/sip_notify.conf.sample asterisk-11.17.1/configs/sip_notify.conf.sample
--- asterisk-11.17.1.orig/configs/sip_notify.conf.sample	2015-05-01 14:15:02.392637678 +1200
+++ asterisk-11.17.1/configs/sip_notify.conf.sample	2015-05-01 14:15:13.944387216 +1200
@@ -55,3 +55,26 @@
 
 [cisco-check-cfg]
 Event=>check-sync
+
+[cisco-restart]
+Event=>service-control
+Subscription-State=>active
+Content-Type=>text/plain
+Content=>action=restart
+Content=>RegisterCallId={${SIPPEER(${PEERNAME},regcallid)}}
+Content=>ConfigVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>DialplanVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>SoftkeyVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>FeatureControlVersionStamp={00000000-0000-0000-0000-000000000000}
+
+[cisco-reset]
+Event=>service-control
+Subscription-State=>active
+Content-Type=>text/plain
+Content=>action=reset
+Content=>RegisterCallId={${SIPPEER(${PEERNAME},regcallid)}}
+Content=>ConfigVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>DialplanVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>SoftkeyVersionStamp={00000000-0000-0000-0000-000000000000}
+Content=>FeatureControlVersionStamp={00000000-0000-0000-0000-000000000000}
+
diff -durN asterisk-11.17.1.orig/funcs/func_presencestate.c asterisk-11.17.1/funcs/func_presencestate.c
--- asterisk-11.17.1.orig/funcs/func_presencestate.c	2015-05-01 14:15:02.376638025 +1200
+++ asterisk-11.17.1/funcs/func_presencestate.c	2015-05-01 14:15:13.944387216 +1200
@@ -92,7 +92,7 @@
 			the dialplan:</para>
 			<para>exten => 1234,hint,,CustomPresence:lamp1</para>
 			<para>The possible values for both uses of this function are:</para>
-			<para>not_set | unavailable | available | away | xa | chat | dnd</para>
+			<para>NOT_SET | UNAVAILABLE | AVAILABLE | AWAY | XA | CHAT | DND</para>
 		</description>
 	</function>
  ***/
diff -durN asterisk-11.17.1.orig/include/asterisk/channel.h asterisk-11.17.1/include/asterisk/channel.h
--- asterisk-11.17.1.orig/include/asterisk/channel.h	2015-05-01 14:15:02.412637245 +1200
+++ asterisk-11.17.1/include/asterisk/channel.h	2015-05-01 14:15:13.948387129 +1200
@@ -578,6 +578,8 @@
 
 	int (* const devicestate)(const char *device_number);	/*!< Devicestate call back */
 
+	int (* const presencestate)(const char *presence_number, char **subtype, char **message);   /*!< Presencestate call back */
+
 	/*!
 	 * \brief Start sending a literal DTMF digit
 	 *
diff -durN asterisk-11.17.1.orig/include/asterisk/event_defs.h asterisk-11.17.1/include/asterisk/event_defs.h
--- asterisk-11.17.1.orig/include/asterisk/event_defs.h	2015-05-01 14:15:02.412637245 +1200
+++ asterisk-11.17.1/include/asterisk/event_defs.h	2015-05-01 14:15:13.948387129 +1200
@@ -60,8 +60,10 @@
 	AST_EVENT_ACL_CHANGE          = 0x0b,
 	/*! Send out a ping for debugging distributed events */
 	AST_EVENT_PING                = 0x0c,
+	/*! Status of a call parking extension */
+	AST_EVENT_PARKED_CALL         = 0x0d,
 	/*! Number of event types.  This should be the last event type + 1 */
-	AST_EVENT_TOTAL               = 0x0d,
+	AST_EVENT_TOTAL               = 0x0e,
 };
 
 /*! \brief Event Information Element types */
@@ -297,15 +299,19 @@
 	AST_EVENT_IE_PRESENCE_STATE      = 0x003a,
 	AST_EVENT_IE_PRESENCE_SUBTYPE    = 0x003b,
 	AST_EVENT_IE_PRESENCE_MESSAGE    = 0x003c,
+	AST_EVENT_IE_EXTEN               = 0x003d,
+	AST_EVENT_IE_TIMEOUT             = 0x003e,
+	AST_EVENT_IE_CIDNAME             = 0x003f,
+	AST_EVENT_IE_CIDNUM              = 0x0040,
 
 	/*!
 	 * \brief Event non-cachability flag
 	 * Used by: All events
 	 * Payload type: UINT
 	 */
-	AST_EVENT_IE_CACHABLE            = 0x003d,
+	AST_EVENT_IE_CACHABLE            = 0x0041,
 	/*! \brief Must be the last IE value +1 */
-	AST_EVENT_IE_TOTAL               = 0x003e,
+	AST_EVENT_IE_TOTAL               = 0x0042,
 };
 
 /*!
diff -durN asterisk-11.17.1.orig/include/asterisk/features.h asterisk-11.17.1/include/asterisk/features.h
--- asterisk-11.17.1.orig/include/asterisk/features.h	2015-05-01 14:15:02.412637245 +1200
+++ asterisk-11.17.1/include/asterisk/features.h	2015-05-01 14:15:13.948387129 +1200
@@ -36,6 +36,15 @@
 
 #define DEFAULT_PARKINGLOT "default"	/*!< Default parking lot */
 
+/*! \brief Parked call state */
+enum {
+	AST_PARKED_CALL_PARKED    = 0,
+	AST_PARKED_CALL_REMINDER  = 1,
+	AST_PARKED_CALL_RETRIEVED = 2,
+	AST_PARKED_CALL_TIMEOUT   = 3,
+	AST_PARKED_CALL_HANGUP    = 4
+};
+
 #define AST_FEATURE_RETURN_HANGUP           -1
 #define AST_FEATURE_RETURN_SUCCESSBREAK     0
 #define AST_FEATURE_RETURN_PBX_KEEPALIVE    AST_PBX_KEEPALIVE
diff -durN asterisk-11.17.1.orig/main/channel.c asterisk-11.17.1/main/channel.c
--- asterisk-11.17.1.orig/main/channel.c	2015-05-01 14:15:02.312639413 +1200
+++ asterisk-11.17.1/main/channel.c	2015-05-01 14:15:13.948387129 +1200
@@ -62,6 +62,7 @@
 #include "asterisk/app.h"
 #include "asterisk/transcap.h"
 #include "asterisk/devicestate.h"
+#include "asterisk/presencestate.h"
 #include "asterisk/threadstorage.h"
 #include "asterisk/slinfactory.h"
 #include "asterisk/audiohook.h"
@@ -289,7 +290,7 @@
 /*! \brief Show channel types - CLI command */
 static char *handle_cli_core_show_channeltypes(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-#define FORMAT  "%-15.15s  %-40.40s %-12.12s %-12.12s %-12.12s\n"
+#define FORMAT  "%-15.15s  %-40.40s %-13.13s %-13.13s %-13.13s %-13.13s\n"
 	struct chanlist *cl;
 	int count_chan = 0;
 
@@ -308,13 +309,13 @@
 	if (a->argc != 3)
 		return CLI_SHOWUSAGE;
 
-	ast_cli(a->fd, FORMAT, "Type", "Description",       "Devicestate", "Indications", "Transfer");
-	ast_cli(a->fd, FORMAT, "-----------", "-----------", "-----------", "-----------", "-----------");
+	ast_cli(a->fd, FORMAT, "Type", "Description", "Devicestate", "Presencestate", "Indications", "Transfer");
 
 	AST_RWLIST_RDLOCK(&backends);
 	AST_RWLIST_TRAVERSE(&backends, cl, list) {
 		ast_cli(a->fd, FORMAT, cl->tech->type, cl->tech->description,
 			(cl->tech->devicestate) ? "yes" : "no",
+			(cl->tech->presencestate) ? "yes" : "no",
 			(cl->tech->indicate) ? "yes" : "no",
 			(cl->tech->transfer) ? "yes" : "no");
 		count_chan++;
@@ -389,6 +390,7 @@
 	ast_cli(a->fd,
 		"-- Info about channel driver: %s --\n"
 		"  Device State: %s\n"
+		"Presence State: %s\n"
 		"    Indication: %s\n"
 		"     Transfer : %s\n"
 		"  Capabilities: %s\n"
@@ -399,6 +401,7 @@
 		"  Text Support: %s\n",
 		cl->tech->type,
 		(cl->tech->devicestate) ? "yes" : "no",
+		(cl->tech->presencestate) ? "yes" : "no",
 		(cl->tech->indicate) ? "yes" : "no",
 		(cl->tech->transfer) ? "yes" : "no",
 		ast_getformatname_multiple(buf, sizeof(buf), cl->tech->capabilities),
@@ -8583,6 +8586,7 @@
 		ast_data_add_str(data_type, "name", cl->tech->type);
 		ast_data_add_str(data_type, "description", cl->tech->description);
 		ast_data_add_bool(data_type, "devicestate", cl->tech->devicestate ? 1 : 0);
+		ast_data_add_bool(data_type, "presencestate", cl->tech->presencestate ? 1 : 0);
 		ast_data_add_bool(data_type, "indications", cl->tech->indicate ? 1 : 0);
 		ast_data_add_bool(data_type, "transfer", cl->tech->transfer ? 1 : 0);
 		ast_data_add_bool(data_type, "send_digit_begin", cl->tech->send_digit_begin ? 1 : 0);
diff -durN asterisk-11.17.1.orig/main/event.c asterisk-11.17.1/main/event.c
--- asterisk-11.17.1.orig/main/event.c	2015-05-01 14:15:02.312639413 +1200
+++ asterisk-11.17.1/main/event.c	2015-05-01 14:15:13.948387129 +1200
@@ -143,6 +143,7 @@
 static int ast_event_hash_devstate(const void *obj, const int flags);
 static int ast_event_hash_devstate_change(const void *obj, const int flags);
 static int ast_event_hash_presence_state_change(const void *obj, const int flags);
+static int ast_event_hash_parked_call(const void *obj, const int flags);
 
 #ifdef LOW_MEMORY
 #define NUM_CACHE_BUCKETS 17
@@ -191,7 +192,10 @@
 		.hash_fn = ast_event_hash_presence_state_change,
 		.cache_args = { AST_EVENT_IE_PRESENCE_STATE, },
 	},
-
+	[AST_EVENT_PARKED_CALL] = {
+		.hash_fn = ast_event_hash_parked_call,
+		.cache_args = { AST_EVENT_IE_EXTEN, AST_EVENT_IE_CONTEXT },
+	},
 };
 
 /*!
@@ -199,7 +203,7 @@
  *
  * \note These names must match what is in the event_names array.
  */
-static const char * const cached_event_types[] = { "MWI", "DeviceState", "DeviceStateChange", NULL };
+static const char * const cached_event_types[] = { "MWI", "DeviceState", "DeviceStateChange", "ParkedCall", NULL };
 
 /*!
  * \brief Event Names
@@ -218,6 +222,7 @@
 	[AST_EVENT_PRESENCE_STATE]      = "PresenceState",
 	[AST_EVENT_ACL_CHANGE]          = "ACLChange",
 	[AST_EVENT_PING]                = "Ping",
+	[AST_EVENT_PARKED_CALL]         = "ParkedCall",
 };
 
 /*!
@@ -287,6 +292,10 @@
 	[AST_EVENT_IE_PRESENCE_STATE]      = { AST_EVENT_IE_PLTYPE_UINT, "PresenceState" },
 	[AST_EVENT_IE_PRESENCE_SUBTYPE]    = { AST_EVENT_IE_PLTYPE_STR,  "PresenceSubtype" },
 	[AST_EVENT_IE_PRESENCE_MESSAGE]    = { AST_EVENT_IE_PLTYPE_STR,  "PresenceMessage" },
+	[AST_EVENT_IE_EXTEN]               = { AST_EVENT_IE_PLTYPE_UINT, "Exten" },
+	[AST_EVENT_IE_CIDNUM]              = { AST_EVENT_IE_PLTYPE_STR,  "CIDNum" },
+	[AST_EVENT_IE_CIDNAME]             = { AST_EVENT_IE_PLTYPE_STR,  "CIDName" },
+	[AST_EVENT_IE_TIMEOUT]             = { AST_EVENT_IE_PLTYPE_UINT, "Timeout" },
 };
 
 const char *ast_event_get_type_name(const struct ast_event *event)
@@ -1631,6 +1640,24 @@
 	return ast_str_hash(ast_event_get_ie_str(event, AST_EVENT_IE_PRESENCE_PROVIDER));
 }
 
+/*!
+ * \internal
+ * \brief Hash function for AST_EVENT_PARKED_CALL
+ *
+ * \param[in] obj an ast_event
+ * \param[in] flags unused
+ *
+ * \return hash value
+ */
+static int ast_event_hash_parked_call(const void *obj, const int flags)
+{
+	const struct ast_event *event = obj;
+	int exten = ast_event_get_ie_uint(event, AST_EVENT_IE_EXTEN);
+	const char *context = ast_event_get_ie_str(event, AST_EVENT_IE_CONTEXT);
+
+	return exten ^ ast_str_hash(context);
+}
+
 static int ast_event_hash(const void *obj, const int flags)
 {
 	const struct ast_event_ref *event_ref;
diff -durN asterisk-11.17.1.orig/main/features.c asterisk-11.17.1/main/features.c
--- asterisk-11.17.1.orig/main/features.c	2015-05-01 14:15:02.316639326 +1200
+++ asterisk-11.17.1/main/features.c	2015-05-01 14:15:13.948387129 +1200
@@ -279,7 +279,7 @@
 		</synopsis>
 		<syntax>
 			<parameter name="timeout">
-				<para>A custom parking timeout for this parked call. Value in milliseconds.</para>
+				<para>A custom parking timeout for this parked call. Value in seconds.</para>
 			</parameter>
 			<parameter name="return_context">
 				<para>The context to return the call to after it times out.</para>
@@ -302,6 +302,11 @@
 					<option name="s">
 						<para>Silence announcement of the parking space number.</para>
 					</option>
+					<option name="t">
+						<argument name="x" required="false" />
+						<para>Wait for <replaceable>x</replaceable> seconds before
+						sending a reminder notification event.</para>
+					</option>
 				</optionlist>
 			</parameter>
 			<parameter name="parking_lot_name">
@@ -429,6 +434,7 @@
 				<para>The allowed values are:</para>
 				<enumlist>
 					<enum name="parkingtime"><para>Specified in seconds.</para></enum>
+					<enum name="remindertime"><para>Specified in seconds.</para></enum>
 				</enumlist>
 			</parameter>
 		</syntax>
@@ -513,17 +519,18 @@
 	</managerEvent>
  ***/
 
-#define DEFAULT_PARK_TIME							45000	/*!< ms */
-#define DEFAULT_PARK_EXTENSION						"700"
-#define DEFAULT_TRANSFER_DIGIT_TIMEOUT				3000	/*!< ms */
-#define DEFAULT_FEATURE_DIGIT_TIMEOUT				1000	/*!< ms */
+#define DEFAULT_PARKING_TIME				45000	/*!< ms */
+#define DEFAULT_REMINDER_TIME				0	/*!< ms */
+#define DEFAULT_PARK_EXTENSION				"700"
+#define DEFAULT_TRANSFER_DIGIT_TIMEOUT			3000	/*!< ms */
+#define DEFAULT_FEATURE_DIGIT_TIMEOUT			1000	/*!< ms */
 #define DEFAULT_NOANSWER_TIMEOUT_ATTENDED_TRANSFER	15000	/*!< ms */
-#define DEFAULT_ATXFER_DROP_CALL					0		/*!< Do not drop call. */
-#define DEFAULT_ATXFER_LOOP_DELAY					10000	/*!< ms */
-#define DEFAULT_ATXFER_CALLBACK_RETRIES				2
-#define DEFAULT_COMEBACK_CONTEXT					"parkedcallstimeout"
-#define DEFAULT_COMEBACK_TO_ORIGIN					1
-#define DEFAULT_COMEBACK_DIAL_TIME					30
+#define DEFAULT_ATXFER_DROP_CALL			0	/*!< Do not drop call. */
+#define DEFAULT_ATXFER_LOOP_DELAY			10000	/*!< ms */
+#define DEFAULT_ATXFER_CALLBACK_RETRIES			2
+#define DEFAULT_COMEBACK_CONTEXT			"parkedcallstimeout"
+#define DEFAULT_COMEBACK_TO_ORIGIN			1
+#define DEFAULT_COMEBACK_DIAL_TIME			30
 
 #define AST_MAX_WATCHERS 256
 #define MAX_DIAL_FEATURE_OPTIONS 30
@@ -612,10 +619,12 @@
 	char exten[AST_MAX_EXTENSION];
 	int priority;
 	unsigned int parkingtime;                   /*!< Maximum length in parking lot before return */
+	unsigned int remindertime;                  /*!< When to send reminder event */
 	/*! Method to entertain the caller when parked: AST_CONTROL_RINGING, AST_CONTROL_HOLD, or 0(none) */
 	enum ast_control_frame_type hold_method;
 	unsigned int notquiteyet:1;
 	unsigned int options_specified:1;
+	unsigned int sentreminder:1;
 	char peername[AST_CHANNEL_NAME];
 	unsigned char moh_trys;
 	/*! Parking lot this entry belongs to.  Holds a parking lot reference. */
@@ -639,6 +648,8 @@
 	int parking_stop;
 	/*! Default parking time in ms. */
 	unsigned int parkingtime;
+	/*! Default reminder time is ms. */
+	unsigned int remindertime;
 	/*!
 	 * \brief Enable DTMF based transfers on bridge when picking up parked calls.
 	 *
@@ -723,6 +734,9 @@
  */
 static struct ast_parkinglot *default_parkinglot;
 
+/*! \brief Dummy event subscription to parked calls so that they can be cached */
+static struct ast_event_sub *parking_event_sub = NULL;
+
 /*! Force a config reload to reload regardless of config file timestamp. */
 static int force_reload_load;
 
@@ -1280,6 +1294,14 @@
 	AST_PARK_OPT_RANDOMIZE = (1 << 1),
 	/*! Do not announce the parking number */
 	AST_PARK_OPT_SILENCE = (1 << 2),
+	/*! How long to wait before sending a reminder to the parker that call
+	 *  is still parked */
+	AST_PARK_OPT_REMINDER = (1 << 3),
+};
+
+enum ast_park_call_option_args {
+	AST_PARK_ARG_REMINDER = 0,
+	AST_PARK_ARG_ARRAY_SIZE
 };
 
 /*! Optional additional parking options when parking a call. */
@@ -1288,6 +1310,8 @@
 	 *  to the specified return extension (or a best guess at where it came
 	 *  from if not explicitly specified). */
 	int timeout;
+	/*! How long to wait before sending a reminder */
+	int reminder;
 	/*! An output parameter to store the parking space where the parked caller
 	 *  was placed. */
 	int *extout;
@@ -1302,6 +1326,13 @@
 	struct ast_parkinglot *parkinglot;
 };
 
+AST_APP_OPTIONS(park_call_options, BEGIN_OPTIONS
+	AST_APP_OPTION('r', AST_PARK_OPT_RINGING),
+	AST_APP_OPTION('R', AST_PARK_OPT_RANDOMIZE),
+	AST_APP_OPTION('s', AST_PARK_OPT_SILENCE),
+	AST_APP_OPTION_ARG('t', AST_PARK_OPT_REMINDER, AST_PARK_ARG_REMINDER),
+END_OPTIONS);
+
 /*!
  * \internal
  * \brief Create a dynamic parking lot.
@@ -1616,7 +1647,14 @@
 	return pu;
 }
 
-static unsigned int get_parkingtime(struct ast_channel *chan, struct ast_parkinglot *parkinglot);
+static void get_parkingtime(struct ast_channel *chan, struct ast_parkinglot *parkinglot, unsigned int *parkingtime, unsigned int *remindertime);
+
+static void parking_event_cb(const struct ast_event *event, void *userdata)
+{
+	/* Does nothing, only exists so that there will be at least one subscriber to parking events so
+	   the event manager will cache them  */
+	return;
+}
 
 /* Park a call */
 static int park_call_full(struct ast_channel *chan, struct ast_channel *peer, struct ast_park_call_args *args)
@@ -1624,6 +1662,8 @@
 	struct parkeduser *pu = args->pu;
 	const char *event_from;		/*!< Channel name that is parking the call. */
 	char app_data[AST_MAX_EXTENSION + AST_MAX_CONTEXT];
+	struct ast_party_connected_line connected;
+	struct ast_event *event;
 
 	if (pu == NULL) {
 		args->pu = pu = park_space_reserve(chan, peer, args);
@@ -1635,6 +1675,24 @@
 	ast_channel_appl_set(chan, "Parked Call");
 	ast_channel_data_set(chan, NULL);
 
+	ast_party_connected_line_init(&connected);
+	ast_channel_lock(chan);
+	ast_party_connected_line_copy(&connected, ast_channel_connected(chan));
+	ast_channel_unlock(chan);
+
+	ast_free(connected.id.name.str);
+	connected.id.name.str = ast_strdup("Parked Call");
+	connected.id.name.valid = 1;
+
+	ast_free(connected.id.number.str);
+	connected.id.number.str = ast_strdup(pu->parkingexten);
+	connected.id.number.valid = 1;
+
+	connected.source = AST_CONNECTED_LINE_UPDATE_SOURCE_ANSWER;
+	ast_channel_update_connected_line(chan, &connected, NULL);
+
+	ast_party_connected_line_free(&connected);
+
 	pu->chan = chan;
 
 	/* Put the parked channel on hold if we have two different channels */
@@ -1651,7 +1709,11 @@
 	}
 
 	pu->start = ast_tvnow();
-	pu->parkingtime = (args->timeout > 0) ? args->timeout : get_parkingtime(chan, pu->parkinglot);
+	pu->parkingtime = args->timeout;
+	pu->remindertime = args->reminder;
+	if (!pu->parkingtime || !pu->remindertime) {
+		get_parkingtime(chan, pu->parkinglot, pu->parkingtime ? NULL : &pu->parkingtime, pu->remindertime ? NULL : &pu->remindertime);
+	}
 	if (args->extout)
 		*(args->extout) = pu->parkingnum;
 
@@ -1728,6 +1790,18 @@
 		ast_channel_name(chan), pu->parkingnum, pu->parkinglot->name,
 		pu->context, pu->exten, pu->priority, (pu->parkingtime / 1000));
 
+	if ((event = ast_event_new(AST_EVENT_PARKED_CALL,
+				AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_PARKED,
+				AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, pu->parkingnum,
+				AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, pu->context,
+				AST_EVENT_IE_TIMEOUT, AST_EVENT_IE_PLTYPE_UINT, pu->parkingtime,
+				AST_EVENT_IE_CIDNUM, AST_EVENT_IE_PLTYPE_STR,
+					S_COR(ast_channel_caller(pu->chan)->id.number.valid, ast_channel_caller(pu->chan)->id.number.str, ""),
+				AST_EVENT_IE_CIDNAME, AST_EVENT_IE_PLTYPE_STR,
+					S_COR(ast_channel_caller(pu->chan)->id.name.valid, ast_channel_caller(pu->chan)->id.name.str, ""),
+				AST_EVENT_IE_END))) {
+		ast_event_queue_and_cache(event);
+	}
 	ast_cel_report_event(chan, AST_CEL_PARK_START, NULL, pu->parkinglot->name, peer);
 	/*** DOCUMENTATION
 		<managerEventInstance>
@@ -1826,10 +1900,12 @@
 int ast_park_call_exten(struct ast_channel *park_me, struct ast_channel *parker, const char *park_exten, const char *park_context, int timeout, int *extout)
 {
 	int res;
-	char *parse;
+	struct ast_str *parse;
 	const char *app_data;
 	struct ast_exten *exten;
 	struct park_app_args app_args;
+	struct ast_flags opts = { 0, };
+	char *opt_args[AST_PARK_ARG_ARRAY_SIZE];
 	struct ast_park_call_args args = {
 		.timeout = timeout,
 		.extout = extout,
@@ -1838,6 +1914,10 @@
 	if (!park_exten || !park_context) {
 		return park_call_full(park_me, parker, &args);
 	}
+	if (!(parse = ast_str_create(32))) {
+		ast_log(LOG_WARNING, "Unable to allocate string for variable substitution\n");
+		return -1;
+	}
 
 	/*
 	 * Determiine if the specified park extension has an exclusive
@@ -1852,8 +1932,37 @@
 		if (!app_data) {
 			app_data = "";
 		}
-		parse = ast_strdupa(app_data);
-		AST_STANDARD_APP_ARGS(app_args, parse);
+		ast_str_substitute_variables(&parse, 0, park_me, app_data);
+		AST_STANDARD_APP_ARGS(app_args, ast_str_buffer(parse));
+
+		if (!ast_strlen_zero(app_args.timeout)) {
+			if (ast_app_parse_timelen(app_args.timeout, &args.timeout, TIMELEN_SECONDS)) {
+				ast_log(LOG_WARNING, "Invalid timeout '%s' provided\n", app_args.timeout);
+				args.timeout = 0;
+			}
+		}
+		if (!ast_strlen_zero(app_args.return_con)) {
+			args.return_con = app_args.return_con;
+		}
+		if (!ast_strlen_zero(app_args.return_ext)) {
+			args.return_ext = app_args.return_ext;
+		}
+		if (!ast_strlen_zero(app_args.return_pri)) {
+			if (sscanf(app_args.return_pri, "%30d", &args.return_pri) != 1) {
+				ast_log(LOG_WARNING, "Invalid priority '%s' specified\n", app_args.return_pri);
+				args.return_pri = 0;
+			}
+		}
+
+		ast_app_parse_options(park_call_options, &opts, opt_args, app_args.options);
+		ast_copy_flags(&args, &opts, AST_PARK_OPT_RINGING | AST_PARK_OPT_RANDOMIZE | AST_PARK_OPT_SILENCE);
+
+		if (ast_test_flag(&opts, AST_PARK_OPT_REMINDER) && !ast_strlen_zero(opt_args[AST_PARK_ARG_REMINDER])) {
+			if (ast_app_parse_timelen(opt_args[AST_PARK_ARG_REMINDER], &args.reminder, TIMELEN_SECONDS)) {
+				ast_log(LOG_WARNING, "Invalid reminder '%s' provided\n", opt_args[AST_PARK_ARG_REMINDER]);
+				args.reminder = 0;
+			}
+		}
 
 		if (!ast_strlen_zero(app_args.pl_name)) {
 			/* Find the specified exclusive parking lot */
@@ -1871,6 +1980,8 @@
 	if (args.parkinglot) {
 		parkinglot_unref(args.parkinglot);
 	}
+	ast_free(parse);
+
 	return res;
 }
 
@@ -1974,9 +2085,11 @@
 int ast_masq_park_call_exten(struct ast_channel *park_me, struct ast_channel *parker, const char *park_exten, const char *park_context, int timeout, int *extout)
 {
 	int res;
-	char *parse;
+	struct ast_str *parse;
 	const char *app_data;
 	struct ast_exten *exten;
+	struct ast_flags opts = { 0, };
+	char *opt_args[AST_PARK_ARG_ARRAY_SIZE];
 	struct park_app_args app_args;
 	struct ast_park_call_args args = {
 		.timeout = timeout,
@@ -1989,6 +2102,10 @@
 	if (!park_exten || !park_context) {
 		return masq_park_call(park_me, parker, &args);
 	}
+	if (!(parse = ast_str_create(32))) {
+		ast_log(LOG_WARNING, "Unable to allocate string for variable substitution\n");
+		return -1;
+	}
 
 	/*
 	 * Determiine if the specified park extension has an exclusive
@@ -2003,8 +2120,37 @@
 		if (!app_data) {
 			app_data = "";
 		}
-		parse = ast_strdupa(app_data);
-		AST_STANDARD_APP_ARGS(app_args, parse);
+		ast_str_substitute_variables(&parse, 0, park_me, app_data);
+		AST_STANDARD_APP_ARGS(app_args, ast_str_buffer(parse));
+
+		if (!ast_strlen_zero(app_args.timeout)) {
+			if (ast_app_parse_timelen(app_args.timeout, &args.timeout, TIMELEN_SECONDS)) {
+				ast_log(LOG_WARNING, "Invalid timeout '%s' provided\n", app_args.timeout);
+				args.timeout = 0;
+			}
+		}
+		if (!ast_strlen_zero(app_args.return_con)) {
+			args.return_con = app_args.return_con;
+		}
+		if (!ast_strlen_zero(app_args.return_ext)) {
+			args.return_ext = app_args.return_ext;
+		}
+		if (!ast_strlen_zero(app_args.return_pri)) {
+			if (sscanf(app_args.return_pri, "%30d", &args.return_pri) != 1) {
+				ast_log(LOG_WARNING, "Invalid priority '%s' specified\n", app_args.return_pri);
+				args.return_pri = 0;
+			}
+		}
+
+		ast_app_parse_options(park_call_options, &opts, opt_args, app_args.options);
+		ast_copy_flags(&args, &opts, AST_PARK_OPT_RINGING | AST_PARK_OPT_RANDOMIZE | AST_PARK_OPT_SILENCE);
+
+		if (ast_test_flag(&opts, AST_PARK_OPT_REMINDER) && !ast_strlen_zero(opt_args[AST_PARK_ARG_REMINDER])) {
+			if (ast_app_parse_timelen(opt_args[AST_PARK_ARG_REMINDER], &args.reminder, TIMELEN_SECONDS)) {
+				ast_log(LOG_WARNING, "Invalid reminder '%s' provided\n", opt_args[AST_PARK_ARG_REMINDER]);
+				args.reminder = 0;
+			}
+		}
 
 		if (!ast_strlen_zero(app_args.pl_name)) {
 			/* Find the specified exclusive parking lot */
@@ -2022,6 +2168,8 @@
 	if (args.parkinglot) {
 		parkinglot_unref(args.parkinglot);
 	}
+	ast_free(parse);
+
 	return res;
 }
 
@@ -3346,7 +3494,9 @@
 	 * instead of handling each one manually.
 	 * */
 	unsigned int parkingtime;
+	unsigned int remindertime;
 	unsigned int parkingtime_is_set:1;
+	unsigned int remindertime_is_set:1;
 };
 
 static void feature_ds_destroy(void *data)
@@ -5020,6 +5170,7 @@
 	struct ast_channel *chan = pu->chan;	/* shorthand */
 	int tms;        /* timeout for this item */
 	int x;          /* fd index in channel */
+	struct ast_event *event;
 
 	tms = ast_tvdiff_ms(ast_tvnow(), pu->start);
 	if (tms > pu->parkingtime) {
@@ -5059,51 +5210,6 @@
 				}
 			}
 
-			if (!ast_context_find_or_create(NULL, NULL, parking_con_dial, registrar)) {
-				ast_log(LOG_ERROR,
-					"Parking dial context '%s' does not exist and unable to create\n",
-					parking_con_dial);
-			} else {
-				char returnexten[AST_MAX_EXTENSION];
-				char comebackdialtime[AST_MAX_EXTENSION];
-				struct ast_datastore *features_datastore;
-				struct ast_dial_features *dialfeatures;
-
-				if (!strncmp(peername, "Parked/", 7)) {
-					peername += 7;
-				}
-
-				ast_channel_lock(chan);
-				features_datastore = ast_channel_datastore_find(chan, &dial_features_info,
-					NULL);
-				if (features_datastore && (dialfeatures = features_datastore->data)) {
-					char buf[MAX_DIAL_FEATURE_OPTIONS] = {0,};
-
-					snprintf(returnexten, sizeof(returnexten), "%s,%u,%s", peername,
-						pu->parkinglot->cfg.comebackdialtime,
-						callback_dialoptions(&dialfeatures->peer_features,
-							&dialfeatures->my_features, buf, sizeof(buf)));
-				} else { /* Existing default */
-					ast_log(LOG_NOTICE, "Dial features not found on %s, using default!\n",
-						ast_channel_name(chan));
-					snprintf(returnexten, sizeof(returnexten), "%s,%u,t", peername,
-						pu->parkinglot->cfg.comebackdialtime);
-				}
-				ast_channel_unlock(chan);
-
-				snprintf(comebackdialtime, sizeof(comebackdialtime), "%u",
-						pu->parkinglot->cfg.comebackdialtime);
-				pbx_builtin_setvar_helper(chan, "COMEBACKDIALTIME", comebackdialtime);
-
-				pbx_builtin_setvar_helper(chan, "PARKER", peername);
-
-				if (ast_add_extension(parking_con_dial, 1, peername_flat, 1, NULL, NULL,
-					"Dial", ast_strdup(returnexten), ast_free_ptr, registrar)) {
-					ast_log(LOG_ERROR,
-						"Could not create parking return dial exten: %s@%s\n",
-						peername_flat, parking_con_dial);
-				}
-			}
 			if (pu->options_specified) {
 				/*
 				 * Park() was called with overriding return arguments, respect
@@ -5111,6 +5217,52 @@
 				 */
 				set_c_e_p(chan, pu->context, pu->exten, pu->priority);
 			} else if (pu->parkinglot->cfg.comebacktoorigin) {
+				if (!ast_context_find_or_create(NULL, NULL, parking_con_dial, registrar)) {
+					ast_log(LOG_ERROR,
+						"Parking dial context '%s' does not exist and unable to create\n",
+						parking_con_dial);
+				} else {
+					char returnexten[AST_MAX_EXTENSION];
+					char comebackdialtime[AST_MAX_EXTENSION];
+					struct ast_datastore *features_datastore;
+					struct ast_dial_features *dialfeatures;
+
+					if (!strncmp(peername, "Parked/", 7)) {
+						peername += 7;
+					}
+
+					ast_channel_lock(chan);
+					features_datastore = ast_channel_datastore_find(chan, &dial_features_info,
+						NULL);
+					if (features_datastore && (dialfeatures = features_datastore->data)) {
+						char buf[MAX_DIAL_FEATURE_OPTIONS] = {0,};
+
+						snprintf(returnexten, sizeof(returnexten), "%s,%u,%s", peername,
+							pu->parkinglot->cfg.comebackdialtime,
+							callback_dialoptions(&dialfeatures->peer_features,
+								&dialfeatures->my_features, buf, sizeof(buf)));
+					} else { /* Existing default */
+						ast_log(LOG_NOTICE, "Dial features not found on %s, using default!\n",
+							ast_channel_name(chan));
+						snprintf(returnexten, sizeof(returnexten), "%s,%u,t", peername,
+							pu->parkinglot->cfg.comebackdialtime);
+					}
+					ast_channel_unlock(chan);
+
+					snprintf(comebackdialtime, sizeof(comebackdialtime), "%u",
+							pu->parkinglot->cfg.comebackdialtime);
+					pbx_builtin_setvar_helper(chan, "COMEBACKDIALTIME", comebackdialtime);
+
+					pbx_builtin_setvar_helper(chan, "PARKER", peername);
+
+					if (ast_add_extension(parking_con_dial, 1, peername_flat, 1, NULL, NULL,
+						"Dial", ast_strdup(returnexten), ast_free_ptr, registrar)) {
+						ast_log(LOG_ERROR,
+							"Could not create parking return dial exten: %s@%s\n",
+							peername_flat, parking_con_dial);
+					}
+				}
+
 				set_c_e_p(chan, parking_con_dial, peername_flat, 1);
 			} else {
 				char parkingslot[AST_MAX_EXTENSION];
@@ -5142,8 +5294,20 @@
 			 */
 			set_c_e_p(chan, pu->context, pu->exten, pu->priority);
 		}
-		post_manager_event("ParkedCallTimeOut", pu);
+
+		if ((event = ast_event_new(AST_EVENT_PARKED_CALL,
+					AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_TIMEOUT,
+					AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, pu->parkingnum,
+					AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, pu->context,
+					AST_EVENT_IE_CIDNUM, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.number.valid, ast_channel_caller(pu->chan)->id.number.str, ""),
+					AST_EVENT_IE_CIDNAME, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.name.valid, ast_channel_caller(pu->chan)->id.name.str, ""),
+					AST_EVENT_IE_END))) {
+			ast_event_queue_and_cache(event);
+		}
 		ast_cel_report_event(pu->chan, AST_CEL_PARK_END, NULL, "ParkedCallTimeOut", NULL);
+		post_manager_event("ParkedCallTimeOut", pu);
 
 		ast_verb(2, "Timeout for %s parked on %d (%s). Returning to %s,%s,%d\n",
 			ast_channel_name(pu->chan), pu->parkingnum, pu->parkinglot->name, ast_channel_context(pu->chan),
@@ -5202,9 +5366,20 @@
 				if (f) {
 					ast_frfree(f);
 				}
+
+				if ((event = ast_event_new(AST_EVENT_PARKED_CALL,
+							AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_HANGUP,
+							AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, pu->parkingnum,
+							AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, pu->context,
+							AST_EVENT_IE_CIDNUM, AST_EVENT_IE_PLTYPE_STR,
+								S_COR(ast_channel_caller(pu->chan)->id.number.valid, ast_channel_caller(pu->chan)->id.number.str, ""),
+							AST_EVENT_IE_CIDNAME, AST_EVENT_IE_PLTYPE_STR,
+								S_COR(ast_channel_caller(pu->chan)->id.name.valid, ast_channel_caller(pu->chan)->id.name.str, ""),
+							AST_EVENT_IE_END))) {
+					ast_event_queue_and_cache(event);
+				}
+				ast_cel_report_event(pu->chan, AST_CEL_PARK_END, NULL, "ParkedCallGiveUp", NULL);
 				post_manager_event("ParkedCallGiveUp", pu);
-				ast_cel_report_event(pu->chan, AST_CEL_PARK_END, NULL, "ParkedCallGiveUp",
-					NULL);
 
 				/* There's a problem, hang them up */
 				ast_verb(2, "%s got tired of being parked\n", ast_channel_name(chan));
@@ -5232,6 +5407,21 @@
 		} /* End for */
 	}
 
+	if (pu->remindertime && tms > pu->remindertime && !pu->sentreminder) {
+		if ((event = ast_event_new(AST_EVENT_PARKED_CALL,
+					AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_REMINDER,
+					AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, pu->parkingnum,
+					AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, pu->context,
+					AST_EVENT_IE_CIDNUM, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.number.valid, ast_channel_caller(pu->chan)->id.number.str, ""),
+					AST_EVENT_IE_CIDNAME, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.name.valid, ast_channel_caller(pu->chan)->id.name.str, ""),
+					AST_EVENT_IE_END))) {
+			ast_event_queue_and_cache(event);
+		}
+		pu->sentreminder = 1;
+	}
+
 	/* mark fds for next round */
 	for (x = 0; x < AST_MAX_FDS; x++) {
 		if (ast_channel_fd_isset(chan, x)) {
@@ -5374,17 +5564,12 @@
 	return copylot;
 }
 
-AST_APP_OPTIONS(park_call_options, BEGIN_OPTIONS
-	AST_APP_OPTION('r', AST_PARK_OPT_RINGING),
-	AST_APP_OPTION('R', AST_PARK_OPT_RANDOMIZE),
-	AST_APP_OPTION('s', AST_PARK_OPT_SILENCE),
-END_OPTIONS );
-
 /*! \brief Park a call */
 static int park_call_exec(struct ast_channel *chan, const char *data)
 {
 	struct ast_park_call_args args = { 0, };
-	struct ast_flags flags = { 0 };
+	struct ast_flags opts = { 0 };
+	char *opt_args[AST_PARK_ARG_ARRAY_SIZE];
 	char orig_exten[AST_MAX_EXTENSION];
 	int orig_priority;
 	int res;
@@ -5422,7 +5607,7 @@
 	AST_STANDARD_APP_ARGS(app_args, parse);
 
 	if (!ast_strlen_zero(app_args.timeout)) {
-		if (sscanf(app_args.timeout, "%30d", &args.timeout) != 1) {
+		if (ast_app_parse_timelen(app_args.timeout, &args.timeout, TIMELEN_SECONDS)) {
 			ast_log(LOG_WARNING, "Invalid timeout '%s' provided\n", app_args.timeout);
 			args.timeout = 0;
 		}
@@ -5440,8 +5625,15 @@
 		}
 	}
 
-	ast_app_parse_options(park_call_options, &flags, NULL, app_args.options);
-	args.flags = flags.flags;
+	ast_app_parse_options(park_call_options, &opts, opt_args, app_args.options);
+	ast_copy_flags(&args, &opts, AST_PARK_OPT_RINGING | AST_PARK_OPT_RANDOMIZE | AST_PARK_OPT_SILENCE);
+
+	if (ast_test_flag(&opts, AST_PARK_OPT_REMINDER) && !ast_strlen_zero(opt_args[AST_PARK_ARG_REMINDER])) {
+		if (ast_app_parse_timelen(opt_args[AST_PARK_ARG_REMINDER], &args.reminder, TIMELEN_SECONDS)) {
+			ast_log(LOG_WARNING, "Invalid reminder '%s' provided\n", opt_args[AST_PARK_ARG_REMINDER]);
+			args.reminder = 0;
+		}
+	}
 
 	/*
 	 * Setup the exten/priority to be s/1 since we don't know where
@@ -5502,6 +5694,7 @@
 	unsigned int park = 0;
 	struct ast_bridge_config config;
 	struct ast_parkinglot *parkinglot;
+	struct ast_event *event;
 	AST_DECLARE_APP_ARGS(app_args,
 		AST_APP_ARG(pl_space);	/*!< Parking lot space to retrieve if present. */
 		AST_APP_ARG(pl_name);	/*!< Parking lot name to use if present. */
@@ -5578,6 +5771,17 @@
 			ast_log(LOG_WARNING, "Whoa, no parking context?\n");
 		}
 
+		if ((event = ast_event_new(AST_EVENT_PARKED_CALL,
+					AST_EVENT_IE_STATE, AST_EVENT_IE_PLTYPE_UINT, AST_PARKED_CALL_RETRIEVED,
+					AST_EVENT_IE_EXTEN, AST_EVENT_IE_PLTYPE_UINT, pu->parkingnum,
+					AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, pu->context,
+					AST_EVENT_IE_CIDNUM, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.number.valid, ast_channel_caller(pu->chan)->id.number.str, ""),
+					AST_EVENT_IE_CIDNAME, AST_EVENT_IE_PLTYPE_STR,
+						S_COR(ast_channel_caller(pu->chan)->id.name.valid, ast_channel_caller(pu->chan)->id.name.str, ""),
+					AST_EVENT_IE_END))) {
+			ast_event_queue_and_cache(event);
+		}
 		ast_cel_report_event(pu->chan, AST_CEL_PARK_END, NULL, "UnParkedCall", chan);
 		/*** DOCUMENTATION
 			<managerEventInstance>
@@ -5848,7 +6052,8 @@
 	.parking_con = "parkedcalls",
 	.parking_start = 701,
 	.parking_stop = 750,
-	.parkingtime = DEFAULT_PARK_TIME,
+	.parkingtime = DEFAULT_PARKING_TIME,
+	.remindertime = DEFAULT_REMINDER_TIME,
 	.comebackdialtime = DEFAULT_COMEBACK_DIAL_TIME,
 	.comebackcontext = DEFAULT_COMEBACK_CONTEXT,
 	.comebacktoorigin = DEFAULT_COMEBACK_TO_ORIGIN,
@@ -5857,7 +6062,8 @@
 /*! Default configuration for normal parking lots. */
 static const struct parkinglot_cfg parkinglot_cfg_default = {
 	.parkext = DEFAULT_PARK_EXTENSION,
-	.parkingtime = DEFAULT_PARK_TIME,
+	.parkingtime = DEFAULT_PARKING_TIME,
+	.remindertime = DEFAULT_REMINDER_TIME,
 	.comebackdialtime = DEFAULT_COMEBACK_DIAL_TIME,
 	.comebackcontext = DEFAULT_COMEBACK_CONTEXT,
 	.comebacktoorigin = DEFAULT_COMEBACK_TO_ORIGIN,
@@ -5920,6 +6126,15 @@
 			} else {
 				cfg->parkingtime = parkingtime * 1000;
 			}
+		} else if (!strcasecmp(var->name, "remindertime")) {
+			unsigned int remindertime = 0;
+
+			if ((sscanf(var->value, "%30u", &remindertime) != 1)) {
+				ast_log(LOG_WARNING, "%s is not a valid remindertime\n", var->value);
+				error = -1;
+			} else {
+				cfg->remindertime = remindertime * 1000;
+			}
 		} else if (!strcasecmp(var->name, "parkpos")) {
 			int start = 0;
 			int end = 0;
@@ -6347,7 +6562,7 @@
 	ctg = NULL;
 	while ((ctg = ast_category_browse(cfg, ctg))) {
 		/* Is this a parkinglot definition ? */
-		if (!strncasecmp(ctg, "parkinglot_", strlen("parkinglot_"))) {
+		if (strcasecmp(ctg, "general") && ast_variable_retrieve(cfg, ctg, "parkext") && ast_variable_retrieve(cfg, ctg, "parkpos")) {
 			ast_debug(2, "Found configuration section %s, assume parking context\n", ctg);
 			if (!build_parkinglot(ctg, ast_variable_browse(cfg, ctg))) {
 				ast_log(LOG_ERROR, "Could not build parking lot %s. Configuration error.\n", ctg);
@@ -8719,7 +8934,7 @@
 	struct ast_channel *parked_chan = NULL;
 	struct ast_parkinglot *dynlot;
 	struct ast_park_call_args args = {
-		.timeout = DEFAULT_PARK_TIME,
+		.timeout = DEFAULT_PARKING_TIME,
 	};
 
 	int res = 0;
@@ -8875,19 +9090,23 @@
  * \internal
  * \brief Get parkingtime for a channel
  */
-static unsigned int get_parkingtime(struct ast_channel *chan, struct ast_parkinglot *parkinglot)
+static void get_parkingtime(struct ast_channel *chan, struct ast_parkinglot *parkinglot, unsigned int *parkingtime, unsigned int *remindertime)
 {
 	const char *parkinglot_name;
 	struct feature_ds *feature_ds;
-	unsigned int parkingtime;
 
 	ast_channel_lock(chan);
 
 	feature_ds = get_feature_ds(chan);
-	if (feature_ds && feature_ds->parkingtime_is_set) {
-		parkingtime = feature_ds->parkingtime;
+	if (feature_ds && (feature_ds->parkingtime_is_set || feature_ds->remindertime_is_set)) {
+		if (parkingtime && feature_ds->parkingtime_is_set) {
+			*parkingtime = feature_ds->parkingtime;
+		}
+		if (remindertime && feature_ds->remindertime_is_set) {
+			*remindertime = feature_ds->remindertime;
+		}
 		ast_channel_unlock(chan);
-		return parkingtime;
+		return;
 	}
 
 	parkinglot_name = ast_strdupa(S_OR(ast_channel_parkinglot(chan), ""));
@@ -8907,11 +9126,14 @@
 		parkinglot_addref(parkinglot);
 	}
 
-	parkingtime = parkinglot->cfg.parkingtime;
+	if (parkingtime) {
+		*parkingtime = parkinglot->cfg.parkingtime;
+	}
+	if (remindertime) {
+		*remindertime = parkinglot->cfg.remindertime;
+	}
 
 	parkinglot_unref(parkinglot);
-
-	return parkingtime;
 }
 
 static int feature_read(struct ast_channel *chan, const char *cmd, char *data,
@@ -8925,7 +9147,15 @@
 	}
 
 	if (!strcasecmp(data, "parkingtime")) {
-		snprintf(buf, len, "%u", get_parkingtime(chan, NULL) / 1000);
+		unsigned int parkingtime;
+
+		get_parkingtime(chan, NULL, &parkingtime, NULL);
+		snprintf(buf, len, "%u", parkingtime / 1000);
+	} else if (!strcasecmp(data, "remindertime")) {
+		unsigned int remindertime;
+
+		get_parkingtime(chan, NULL, NULL, &remindertime);
+		snprintf(buf, len, "%u", remindertime / 1000);
 	} else {
 		ast_log(LOG_WARNING, "Invalid argument '%s' to FEATURE()\n", data);
 		res = -1;
@@ -8961,6 +9191,15 @@
 			feature_ds->parkingtime_is_set = 0;
 			res = -1;
 		}
+	} else if (!strcasecmp(data, "remindertime")) {
+		feature_ds->remindertime_is_set = 1;
+		if (sscanf(value, "%30u", &feature_ds->remindertime) == 1) {
+			feature_ds->remindertime *= 1000; /* stored in ms */
+		} else {
+			ast_log(LOG_WARNING, "'%s' is not a valid remindertime\n", value);
+			feature_ds->remindertime_is_set = 0;
+			res = -1;
+		}
 	} else {
 		ast_log(LOG_WARNING, "Invalid argument '%s' to FEATURE()\n", data);
 		res = -1;
@@ -9053,6 +9292,9 @@
 {
 	ast_cli_unregister_multiple(cli_features, ARRAY_LEN(cli_features));
 	ast_devstate_prov_del("Park");
+	if (parking_event_sub) {
+		parking_event_sub = ast_event_unsubscribe(parking_event_sub);
+	}
 	ast_custom_function_unregister(&featuremap_function);
 	ast_custom_function_unregister(&feature_function);
 	ast_manager_unregister("Bridge");
@@ -9104,6 +9346,12 @@
 	res |= __ast_custom_function_register(&featuremap_function, NULL);
 
 	res |= ast_devstate_prov_add("Park", metermaidstate);
+	if (!res) {
+		if (!(parking_event_sub = ast_event_subscribe(AST_EVENT_PARKED_CALL, parking_event_cb,
+			"features Park event", NULL, AST_EVENT_IE_END))) {
+			res = -1;
+		}
+	}
 #if defined(TEST_FRAMEWORK)
 	res |= AST_TEST_REGISTER(features_test);
 #endif	/* defined(TEST_FRAMEWORK) */
diff -durN asterisk-11.17.1.orig/main/pbx.c asterisk-11.17.1/main/pbx.c
--- asterisk-11.17.1.orig/main/pbx.c	2015-05-01 14:15:02.316639326 +1200
+++ asterisk-11.17.1/main/pbx.c	2015-05-01 14:15:13.952387043 +1200
@@ -7564,9 +7564,12 @@
 /*! \brief  handle_show_hints: CLI support for listing registered dial plan hints */
 static char *handle_show_hints(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
+#define FORMAT  "%-25.25s %-31.31s %-15.15s %-15.15s %-8.8s\n"
+#define FORMAT2 "%-25.25s %-31.31s %-15.15s %-15.15s %-2d\n"
 	struct ast_hint *hint;
 	int num = 0;
 	int watchers;
+	char exten_context[32];
 	struct ao2_iterator i;
 
 	switch (cmd) {
@@ -7590,7 +7593,7 @@
 		return CLI_SUCCESS;
 	}
 	/* ... we have hints ... */
-	ast_cli(a->fd, "\n    -= Registered Asterisk Dial Plan Hints =-\n");
+	ast_cli(a->fd, FORMAT, "Location", "Hints", "DeviceState", "PresenceState", "Watchers");
 
 	i = ao2_iterator_init(hints, 0);
 	for (; (hint = ao2_iterator_next(&i)); ao2_ref(hint, -1)) {
@@ -7600,20 +7603,23 @@
 			ao2_unlock(hint);
 			continue;
 		}
+		snprintf(exten_context, sizeof(exten_context), "%s@%s", ast_get_extension_name(hint->exten), ast_get_context_name(ast_get_extension_context(hint->exten)));
 		watchers = ao2_container_count(hint->callbacks);
-		ast_cli(a->fd, "   %20s@%-20.20s: %-20.20s  State:%-15.15s Watchers %2d\n",
-			ast_get_extension_name(hint->exten),
-			ast_get_context_name(ast_get_extension_context(hint->exten)),
+		ast_cli(a->fd, FORMAT2,
+			exten_context, 
 			ast_get_extension_app(hint->exten),
-			ast_extension_state2str(hint->laststate), watchers);
+			ast_extension_state2str(hint->laststate),
+			ast_presence_state2str(hint->last_presence_state),
+			watchers);
 		ao2_unlock(hint);
 		num++;
 	}
 	ao2_iterator_destroy(&i);
 
-	ast_cli(a->fd, "----------------\n");
-	ast_cli(a->fd, "- %d hints registered\n", num);
+	ast_cli(a->fd, "%d hints registered\n", num);
 	return CLI_SUCCESS;
+#undef FORMAT
+#undef FORMAT2
 }
 
 /*! \brief autocomplete for CLI command 'core show hint' */
diff -durN asterisk-11.17.1.orig/main/presencestate.c asterisk-11.17.1/main/presencestate.c
--- asterisk-11.17.1.orig/main/presencestate.c	2015-05-01 14:15:02.312639413 +1200
+++ asterisk-11.17.1/main/presencestate.c	2015-05-01 14:15:13.952387043 +1200
@@ -44,13 +44,13 @@
 	enum ast_presence_state state;
 
 } state2string[] = {
-	{ "not_set", AST_PRESENCE_NOT_SET},
-	{ "unavailable", AST_PRESENCE_UNAVAILABLE },
-	{ "available", AST_PRESENCE_AVAILABLE},
-	{ "away", AST_PRESENCE_AWAY},
-	{ "xa", AST_PRESENCE_XA},
-	{ "chat", AST_PRESENCE_CHAT},
-	{ "dnd", AST_PRESENCE_DND},
+	{ "Not_Set", AST_PRESENCE_NOT_SET},
+	{ "Unavailable", AST_PRESENCE_UNAVAILABLE },
+	{ "Available", AST_PRESENCE_AVAILABLE},
+	{ "Away", AST_PRESENCE_AWAY},
+	{ "XA", AST_PRESENCE_XA},
+	{ "Chat", AST_PRESENCE_CHAT},
+	{ "DND", AST_PRESENCE_DND},
 };
 
 /*! \brief Flag for the queue */
@@ -129,6 +129,7 @@
 static enum ast_presence_state ast_presence_state_helper(const char *presence_provider, char **subtype, char **message, int check_cache)
 {
 	struct presence_state_provider *provider;
+	const struct ast_channel_tech *chan_tech;
 	char *address;
 	char *label = ast_strdupa(presence_provider);
 	int res = AST_PRESENCE_INVALID;
@@ -140,6 +141,17 @@
 		}
 	}
 
+	if ((address = strchr(label, '/'))) {
+		*address = '\0';
+		address++;
+
+		if ((chan_tech = ast_get_channel_tech(label)) && chan_tech->presencestate) {
+			res = chan_tech->presencestate(address, subtype, message);
+		}
+
+		return res;
+	}
+
 	if ((address = strchr(label, ':'))) {
 		*address = '\0';
 		address++;
