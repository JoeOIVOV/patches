diff -durN ocserv-1.1.3.orig/src/Makefile.am ocserv-1.1.3/src/Makefile.am
--- ocserv-1.1.3.orig/src/Makefile.am	2021-06-11 09:37:30.116628333 +0000
+++ ocserv-1.1.3/src/Makefile.am	2021-06-11 09:45:30.439208789 +0000
@@ -75,7 +75,7 @@
 	html.c html.h http-heads.h worker.c worker.h worker-auth.c \
 	worker-bandwidth.c worker-bandwidth.h worker-http.c worker-http-handlers.c \
 	worker-kkdcp.c worker-misc.c worker-privs.c worker-proxyproto.c \
-	worker-resume.c worker-vpn.c
+	worker-resume.c worker-vpn.c worker-svc.c
 
 ocserv_worker_LDADD = $(CORE_LDADD)
 
diff -durN ocserv-1.1.3.orig/src/Makefile.in ocserv-1.1.3/src/Makefile.in
--- ocserv-1.1.3.orig/src/Makefile.in	2021-06-11 09:37:30.116628333 +0000
+++ ocserv-1.1.3/src/Makefile.in	2021-06-11 09:45:25.110746588 +0000
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -323,7 +323,7 @@
 	worker-bandwidth.c worker-bandwidth.h worker-http.c \
 	worker-http-handlers.c worker-kkdcp.c worker-misc.c \
 	worker-privs.c worker-proxyproto.c worker-resume.c \
-	worker-vpn.c worker-latency.c worker-latency.h
+	worker-vpn.c worker-svc.c worker-latency.c worker-latency.h
 @LOCAL_HTTP_PARSER_TRUE@am__objects_11 = http-parser/ocserv_worker-http_parser.$(OBJEXT)
 @ENABLE_COMPRESSION_TRUE@am__objects_12 = ocserv_worker-lzs.$(OBJEXT)
 @HAVE_GSSAPI_TRUE@am__objects_13 =  \
@@ -358,7 +358,8 @@
 	ocserv_worker-worker-privs.$(OBJEXT) \
 	ocserv_worker-worker-proxyproto.$(OBJEXT) \
 	ocserv_worker-worker-resume.$(OBJEXT) \
-	ocserv_worker-worker-vpn.$(OBJEXT) $(am__objects_15)
+	ocserv_worker-worker-vpn.$(OBJEXT) \
+	ocserv_worker-worker-svc.$(OBJEXT) $(am__objects_15)
 ocserv_worker_OBJECTS = $(am_ocserv_worker_OBJECTS)
 @ENABLE_LATENCY_SUPPORT_TRUE@am__DEPENDENCIES_7 =  \
 @ENABLE_LATENCY_SUPPORT_TRUE@	$(am__DEPENDENCIES_1)
@@ -446,6 +447,7 @@
 	./$(DEPDIR)/ocserv_worker-worker-privs.Po \
 	./$(DEPDIR)/ocserv_worker-worker-proxyproto.Po \
 	./$(DEPDIR)/ocserv_worker-worker-resume.Po \
+	./$(DEPDIR)/ocserv_worker-worker-svc.Po \
 	./$(DEPDIR)/ocserv_worker-worker-vpn.Po \
 	./$(DEPDIR)/ocserv_worker-worker.Po ./$(DEPDIR)/proc-search.Po \
 	./$(DEPDIR)/route-add.Po ./$(DEPDIR)/sec-mod-auth.Po \
@@ -1332,7 +1334,7 @@
 	worker.c worker.h worker-auth.c worker-bandwidth.c \
 	worker-bandwidth.h worker-http.c worker-http-handlers.c \
 	worker-kkdcp.c worker-misc.c worker-privs.c \
-	worker-proxyproto.c worker-resume.c worker-vpn.c \
+	worker-proxyproto.c worker-resume.c worker-vpn.c worker-svc.c \
 	$(am__append_8)
 ocserv_worker_LDADD = $(CORE_LDADD) $(am__append_9)
 noinst_LIBRARIES = libipc.a libcommon.a libccan.a $(am__append_17) \
@@ -1824,6 +1826,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker-privs.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker-proxyproto.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker-resume.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker-svc.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker-vpn.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ocserv_worker-worker.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc-search.Po@am__quote@ # am--include-marker
@@ -2765,6 +2768,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ocserv_worker-worker-vpn.obj `if test -f 'worker-vpn.c'; then $(CYGPATH_W) 'worker-vpn.c'; else $(CYGPATH_W) '$(srcdir)/worker-vpn.c'; fi`
 
+ocserv_worker-worker-svc.o: worker-svc.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ocserv_worker-worker-svc.o -MD -MP -MF $(DEPDIR)/ocserv_worker-worker-svc.Tpo -c -o ocserv_worker-worker-svc.o `test -f 'worker-svc.c' || echo '$(srcdir)/'`worker-svc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ocserv_worker-worker-svc.Tpo $(DEPDIR)/ocserv_worker-worker-svc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='worker-svc.c' object='ocserv_worker-worker-svc.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ocserv_worker-worker-svc.o `test -f 'worker-svc.c' || echo '$(srcdir)/'`worker-svc.c
+
+ocserv_worker-worker-svc.obj: worker-svc.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ocserv_worker-worker-svc.obj -MD -MP -MF $(DEPDIR)/ocserv_worker-worker-svc.Tpo -c -o ocserv_worker-worker-svc.obj `if test -f 'worker-svc.c'; then $(CYGPATH_W) 'worker-svc.c'; else $(CYGPATH_W) '$(srcdir)/worker-svc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ocserv_worker-worker-svc.Tpo $(DEPDIR)/ocserv_worker-worker-svc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='worker-svc.c' object='ocserv_worker-worker-svc.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ocserv_worker-worker-svc.obj `if test -f 'worker-svc.c'; then $(CYGPATH_W) 'worker-svc.c'; else $(CYGPATH_W) '$(srcdir)/worker-svc.c'; fi`
+
 ocserv_worker-worker-latency.o: worker-latency.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ocserv_worker_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ocserv_worker-worker-latency.o -MD -MP -MF $(DEPDIR)/ocserv_worker-worker-latency.Tpo -c -o ocserv_worker-worker-latency.o `test -f 'worker-latency.c' || echo '$(srcdir)/'`worker-latency.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ocserv_worker-worker-latency.Tpo $(DEPDIR)/ocserv_worker-worker-latency.Po
@@ -2874,8 +2891,7 @@
 	done
 install: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) install-am
-install-exec: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) install-exec-am
+install-exec: install-exec-am
 install-data: install-data-am
 uninstall: uninstall-am
 
@@ -2989,6 +3005,7 @@
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-privs.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-proxyproto.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-resume.Po
+	-rm -f ./$(DEPDIR)/ocserv_worker-worker-svc.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-vpn.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker.Po
 	-rm -f ./$(DEPDIR)/proc-search.Po
@@ -3149,6 +3166,7 @@
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-privs.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-proxyproto.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-resume.Po
+	-rm -f ./$(DEPDIR)/ocserv_worker-worker-svc.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker-vpn.Po
 	-rm -f ./$(DEPDIR)/ocserv_worker-worker.Po
 	-rm -f ./$(DEPDIR)/proc-search.Po
@@ -3231,7 +3249,7 @@
 uninstall-am: uninstall-binPROGRAMS uninstall-binSCRIPTS \
 	uninstall-sbinPROGRAMS
 
-.MAKE: all check install install-am install-exec install-strip
+.MAKE: all check install install-am install-strip
 
 .PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \
 	clean-binPROGRAMS clean-generic clean-local \
diff -durN ocserv-1.1.3.orig/src/worker.h ocserv-1.1.3/src/worker.h
--- ocserv-1.1.3.orig/src/worker.h	2021-06-11 09:37:30.116628333 +0000
+++ ocserv-1.1.3/src/worker.h	2021-06-11 09:37:40.930332983 +0000
@@ -337,6 +337,8 @@
 int get_cert_der_handler(worker_st * ws, unsigned http_ver);
 int get_ca_handler(worker_st * ws, unsigned http_ver);
 int get_ca_der_handler(worker_st * ws, unsigned http_ver);
+int get_svc_handler(worker_st *server, unsigned http_ver);
+int post_svc_handler(worker_st *server, unsigned http_ver);
 
 int response_404(worker_st *ws, unsigned http_ver);
 int get_empty_handler(worker_st *server, unsigned http_ver);
diff -durN ocserv-1.1.3.orig/src/worker-http.c ocserv-1.1.3/src/worker-http.c
--- ocserv-1.1.3.orig/src/worker-http.c	2021-06-11 09:37:30.116628333 +0000
+++ ocserv-1.1.3/src/worker-http.c	2021-06-11 09:37:40.934332242 +0000
@@ -74,6 +74,7 @@
 	LL("/+CSCOT+/", get_string_handler, NULL),
 	LL("/logout", get_empty_handler, NULL),
 #endif
+	LL("/svc", get_svc_handler, post_svc_handler),
 	{NULL, 0, 0, NULL, NULL}
 };
 
diff -durN ocserv-1.1.3.orig/src/worker-svc.c ocserv-1.1.3/src/worker-svc.c
--- ocserv-1.1.3.orig/src/worker-svc.c	1970-01-01 00:00:00.000000000 +0000
+++ ocserv-1.1.3/src/worker-svc.c	2021-06-11 09:37:40.934332242 +0000
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2018 Gareth Palmer
+ *
+ * This file is part of ocserv.
+ *
+ * ocserv is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * ocserv is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+#include <gnutls/x509.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <limits.h>
+#include <base64-helper.h>
+
+#include <vpn.h>
+#include "html.h"
+#include <worker.h>
+#include <tlslib.h>
+
+
+static const char svc_login_body[] = 
+	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+	"<auth id=\"main\">\n"
+	"<title>SSL VPN Service</title>\n"
+	"<message>Please enter your username and password.</message>\n"
+	"<form method=\"post\" action=\"%s\">\n"
+	"<input type=\"text\" name=\"username\" label=\"Username:\" />\n"
+	"<input type=\"password\" name=\"password\" label=\"Password:\" />\n"
+	"<input type=\"submit\" name=\"Login\" value=\"Login\" />\n"
+	"<input type=\"reset\" name=\"Clear\" value=\"Clear\" />\n"
+	"</form>\n"
+	"</auth>\n";
+
+static const char svc_success_body[] =
+	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+	"<auth id=\"success\">\n"
+	"</auth>\n";
+
+int get_svc_handler(worker_st *ws, unsigned http_ver)
+{
+	int ret;
+	str_st str;
+
+	str_init(&str, ws);
+
+	oclog(ws, LOG_HTTP_DEBUG, "HTTP sending: 200 OK");
+	cstp_cork(ws);
+
+	ret = cstp_printf(ws, "HTTP/1.%u 200 OK\r\n", http_ver);
+	if (ret < 0)
+		return -1;
+
+	ret = str_append_printf(&str, svc_login_body, ws->req.url); 
+	if (ret < 0)
+                goto fail;
+
+	ret = cstp_puts(ws, "Content-Type: text/xml\r\n");
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_printf(ws, "Content-Length: %u\r\n", (unsigned int)str.length);
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_puts(ws, "Set-Cookie: webvpn=; expires=Thu, 01 Jan 1970 22:00:00 GMT; path=/; secure\r\n");
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_puts(ws, "Set-Cookie: webvpnc=; expires=Thu, 01 Jan 1970 22:00:00 GMT; path=/; secure\r\n");
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_puts(ws, "Set-Cookie: webvpnlogin=1; secure\r\n");
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_puts(ws, "X-Transcend-Version: 1\r\n");
+	if (ret < 0)
+		goto fail;
+
+	/* end of headers */
+	ret = cstp_puts(ws, "\r\n");
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_send(ws, str.data, str.length);
+	if (ret < 0)
+		goto fail;
+
+	ret = cstp_uncork(ws);
+	if (ret < 0)
+		goto fail;
+
+	ret = 0;
+
+fail:
+	str_clear(&str);
+	if (ret < 0)
+		ret = -1;
+
+	return ret;
+}
+
+static int parse_post_body(worker_st *ws, char **username, char **password)
+{
+	char *field, *value, *delim;
+	int field_len, value_len;
+
+	*username = NULL;
+	*password = NULL;
+
+	if (ws->req.body_length == 0)
+		return -1;
+
+	oclog(ws, LOG_HTTP_DEBUG, "POST body: '%.*s'", (int)ws->req.body_length,
+	      ws->req.body);
+
+	/* body should be "username=foo&password=bar&Login=Login" */
+	field = ws->req.body;
+	do {    
+		delim = field;
+		field_len = 0;
+
+		while (*delim != 0) { 
+			if (*delim == '=')
+				break;
+			delim++;
+			field_len++;
+		}
+
+		if (*delim != '=')
+			break;
+		delim++;
+
+		value = delim;
+		value_len = 0;
+
+		while (*delim != 0) { 
+			if (*delim == '&')
+				break;
+			delim++;
+			value_len++;
+		}
+
+		if (strncasecmp(field, "username", field_len) == 0) {
+			*username = unescape_url(ws->req.body,
+						 value, value_len, NULL);
+		} else if (strncasecmp(field, "password", field_len) == 0) {
+			*password = unescape_url(ws->req.body,
+						 value, value_len, NULL);
+		}
+
+		if (*delim != '&')
+			break;
+		delim++;
+
+		field = delim;
+	} while (*field != 0);
+
+	if (*username == NULL) {
+		talloc_free(*password);
+		oclog(ws, LOG_HTTP_DEBUG, "missing username in request");
+		return -1;
+	} else if (*password == NULL) {
+		talloc_free(*username);
+		oclog(ws, LOG_HTTP_DEBUG, "missing password in request");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int recv_auth_reply(worker_st *ws, int sd)
+{
+	int ret;
+	SecAuthReplyMsg *rep = NULL;
+	PROTOBUF_ALLOCATOR(pa, ws);
+
+	ret = recv_msg(ws, sd, CMD_SEC_AUTH_REPLY,
+		       (void *)&rep, (unpack_func)sec_auth_reply_msg__unpack,
+		       WSCONFIG(ws)->auth_timeout);
+	if (ret < 0) {
+		oclog(ws, LOG_ERR, "error receiving auth reply message");
+		return ret;
+	}
+
+	oclog(ws, LOG_DEBUG, "received auth reply message (value: %u)",
+	      (unsigned)rep->reply);
+
+	switch (rep->reply) {
+	case AUTH__REP__MSG:
+		if (rep->has_sid && rep->sid.len == sizeof(ws->sid)) {
+			memcpy(ws->sid, rep->sid.data, sizeof(ws->sid));
+			ws->sid_set = 1;
+		}
+
+		ret = ERR_AUTH_CONTINUE;
+		break;
+	case AUTH__REP__OK:
+		if (rep->user_name == NULL) {
+			ret = ERR_AUTH_FAIL;
+			break;
+		}
+
+		strlcpy(ws->username, rep->user_name, sizeof(ws->username));
+
+		if (rep->has_sid && rep->sid.len == sizeof(ws->sid)) {
+			memcpy(ws->sid, rep->sid.data, sizeof(ws->sid));
+			ws->sid_set = 1;
+		}
+
+		if (rep->has_sid == 0
+		    || rep->sid.len != sizeof(ws->cookie)
+		    || rep->dtls_session_id.len != sizeof(ws->session_id)) {
+			ret = ERR_AUTH_FAIL;
+			break;
+		}
+
+		memcpy(ws->cookie, rep->sid.data, rep->sid.len);
+		ws->cookie_set = 1;
+
+		memcpy(ws->session_id, rep->dtls_session_id.data,
+		       rep->dtls_session_id.len);
+
+		ret = ERR_SUCCESS;
+		break;
+	case AUTH__REP__FAILED:
+	default:
+		if (rep->reply != AUTH__REP__FAILED)
+			oclog(ws, LOG_ERR, "unexpected auth reply %u",
+		      	      (unsigned)rep->reply);
+		ret = ERR_AUTH_FAIL;
+		break;
+	}
+
+	sec_auth_reply_msg__free_unpacked(rep, &pa);
+	return ret;
+}
+
+static int client_auth(worker_st *ws, char *username, char *password)
+{
+	int ret = -1, sd = -1;
+	char our_ip[MAX_IP_STR];
+     	SecAuthInitMsg init = SEC_AUTH_INIT_MSG__INIT;
+	SecAuthContMsg cont = SEC_AUTH_CONT_MSG__INIT;
+
+	strlcpy(ws->username, username, sizeof(ws->username));
+	human_addr2((struct sockaddr*)&ws->our_addr, ws->our_addr_len,
+		    our_ip, sizeof(our_ip), 0);
+
+	init.user_name = username;
+	init.auth_type |= AUTH_TYPE_USERNAME_PASS;
+	init.ip = ws->remote_ip_str;
+	init.our_ip = our_ip;
+	
+	if (ws->req.user_agent[0] != 0)
+		init.user_agent = ws->req.user_agent;
+
+	sd = connect_to_secmod(ws);
+	if (sd == -1) {
+		oclog(ws, LOG_ERR, "failed connecting to sec mod");
+		goto fail;
+	}	
+
+	ret = send_msg_to_secmod(ws, sd, CMD_SEC_AUTH_INIT, &init,
+				 (pack_size_func)sec_auth_init_msg__get_packed_size,
+				 (pack_func)sec_auth_init_msg__pack);
+	if (ret < 0) {
+		oclog(ws, LOG_ERR, "failed sending auth init message to sec mod");
+		goto fail;
+	}
+
+	ret = recv_auth_reply(ws, sd);
+	if (ret != ERR_AUTH_CONTINUE) {
+		oclog(ws, LOG_ERR, "not in auth continue state: %d", ret);
+		goto fail;
+	}
+
+	close(sd);
+
+	cont.ip = ws->remote_ip_str;
+	cont.password = password;
+
+	if (ws->sid_set != 0) {
+		cont.sid.data = ws->sid;
+		cont.sid.len = sizeof(ws->sid);
+	}
+	
+	sd = connect_to_secmod(ws);
+	if (sd == -1) {
+		oclog(ws, LOG_ERR, "failed connecting to sec mod");
+		goto fail;
+	}
+
+	ret = send_msg_to_secmod(ws, sd, CMD_SEC_AUTH_CONT, &cont,
+				 (pack_size_func)sec_auth_cont_msg__get_packed_size, 
+				 (pack_func)sec_auth_cont_msg__pack);
+	if (ret < 0) {
+		oclog(ws, LOG_ERR, "failed sending auth cont message to sec mod");
+		goto fail;
+	}
+
+	ret = recv_auth_reply(ws, sd);
+	if (ret < 0) {
+		oclog(ws, LOG_ERR, "failed authentication for '%s'",
+		      ws->username);
+		goto fail;
+	}
+
+fail:
+	if (sd != -1)
+	     close(sd);
+	
+	return ret;
+}
+
+int post_svc_handler(worker_st *ws, unsigned http_ver)
+{
+	int ret = -1;
+	char *username = NULL, *password = NULL;
+	char cookie[BASE64_ENCODE_RAW_LENGTH(sizeof(ws->cookie)) + 1];
+
+	/* fail if username or password is missing */
+	ret = parse_post_body(ws, &username, &password);
+	if (ret < 0)
+		return get_svc_handler(ws, http_ver);
+
+	ret = client_auth(ws, username, password);
+
+	talloc_free(username);
+	talloc_free(password);
+
+	if (ret < 0) {
+		oclog(ws, LOG_HTTP_DEBUG, "HTTP sending: 401 Unauthorized");
+		cstp_printf(ws, "HTTP/1.%d 401 Authentication failed\r\n"
+			    "Content-Length: 0\r\n"
+			    "\r\n", http_ver);
+
+		cstp_fatal_close(ws, GNUTLS_A_ACCESS_DENIED);
+		exit_worker(ws);
+		return -1;
+	}
+
+	ws->auth_state = S_AUTH_COOKIE;
+	oclog(ws, LOG_HTTP_DEBUG, "user '%s' obtained cookie", ws->username);
+
+	oc_base64_encode((char *)ws->cookie, sizeof(ws->cookie),
+			 cookie, sizeof(cookie));
+
+	/* reply */
+	oclog(ws, LOG_HTTP_DEBUG, "HTTP sending: 200 OK");
+
+	cstp_cork(ws);
+	ret = cstp_printf(ws, "HTTP/1.%u 200 OK\r\n", http_ver);
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_puts(ws, "Connection: Keep-Alive\r\n");
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_puts(ws, "Content-Type: text/xml\r\n");
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_printf(ws, "Content-Length: %u\r\n",
+			  (unsigned int)sizeof(svc_success_body) - 1);
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_printf(ws, "Set-Cookie: webvpn=%s; secure\r\n", cookie);
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_printf(ws,
+			  "Set-Cookie: webvpnc=bu:/&p:t&iu:1/&sh:%s; path=/; secure\r\n",
+			  WSPCONFIG(ws)->cert_hash);
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_puts(ws, "Set-Cookie: webvpnlogin=1; secure\r\n");
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_puts(ws, "X-Transcend-Version: 1\r\n");
+	if (ret < 0)
+		return -1;
+
+	/* end of headers */
+	ret = cstp_puts(ws, "\r\n");
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_puts(ws, svc_success_body);
+	if (ret < 0)
+		return -1;
+
+	ret = cstp_uncork(ws);
+	if (ret < 0)
+		return -1;
+
+	return 0;
+}
